<!DOCTYPE html>
<html lang="ko" x-data>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sevit Studio</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {}
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script>
        document.addEventListener('alpine:init', () => {
            const CONSTANTS = {
                LOCAL_STORAGE_KEY: 'promptStudioData_v6.0_renewal', // Version up
                PROMPT_CHAR_LIMIT: 500,
                IMAGE_SIZE_LIMIT_MB: 20,
                GEMINI_SAFETY_SETTINGS: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ],
                // --- Refined & New AI Prompts for Modal ---
                'line-cleanup': 'Analyze the attached rough sketch image and refine it into clean, well-defined line art. Preserve the original composition and character poses.',
                'sketch-complete': 'Based on the attached sketch image, complete a creative and detailed final image.',
                colorize: 'Do not damage the original lines of the attached image, and color it naturally.',
                'background-removal': 'Identify the main subject in the image and completely remove the background, leaving the subject on a transparent canvas.',
                'quality-enhance': 'Perform a comprehensive quality enhancement on the provided image. Upscale the resolution, sharpen the details, and remove any digital noise or grain. The core subject, composition, and style of the original image must be strictly preserved.',
                'id-photo': "You are provided with two images:\n- Image 1: A blank, pure white vertical canvas for the background.\n- Image 2: A portrait of a person.\n\nYour primary goal is to preserve the identity and all core facial features of the person in Image 2 while adjusting their portrait to meet the standards of a Korean ID photo on the white canvas of Image 1.\n\nModify the person from Image 2 with the following minimal adjustments:\n\n1. Pose & Composition: Adjust the pose to be strictly frontal. Center the subject on the canvas, ensuring proper headroom. Crucially, do not alter the subject's inherent facial structure.\n\n2. Expression: Subtly shift the facial expression to neutral with the mouth closed. Avoid any significant changes that would alter the person's likeness.\n\n3. Lighting & Tone: Balance the existing lighting to be even and frontal. Do not re-light from scratch. Your task is to soften or remove harsh shadows on the face and background while faithfully maintaining the original skin tone and facial details.\n\n4. Hair & Accessories: Ensure hair does not cover the eyes or eyebrows. Remove any non-essential items like hats, sunglasses, or headphones.\n\n5. Final Output: The result must clearly be the same person from Image 2, now presented as a high-quality, sharp, and clear studio-lit portrait."
            };
            
            Alpine.data('keywordGroup', (group) => ({
                group: group,
                isAddingTab: false,
                newTabName: '',
                getKeywordsForActiveTab() {
                    const activeTab = this.group.tabs.find(t => t.name === this.group.activeTab);
                    if (!activeTab) return [];
                    return activeTab.keywordIds.map(id => this.group.keywords.find(k => k.id === id)).filter(Boolean);
                },
                get filteredKeywords() {
                    let keywords = this.getKeywordsForActiveTab();
                    const searchTerm = Alpine.store('app').keywordLibrary.searchTerm;
                    if (searchTerm) {
                        const termLower = searchTerm.toLowerCase();
                        keywords = keywords.filter(item => 
                            item.keyword.toLowerCase().includes(termLower) ||
                            (item.desc && item.desc.toLowerCase().includes(termLower))
                        );
                    }
                    return keywords;
                },
                get filteredCount() {
                    return this.group.keywords ? this.group.keywords.length : 0;
                },
                get hasSearchResults() {
                    if (!Alpine.store('app').keywordLibrary.searchTerm) return true;
                    
                    const term = Alpine.store('app').keywordLibrary.searchTerm.toLowerCase();
                    const groupName = this.group.isDefault ? { subject: 'ì£¼ì œ', details: 'ì„¸ë¶€ ë¬˜ì‚¬', style: 'í‘œí˜„ ê¸°ë²•', composition: 'êµ¬ë„' }[this.group.id] : this.group.name;
                    if (groupName && groupName.toLowerCase().includes(term)) return true;

                    return this.group.tabs.some(tab => {
                        if (tab.name.toLowerCase().includes(term)) return true;
                        return tab.keywordIds.some(id => {
                            const keyword = this.group.keywords.find(k => k.id === id);
                            return keyword && (
                                keyword.keyword.toLowerCase().includes(term) ||
                                (keyword.desc && keyword.desc.toLowerCase().includes(term))
                            );
                        });
                    });
                },
                confirmAddTab() {
                    const name = this.newTabName.trim();
                    if (!name) return;
                    
                    if (this.group && !this.group.tabs.some(t => t.name.toLowerCase() === name.toLowerCase())) {
                        this.group.tabs.push({ name: name, keywordIds: [] });
                        this.group.activeTab = name;
                        Alpine.store('app').saveState(false);
                    }
                    this.isAddingTab = false;
                    this.newTabName = '';
                }
            }));

            Alpine.data('promptBoardArea', (areaKey, title) => ({
                key: areaKey,
                title: title,
                get keywords() {
                    return Alpine.store('app').promptBoard[this.key] || [];
                }
            }));
            
            Alpine.store('app', {
                constants: CONSTANTS,
                keywordLibrary: { 
                    defaultGroups: [
                        { 
                            id: 'subject', 
                            keywords: [
                                { id: 1001, type: 'keyword', keyword: 'Man', desc: 'ë‚¨ì„±' }, { id: 1002, type: 'keyword', keyword: 'Woman', desc: 'ì—¬ì„±' }, { id: 1003, type: 'keyword', keyword: 'Boy', desc: 'ì†Œë…„' }, { id: 1004, type: 'keyword', keyword: 'Girl', desc: 'ì†Œë…€' }, { id: 1005, type: 'keyword', keyword: 'Old Man', desc: 'ë…¸ì¸ (ë‚¨)' }, { id: 1006, type: 'keyword', keyword: 'Old Woman', desc: 'ë…¸ì¸ (ì—¬)' }, { id: 1007, type: 'keyword', keyword: 'Knight', desc: 'ê¸°ì‚¬' }, { id: 1008, type: 'keyword', keyword: 'Wizard', desc: 'ë§ˆë²•ì‚¬' }, { id: 1009, type: 'keyword', keyword: 'Cyborg', desc: 'ì‚¬ì´ë³´ê·¸' }, { id: 1010, type: 'keyword', keyword: 'Elf', desc: 'ì—˜í”„' },
                                { id: 1011, type: 'keyword', keyword: 'Cat', desc: 'ê³ ì–‘ì´' }, { id: 1012, type: 'keyword', keyword: 'Dog', desc: 'ê°œ' }, { id: 1013, type: 'keyword', keyword: 'Wolf', desc: 'ëŠ‘ëŒ€' }, { id: 1014, type: 'keyword', keyword: 'Fox', desc: 'ì—¬ìš°' }, { id: 1015, type: 'keyword', keyword: 'Bird', desc: 'ìƒˆ' }, { id: 1016, type: 'keyword', keyword: 'Dragon', desc: 'ìš©' }, { id: 1017, type: 'keyword', keyword: 'Phoenix', desc: 'ë¶ˆì‚¬ì¡°' }, { id: 1018, type: 'keyword', keyword: 'Unicorn', desc: 'ìœ ë‹ˆì½˜' },
                                { id: 1019, type: 'keyword', keyword: 'Cityscape', desc: 'ë„ì‹œ í’ê²½' }, { id: 1020, type: 'keyword', keyword: 'Forest', desc: 'ìˆ²' }, { id: 1021, type: 'keyword', keyword: 'Ocean', desc: 'ëŒ€ì–‘' }, { id: 1022, type: 'keyword', keyword: 'Mountains', desc: 'ì‚°ë§¥' }, { id: 1023, type: 'keyword', keyword: 'Sky', desc: 'í•˜ëŠ˜' }, { id: 1024, type: 'keyword', keyword: 'Outer Space', desc: 'ìš°ì£¼ ê³µê°„' }, { id: 1025, type: 'keyword', keyword: 'Ruins', desc: 'íí—ˆ' }, { id: 1026, type: 'keyword', keyword: 'Library', desc: 'ë„ì„œê´€' },
                                { id: 1027, type: 'keyword', keyword: 'Sword', desc: 'ê²€' }, { id: 1028, type: 'keyword', keyword: 'Book', desc: 'ì±…' }, { id: 1029, type: 'keyword', keyword: 'Spaceship', desc: 'ìš°ì£¼ì„ ' }, { id: 1030, type: 'keyword', keyword: 'Car', desc: 'ìžë™ì°¨' }, { id: 1031, type: 'keyword', keyword: 'Cap', desc: 'ëª¨ìž' }, { id: 1032, type: 'keyword', keyword: 'Umbrella', desc: 'ìš°ì‚°' }, { id: 1033, type: 'keyword', keyword: 'Flower', desc: 'ê½ƒ' }, { id: 1034, type: 'keyword', keyword: 'Camera', desc: 'ì‚¬ì§„ê¸°' }, { id: 1035, type: 'keyword', keyword: 'Microphone', desc: 'ë§ˆì´í¬' }, { id: 1036, type: 'keyword', keyword: 'Guitar', desc: 'ê¸°íƒ€' }, { id: 1037, type: 'keyword', keyword: 'Mobile', desc: 'ìŠ¤ë§ˆíŠ¸í°' }, { id: 1038, type: 'keyword', keyword: 'Newspaper', desc: 'ì‹ ë¬¸' }, { id: 1039, type: 'keyword', keyword: 'Bag', desc: 'ê°€ë°©' }
                            ], 
                            collapsed: true, 
                            isDefault: true,
                            activeTab: 'ì¸ë¬¼',
                            tabs: [
                                { name: 'ì¸ë¬¼', keywordIds: [1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010] },
                                { name: 'ë™ë¬¼', keywordIds: [1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018] },
                                { name: 'ë°°ê²½', keywordIds: [1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026] },
                                { name: 'ì‚¬ë¬¼', keywordIds: [1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039] }
                            ]
                        },
                        { 
                            id: 'details', 
                            keywords: [
                                { id: 2001, type: 'keyword', keyword: 'Long Hair', desc: 'ê¸´ ë¨¸ë¦¬' }, { id: 2002, type: 'keyword', keyword: 'Short Hair', desc: 'ì§§ì€ ë¨¸ë¦¬' }, { id: 2003, type: 'keyword', keyword: 'Blonde Hair', desc: 'ê¸ˆë°œ' }, { id: 2004, type: 'keyword', keyword: 'Red Eyes', desc: 'ë¶‰ì€ ëˆˆ' }, { id: 2005, type: 'keyword', keyword: 'Blue Eyes', desc: 'íŒŒëž€ ëˆˆ' }, { id: 2006, type: 'keyword', keyword: 'Glowing Eyes', desc: 'ë¹›ë‚˜ëŠ” ëˆˆ' }, { id: 2007, type: 'keyword', keyword: 'Muscular', desc: 'ê·¼ìœ¡ì§ˆ' }, { id: 2008, type: 'keyword', keyword: 'Detailed Face', desc: 'ìƒì„¸í•œ ì–¼êµ´' }, { id: 2009, type: 'keyword', keyword: 'Jewelry', desc: 'ë³´ì„' }, { id: 2010, type: 'keyword', keyword: 'Tattoo', desc: 'ë¬¸ì‹ ' },
                                { id: 2011, type: 'keyword', keyword: 'Dress', desc: 'ë“œë ˆìŠ¤' }, { id: 2012, type: 'keyword', keyword: 'Suit', desc: 'ì •ìž¥' }, { id: 2013, type: 'keyword', keyword: 'Armor', desc: 'ê°‘ì˜·' }, { id: 2014, type: 'keyword', keyword: 'Hoodie', desc: 'í›„ë“œí‹°' }, { id: 2015, type: 'keyword', keyword: 'School Uniform', desc: 'êµë³µ' }, { id: 2016, type: 'keyword', keyword: 'Sunglasses', desc: 'ì„ ê¸€ë¼ìŠ¤' }, { id: 2017, type: 'keyword', keyword: 'Hat', desc: 'ëª¨ìž' }, { id: 2018, type: 'keyword', keyword: 'Boots', desc: 'ë¶€ì¸ ' }, { id: 2019, type: 'keyword', keyword: 'Cape', desc: 'ë§í† ' }, { id: 5001, type: 'keyword', keyword: 'Barefoot', desc: 'ë§¨ë°œ' }, { id: 5002, type: 'keyword', keyword: 'Jeans', desc: 'ì²­ë°”ì§€' }, { id: 5003, type: 'keyword', keyword: 'Crop Top', desc: 'í¬ë¡­íƒ‘' },
                                { id: 2033, type: 'keyword', keyword: 'Neutral', desc: 'ë¬´í‘œì •' }, { id: 2020, type: 'keyword', keyword: 'Joy', desc: 'ê¸°ì¨' }, { id: 2021, type: 'keyword', keyword: 'Sadness', desc: 'ìŠ¬í””' }, { id: 2029, type: 'keyword', keyword: 'Anger', desc: 'í™”ë‚¨' }, { id: 2030, type: 'keyword', keyword: 'Fear', desc: 'ê³µí¬' }, { id: 2031, type: 'keyword', keyword: 'Surprise', desc: 'ë†€ëžŒ' }, { id: 2032, type: 'keyword', keyword: 'Disgust', desc: 'í˜ì˜¤' }, { id: 2037, type: 'keyword', keyword: 'Wink', desc: 'ìœ™í¬' }, { id: 2041, type: 'keyword', keyword: 'Pout', desc: 'ì‚ì§' }, { id: 2042, type: 'keyword', keyword: 'Slight Tongue', desc: 'í˜€' }, { id: 2043, type: 'keyword', keyword: 'Sullen', desc: 'ì‹œë¬´ë£©' }, { id: 2044, type: 'keyword', keyword: 'Kiss Face', desc: 'í‚¤ìŠ¤' },
                                { id: 2022, type: 'keyword', keyword: 'Looking At Viewer', desc: 'ë°”ë¼ë³´ëŠ”' }, { id: 2023, type: 'keyword', keyword: 'Sit', desc: 'ì•‰ì•„ìžˆëŠ”' }, { id: 2024, type: 'keyword', keyword: 'Standing', desc: 'ì„œìžˆëŠ”' }, { id: 2025, type: 'keyword', keyword: 'Run', desc: 'ë‹¬ë¦¬ëŠ”' }, { id: 2026, type: 'keyword', keyword: 'Jump', desc: 'ì í”„í•˜ëŠ”' }, { id: 2027, type: 'keyword', keyword: 'Holding', desc: 'ë“¤ê³ ìžˆëŠ”' }, { id: 2028, type: 'keyword', keyword: 'Glowing', desc: 'ë¹›ë‚˜ëŠ”' },  { id: 2034, type: 'keyword', keyword: 'Cartwheel', desc: 'ìž¬ì£¼ë„˜ê¸°' }, { id: 2035, type: 'keyword', keyword: 'Lie', desc: 'ëˆ•ë‹¤' }, { id: 2036, type: 'keyword', keyword: 'Prone', desc: 'ì—Žë“œë¦¬ë‹¤' },  { id: 2038, type: 'keyword', keyword: 'Hug', desc: 'ê»´ì•ˆë‹¤' }, { id: 2039, type: 'keyword', keyword: 'Punch', desc: 'íŽ€ì¹˜' }, { id: 2040, type: 'keyword', keyword: 'Kick', desc: 'ë°œì°¨ê¸°' }                           
                            ], 
                            collapsed: true, 
                            isDefault: true,
                            activeTab: 'ì™¸í˜•',
                            tabs: [
                                { name: 'ì™¸í˜•', keywordIds: [2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010] },
                                { name: 'ì˜ìƒ', keywordIds: [2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 5001, 5002, 5003] },
                                { name: 'í‘œì •', keywordIds: [2033, 2020, 2021, 2029, 2030, 2031, 2032, 2037, 2041,2042, 2043, 2044] },
                                { name: 'ë™ìž‘', keywordIds: [2022, 2023, 2024, 2025, 2026, 2027, 2028, 2034, 2035, 2036, 2038, 2039, 2040] }
                            ]
                        },
                        { 
                            id: 'style', 
                            keywords: [
                                { id: 3001, type: 'keyword', keyword: 'Anime', desc: 'ì• ë‹ˆë©”ì´ì…˜' }, { id: 3002, type: 'keyword', keyword: 'Manga', desc: 'ë§Œí™”' }, { id: 3003, type: 'keyword', keyword: 'Concept Art', desc: 'ì»¨ì…‰ ì•„íŠ¸' }, { id: 3004, type: 'keyword', keyword: 'Pixel Art', desc: 'í”½ì…€ ì•„íŠ¸' }, { id: 3005, type: 'keyword', keyword: 'Realistic', desc: 'ì‚¬ì‹¤ì ì¸' }, { id: 3006, type: 'keyword', keyword: 'Photorealistic', desc: 'ì‚¬ì§„ê°™ì€' }, { id: 3007, type: 'keyword', keyword: 'Impressionism', desc: 'ì¸ìƒì£¼ì˜' }, { id: 3008, type: 'keyword', keyword: 'Studio Ghibli Style', desc: 'ì§€ë¸Œë¦¬ ìŠ¤íƒ€ì¼' }, { id: 5004, type: 'keyword', keyword: 'Shinkai Makoto Style', desc: 'ì‹ ì¹´ì´ ë§ˆì½”í†  ìŠ¤íƒ€ì¼' }, { id: 5005, type: 'keyword', keyword: 'Playmobil', desc: 'í”Œë ˆì´ëª¨ë¹Œ' }, { id: 5006, type: 'keyword', keyword: 'Korean', desc: 'í•œêµ­ì ì¸' }, { id: 5007, type: 'keyword', keyword: 'Japanese', desc: 'ì¼ë³¸ì ì¸' },
                                { id: 3009, type: 'keyword', keyword: 'Fantasy', desc: 'íŒíƒ€ì§€' }, { id: 3010, type: 'keyword', keyword: 'Sci-Fi', desc: 'ê³µìƒê³¼í•™' }, { id: 3011, type: 'keyword', keyword: 'Cyberpunk', desc: 'ì‚¬ì´ë²„íŽ‘í¬' }, { id: 3012, type: 'keyword', keyword: 'Steampunk', desc: 'ìŠ¤íŒ€íŽ‘í¬' }, { id: 3013, type: 'keyword', keyword: 'Horror', desc: 'í˜¸ëŸ¬' }, { id: 3014, type: 'keyword', keyword: 'Dystopian', desc: 'ë””ìŠ¤í† í”¼ì•„' }, { id: 3015, type: 'keyword', keyword: 'Post-Apocalyptic', desc: 'í¬ìŠ¤íŠ¸ ì•„í¬ì¹¼ë¦½ìŠ¤' },
                                { id: 3016, type: 'keyword', keyword: 'Cinematic Lighting', desc: 'ì˜í™”ì  ì¡°ëª…' }, { id: 3017, type: 'keyword', keyword: 'Dramatic Lighting', desc: 'ë“œë¼ë§ˆí‹± ì¡°ëª…' }, { id: 3018, type: 'keyword', keyword: 'Glowing', desc: 'ë°œê´‘' }, { id: 3019, type: 'keyword', keyword: 'Dark', desc: 'ì–´ë‘ìš´' }, { id: 3020, type: 'keyword', keyword: 'Vibrant Colors', desc: 'ìƒìƒí•œ ìƒ‰ê°' }, { id: 3021, type: 'keyword', keyword: 'Monochrome', desc: 'ë‹¨ìƒ‰' }, { id: 3022, type: 'keyword', keyword: 'Night', desc: 'ë°¤' }, { id: 3028, type: 'keyword', keyword: 'Day', desc: 'ë‚®' }, { id: 3029, type: 'keyword', keyword: 'Dawn', desc: 'ìƒˆë²½' }, { id: 3030, type: 'keyword', keyword: 'Rain', desc: 'ë¹„' }, { id: 3031, type: 'keyword', keyword: 'Spring', desc: 'ë´„' }, { id: 3032, type: 'keyword', keyword: 'Summer', desc: 'ì—¬ë¦„' }, { id: 3033, type: 'keyword', keyword: 'Fall', desc: 'ê°€ì„' }, { id: 3034, type: 'keyword', keyword: 'Winter', desc: 'ê²¨ìš¸' }, { id: 3035, type: 'keyword', keyword: 'Wind', desc: 'ë°”ëžŒ' },
                                { id: 3023, type: 'keyword', keyword: 'Oil Painting', desc: 'ìœ í™”' }, { id: 3024, type: 'keyword', keyword: 'Watercolor', desc: 'ìˆ˜ì±„í™”' }, { id: 3025, type: 'keyword', keyword: 'Sketch', desc: 'ìŠ¤ì¼€ì¹˜' }, { id: 3026, type: 'keyword', keyword: '3D Render', desc: '3D ë Œë”' }, { id: 3027, type: 'keyword', keyword: 'Cel Shading', desc: 'ì…€ ì…°ì´ë”©' }
                            ], 
                            collapsed: true, 
                            isDefault: true,
                            activeTab: 'í™”í’',
                            tabs: [
                                { name: 'í™”í’', keywordIds: [3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 5004, 5005, 5006, 5007] },
                                { name: 'ìž¥ë¥´', keywordIds: [3009, 3010, 3011, 3012, 3013, 3014, 3015] },
                                { name: 'ë¶„ìœ„ê¸°', keywordIds: [3016, 3017, 3018, 3019, 3020, 3021, 3022, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035] },
                                { name: 'ë§¤ì²´', keywordIds: [3023, 3024, 3025, 3026, 3027] }
                            ]
                        },
                        { 
                            id: 'composition', 
                            keywords: [
                                { id: 4001, type: 'keyword', keyword: 'Full Body', desc: 'ì „ì‹  ìƒ·' }, { id: 4002, type: 'keyword', keyword: 'Portrait', desc: 'ì´ˆìƒí™”' }, { id: 4003, type: 'keyword', keyword: 'Close-Up', desc: 'í´ë¡œì¦ˆì—…' }, { id: 4004, type: 'keyword', keyword: 'Cowboy Shot', desc: 'ì¹´ìš°ë³´ì´ ìƒ·' }, { id: 4005, type: 'keyword', keyword: 'Low Angle', desc: 'ë¡œìš° ì•µê¸€' }, { id: 4006, type: 'keyword', keyword: 'High Angle', desc: 'í•˜ì´ ì•µê¸€' }, { id: 4007, type: 'keyword', keyword: 'Dynamic Angle', desc: 'ì—­ë™ì  ì•µê¸€' }, { id: 4008, type: 'keyword', keyword: 'Profile Shot', desc: 'ì¸¡ë©´ ìƒ·' },
                                { id: 4009, type: 'keyword', keyword: 'Masterpiece', desc: 'ê±¸ìž‘' }, { id: 4010, type: 'keyword', keyword: 'Best Quality', desc: 'ìµœê³  í’ˆì§ˆ' }, { id: 4011, type: 'keyword', keyword: '4K', desc: '4K í•´ìƒë„' }, { id: 4012, type: 'keyword', keyword: '8K', desc: '8K í•´ìƒë„' }, { id: 4013, type: 'keyword', keyword: 'High Resolution', desc: 'ê³ í•´ìƒë„' }, { id: 4014, type: 'keyword', keyword: 'Detailed', desc: 'ë””í…Œì¼í•œ' }, { id: 4015, type: 'keyword', keyword: 'Bokeh', desc: 'ë³´ì¼€ (ë°°ê²½ íë¦¼)' }, { id: 4016, type: 'keyword', keyword: 'Lens Flare', desc: 'ë Œì¦ˆ í”Œë ˆì–´' }, { id: 4017, type: 'keyword', keyword: 'Motion Blur', desc: 'ëª¨ì…˜ ë¸”ëŸ¬' }
                            ], 
                            collapsed: true, 
                            isDefault: true,
                            activeTab: 'ìƒ·/ì•µê¸€',
                            tabs: [
                                { name: 'ìƒ·/ì•µê¸€', keywordIds: [4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008] },
                                { name: 'í’ˆì§ˆ/íš¨ê³¼', keywordIds: [4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017] }
                            ]
                        }
                    ],
                    userGroups: [],
                    searchTerm: '',
                    preSearchCollapsedState: null,
                    preSearchActiveTabState: null,
                    tabDeleteState: { active: false, groupId: null }
                },

                settings: { 
                    apiKey: '', 
                    aiKeywordSupport: true,
                    referenceImageCount: 1,
                    generationModel: 'gemini', // 'imagen' or 'gemini'
                    aspectRatio: '1:1',
                    interpretationLevel: 'balanced', // 'precise', 'balanced', 'creative'
                    numberOfImages: 1
                },
                promptBoard: { 
                    subject: [], 
                    details: [], 
                    style: [], 
                    composition: [], 
                    manualPrompt: '', 
                    activeKeywordIds: [],
                    draggingItem: null
                },
                promptBoardAreaInfo: [
                    { key: 'subject', title: '1. ì£¼ì œ (Subject)' },
                    { key: 'details', title: '2. ì„¸ë¶€ ë¬˜ì‚¬ (Details)' },
                    { key: 'style', title: '3. í‘œí˜„ ê¸°ë²• (Style)' },
                    { key: 'composition', title: '4. êµ¬ë„ (Composition)' }
                ],
                aspectRatioOptions: [
                    { ratio: '1:1', desc: 'ì •ì‚¬ê°í˜•' },
                    { ratio: '4:3', desc: 'ì‚¬ì§„ (ê°€ë¡œ)' },
                    { ratio: '3:4', desc: 'ì‚¬ì§„ (ì„¸ë¡œ)' },
                    { ratio: '16:9', desc: 'HD ì˜ìƒ (ê°€ë¡œ)' },
                    { ratio: '9:16', desc: 'ìŠ¤ë§ˆíŠ¸í° (ì„¸ë¡œ)' }
                ],
                history: [],
                presets: [],
                imageStation: { 
                    images: [],
                    draggingItem: null
                },
                ui: {
                    manualPromptPosition: 'append',
                    isToolboxOpen: false,
                    isPromptBoardCollapsed: true,
                    activeModal: null, 
                    modalData: {},
                    toast: {
                        show: false,
                        message: ''
                    },
                    isLoadingCompletion: false,
                    isLoadingImage: false,
                    isLoadingTranslation: false,
                    generatedImageUrl: null,
                    selectedImageId: null,
                    historySearchTerm: '',
                    presetSearchTerm: '',
                    editingPresetId: null,
                    isImageInfoPinned: false,
                    currentImageInfo: { name: '', resolution: '', size: '' },
                    moveMenu: { 
                        visible: false, 
                        top: 0, 
                        left: 0, 
                        keyword: null, 
                        fromGroupId: null, 
                        fromTabName: null 
                    },
                    addMenu: {
                        visible: false,
                        top: 0,
                        left: 0,
                        keyword: null
                    }
                },

                // [NEW] Master table to dynamically build the infuse panel
                infuseMasterTable: {
                    expression: {
                        title: 'í‘œì •',
                        recipes: [
                            { keywordId: 2033, display: 'ðŸ˜‘' }, // neutral
                            { keywordId: 2020, display: 'ðŸ˜Š' }, // joy
                            { keywordId: 2021, display: 'ðŸ˜¢' }, // sadness
                            { keywordId: 2029, display: 'ðŸ˜¡' }, // anger
                            { keywordId: 2030, display: 'ðŸ˜¨' }, // fear
                            { keywordId: 2031, display: 'ðŸ˜²' }, // surprise
                            { keywordId: 2032, display: 'ðŸ˜£' }, // disgust
                            { keywordId: 2043, display: 'ðŸ˜ž' }, // sullen
                            { keywordId: 2041, display: 'ðŸ˜¤' }, // pout
                            { keywordId: 2037, display: 'ðŸ˜‰' }, // wink
                            { keywordId: 2044, display: 'ðŸ˜˜' }, // kiss face
                            { keywordId: 2042, display: 'ðŸ˜‹' }  // slight tongue
                        ]
                    },
                    action: {
                        title: 'ë™ìž‘',
                        recipes: [
                            { keywordId: 2023, display: 'ðŸ§˜' }, // sit
                            { keywordId: 2025, display: 'ðŸƒ' }, // run
                            { keywordId: 2026, display: 'ðŸ¤¸' }, // jump
                            { keywordId: 2035, display: 'ðŸ›Œ' }, // lie
                            { keywordId: 2038, display: 'ðŸ¤—' }, // hug
                            { keywordId: 2034, display: 'ðŸ¤¸â€â™‚ï¸' }, // cartwheel
                            { keywordId: 2039, display: 'ðŸ‘Š' }, // punch
                            { keywordId: 2040, display: 'ðŸ‘Ÿ' }  // kick
                        ]
                    },
                    props: {
                        title: 'ì†Œí’ˆ',
                        recipes: [
                            { keywordId: 1031, display: 'ðŸ§¢' }, // cap
                            { keywordId: 1032, display: 'â˜‚ï¸' }, // umbrella
                            { keywordId: 1033, display: 'ðŸ’' }, // flower
                            { keywordId: 1028, display: 'ðŸ“–' }, // book
                            { keywordId: 1039, display: 'ðŸ‘œ' }, // bag
                            { keywordId: 1034, display: 'ðŸ“·' }, // camera
                            { keywordId: 1036, display: 'ðŸŽ¸' }, // guitar
                            { keywordId: 1035, display: 'ðŸŽ¤' }, // microphone
                            { keywordId: 1037, display: 'ðŸ“±' }, // mobile
                            { keywordId: 1038, display: 'ðŸ“°' }, // newspaper
                            { keywordId: 1027, display: 'âš”ï¸' }, // sword
                            { keywordId: 1011, display: 'ðŸ±' }, // cat
                            { keywordId: 1012, display: 'ðŸ¶' }, // dog
                        ]
                    },
                    environment: {
                        title: 'í™˜ê²½',
                        recipes: [
                            { keywordId: 3028, display: 'â˜€ï¸' },  // day
                            { keywordId: 3022, display: 'ðŸŒ™' },  // night
                            { keywordId: 3031, display: 'ðŸŒ±' },  // spring
                            { keywordId: 3032, display: 'ðŸ–ï¸' },  // summer
                            { keywordId: 3033, display: 'ðŸ‚' },  // fall
                            { keywordId: 3034, display: 'â„ï¸' },  // winter
                            { keywordId: 3030, display: 'ðŸŒ§ï¸' },  // rain
                            { keywordId: 3035, display: 'ðŸŒªï¸' }   // wind
                        ]
                    },
                    angle: {
                        title: 'ì•µê¸€',
                        recipes: [
                            { keywordId: 4001, display: 'ðŸ“¹ðŸ§â€â™€ï¸' }, // full body
                            { keywordId: 4003, display: 'ðŸ“¹ðŸ‘©' }, // close-up
                            { keywordId: 4005, display: 'â¬‡ï¸' }, // low angle
                            { keywordId: 4006, display: 'â¬†ï¸' }  // high angle
                        ]
                    }
                },

                // [NEW] Helper function to get keyword details from the main library
                getKeywordById(id) {
                    for (const group of [...this.keywordLibrary.defaultGroups, ...this.keywordLibrary.userGroups]) {
                        const found = group.keywords.find(k => k.id === id);
                        if (found) return found;
                    }
                    return null; // Return null if not found
                },
                // --- Computed Properties ---
                get isPromptBoardEmpty() {
                    return this.getFinalPrompt().length === 0;
                },
                get promptLengthInfo() {
                    const current = this.getFinalPrompt().length;
                    const max = this.constants.PROMPT_CHAR_LIMIT;
                    return {
                        current,
                        max,
                        exceeds: current > max
                    };
                },
                get referenceImagesSizeInfo() {
                    const maxMB = this.constants.IMAGE_SIZE_LIMIT_MB;
                    const imagesToConsider = this.imageStation.images.slice(0, this.settings.referenceImageCount);
                    if (imagesToConsider.length === 0) {
                        return { current: 0, max: maxMB, exceeds: false };
                    }
                    // Simplified and more direct calculation of Base64 string size
                    const totalBytes = imagesToConsider.reduce((sum, img) => {
                        return sum + (img.dataUrl.length || 0);
                    }, 0);

                    const currentMB = totalBytes / (1024 * 1024);
                    return {
                        current: currentMB,
                        max: maxMB,
                        exceeds: currentMB > maxMB
                    };
                },
                 get filteredHistory() {
                    if (!this.ui.historySearchTerm) return this.history;
                    const term = this.ui.historySearchTerm.toLowerCase();
                    return this.history.filter(item => item.promptText.toLowerCase().includes(term));
                },
                get filteredPresets() {
                    if (!this.ui.presetSearchTerm) return this.presets;
                    const term = this.ui.presetSearchTerm.toLowerCase();
                    return this.presets.filter(item => 
                        item.name.toLowerCase().includes(term) ||
                        item.promptText.toLowerCase().includes(term)
                    );
                },

                // =================================================================
                // API GATEWAY
                // =================================================================
                getApiKey() {
                    if (typeof __api_key !== 'undefined' && __api_key) {
                        return __api_key;
                    }
                    return this.settings.apiKey || "";
                },

                // í…ìŠ¤íŠ¸ ìƒì„± ì „ìš© ê²Œì´íŠ¸ì›¨ì´
                async callTextAPI(systemPrompt, userQuery, temperature = 1.0) {
                    const apiKey = this.getApiKey();
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        safetySettings: this.constants.GEMINI_SAFETY_SETTINGS,
                        generationConfig: {
                            temperature: temperature
                        }
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => null);
                        const message = errorData?.error?.message || `API Error: ${response.status}`;
                        throw new Error(message);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        return text.replace(/```json|```/g, '').trim();
                    } else {
                        const reason = this.getFailureReason(result);
                        const reasonMap = {
                            recitation: "ì €ìž‘ê¶Œ", other: "ê¸°íƒ€", sexually_explicit: "ì„±ì  ì½˜í…ì¸ ", hate_speech: "í˜ì˜¤ ë°œì–¸",
                            harassment: "ê´´ë¡­íž˜", dangerous_content: "í­ë ¥/ìœ„í—˜"
                        };
                        if (reason !== 'other') {
                             throw new Error(reasonMap[reason] || "ì•Œ ìˆ˜ ì—†ëŠ” ì´ìœ ");
                        }
                        throw new Error("No content in API response.");
                    }
                },

                // Gemini ì´ë¯¸ì§€ ëª¨ë¸(ë‚˜ë…¸ë°”ë‚˜ë‚˜) ì „ìš© ê²Œì´íŠ¸ì›¨ì´
                async callImageAPI(prompt, images = [], mask = null, numberOfImages = 1) {
                    const apiKey = this.getApiKey();

                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                    
                    const parts = [{ text: prompt }];
                    images.forEach(image => parts.push({ inlineData: { mimeType: 'image/png', data: image.dataUrl.split(',')[1] } }));
                    if (mask) {
                        parts.push({ inlineData: { mimeType: 'image/png', data: mask.split(',')[1] } });
                    }

                    const payload = {
                        contents: [{ parts }],
                        generationConfig: { 
                            responseModalities: ['IMAGE'],
                            candidateCount: numberOfImages
                        },
                        safetySettings: this.constants.GEMINI_SAFETY_SETTINGS
                    };

                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                    if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                    return await response.json();
                },

                // Imagen 3 ëª¨ë¸ ì „ìš© ê²Œì´íŠ¸ì›¨ì´
                async callImagenAPI(prompt, numberOfImages = 1) {
                    const apiKey = this.getApiKey();
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                    
                    const parameters = { 
                        "personGeneration": "ALLOW_ALL",
                        "aspectRatio": this.settings.aspectRatio,
                        "sampleCount": numberOfImages
                    };

                    const payload = { 
                        instances: [{ prompt }], 
                        parameters
                    };
                    
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    
                    if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                    return await response.json();
                },

                async callMultimodalTextAPI(systemPrompt, userQuery, images = []) {
                    const apiKey = this.getApiKey();
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                    const parts = [{ text: userQuery }];
                    images.forEach(image => parts.push({ inlineData: { mimeType: 'image/png', data: image.dataUrl.split(',')[1] } }));

                    const payload = {
                        contents: [{ parts }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        safetySettings: this.constants.GEMINI_SAFETY_SETTINGS,
                        generationConfig: {
                            temperature: 0.5,
                            responseMimeType: "application/json",
                        }
                    };

                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => null);
                        const message = errorData?.error?.message || `API Error: ${response.status}`;
                        throw new Error(message);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        return text.replace(/```json|```/g, '').trim();
                    } else {
                        const reason = this.getFailureReason(result);
                        const reasonMap = { recitation: "ì €ìž‘ê¶Œ", other: "ê¸°íƒ€", sexually_explicit: "ì„±ì  ì½˜í…ì¸ ", hate_speech: "í˜ì˜¤ ë°œì–¸", harassment: "ê´´ë¡­íž˜", dangerous_content: "í­ë ¥/ìœ„í—˜" };
                        if (reason !== 'other') throw new Error(reasonMap[reason] || "ì•Œ ìˆ˜ ì—†ëŠ” ì´ìœ ");
                        throw new Error("API ì‘ë‹µì— ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.");
                    }
                },
                
                // =================================================================
                // AI-ASSISTED FUNCTIONS
                // =================================================================
                async callTranslationAPI(text) {
                    const systemPrompt = "You are a machine translator. Your sole task is to translate the given text into a concise English keyword or phrase suitable for an image generation AI. Do not add any explanations. The response MUST be a single JSON object with a single key 'translatedKeyword'.";
                    const userQuery = `Translate the following text into a concise English keyword or phrase:\n${text}\n\nResponse format:\n{"translatedKeyword": "..."}`;
                    
                    try {
                        const jsonString = await this.callTextAPI(systemPrompt, userQuery, 0.5);
                        const parsed = JSON.parse(jsonString);
                        return parsed.translatedKeyword || text.trim().replace(/\s+/g, ' ');
                    } catch (error) {
                        console.error("Translation API call failed:", error);
                        this.showToast(`AI ì§€ì› ì˜¤ë¥˜: ${error.message}`);
                        throw error;
                    }
                },

                async callDescriptionAPI(keyword) {
                    const lang = 'Korean';
                    const systemPrompt = `You are a helpful assistant. Your task is to write a brief, one-sentence description for the given image generation keyword. The description should be in ${lang}. The response MUST be a single JSON object with a single key 'description'.`;
                    const userQuery = `Create a description for the keyword "${keyword}".\n\nResponse format:\n{"description": "..."}`;

                    try {
                        const jsonString = await this.callTextAPI(systemPrompt, userQuery, 0.5);
                        const parsed = JSON.parse(jsonString);
                        return parsed.description || '';
                    } catch (error) {
                        console.error("Description API call failed:", error);
                        this.showToast(`AI ì§€ì› ì˜¤ë¥˜: ${error.message}`);
                        throw error;
                    }
                },
                
                async translateManualPrompt() {
                    const textToTranslate = this.promptBoard.manualPrompt.trim();
                    if (!textToTranslate) {
                        this.showToast("ë²ˆì—­í•  ë‚´ìš©ì„ ë¨¼ì € ìž…ë ¥í•´ì£¼ì„¸ìš”.");
                        return;
                    }

                    this.ui.isLoadingTranslation = true;
                    try {
                        const systemPrompt = "You are an intelligent translator. Your task is to translate the given text. Detect the source language and translate it to the other (Korean to English, or English to Korean). The response MUST be a single JSON object with a single key 'translatedText'.";
                        const userQuery = `Translate:\n${textToTranslate}\n\nResponse format:\n{"translatedText": "..."}`;
                        
                        const jsonString = await this.callTextAPI(systemPrompt, userQuery, 0.5);
                        const parsed = JSON.parse(jsonString);
                        if (parsed.translatedText) {
                            this.promptBoard.manualPrompt = parsed.translatedText;
                        } else {
                            throw new Error('Invalid JSON structure in translation response.');
                        }
                    } catch (error) {
                        console.error("Translation Error:", error);
                        this.showToast(`AI ì§€ì› ì˜¤ë¥˜: ${error.message}`);
                    } finally {
                        this.ui.isLoadingTranslation = false;
                    }
                },

                async generatePromptSentence() {
                    if (this.promptBoard.subject.length === 0) {
                        this.showToast('ë¨¼ì € "ì£¼ì œ" í‚¤ì›Œë“œë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.');
                        return;
                    }

                    const keywordText = ['subject', 'details', 'style', 'composition']
                        .map(cat => this.promptBoard[cat].map(k => k.keyword).join(', '))
                        .filter(Boolean)
                        .join(', ');

                    this.ui.isLoadingCompletion = true;
                    try {
                        const systemPrompt = "You are a world-class prompt engineer. Combine the given English keywords into a single, creative, detailed descriptive sentence in English. The response must be a single JSON object with the key 'prompt'.";
                        const userQuery = `Combine these keywords:\n${keywordText}\n\nExample format:\n{"prompt": "A cinematic portrait of a beautiful girl with long hair, cinematic lighting."}`;
                        
                        const jsonString = await this.callTextAPI(systemPrompt, userQuery, 1.0);
                        if (jsonString) {
                            const parsed = JSON.parse(jsonString);
                            if (parsed.prompt) {
                                // Rollback: Do not clear the promptBoard. Just update the manual prompt.
                                this.promptBoard.manualPrompt = parsed.prompt;
                            } else {
                                throw new Error('Invalid JSON structure in response.');
                            }
                        }
                    } catch (error) {
                        console.error("AI Prompt Completion Error:", error);
                        this.showToast(`AI ì§€ì› ì˜¤ë¥˜: ${error.message}`);
                    } finally {
                        this.ui.isLoadingCompletion = false;
                    }
                },
                
                // =================================================================
                // UTILITY FUNCTIONS
                // =================================================================
                generateFilename(model) {
                    const modelAbbr = model === 'gemini' ? 'gf' : 'im';
                    const timestamp = Date.now();
                    return `sv-${modelAbbr}-${timestamp}.png`;
                },

                getFailureReason(result) {
                    const geminiCandidate = result?.candidates?.[0];
                    if (geminiCandidate) {
                        if (geminiCandidate.finishReason === 'RECITATION') return 'recitation';
                        if (geminiCandidate.finishReason === 'OTHER') return 'other';
                        if (geminiCandidate.finishReason === 'SAFETY') {
                            const blockedRating = geminiCandidate.safetyRatings?.find(r => r.blocked);
                            if (blockedRating) return blockedRating.category.replace('HARM_CATEGORY_', '').toLowerCase();
                        }
                    }
                    const imagenPrediction = result?.predictions?.[0];
                    if (imagenPrediction?.safetyFeedback) {
                        const blockedRating = imagenPrediction.safetyFeedback.safetyRatings?.find(r => r.blocked);
                        if (blockedRating) return blockedRating.category.replace('HARM_CATEGORY_', '').toLowerCase();
                    }
                    return 'other';
                },

                getFinalPrompt() {
                    const promptOrder = ['subject', 'details', 'style', 'composition'];
                    const promptParts = promptOrder.map(areaKey => {
                        const keywords = this.promptBoard[areaKey];
                        return (keywords && keywords.length > 0) ? keywords.map(k => k.keyword).join(', ') : '';
                    }).filter(Boolean);

                    const manualPrompt = this.promptBoard.manualPrompt.trim();
                    if (manualPrompt) {
                        if (this.ui.manualPromptPosition === 'prepend') {
                            promptParts.unshift(manualPrompt);
                        } else {
                            promptParts.push(manualPrompt);
                        }
                    }
                    
                    return promptParts.join(', ');
                },
                
                showToast(message) {
                    this.ui.toast.message = message;
                    this.ui.toast.show = true;
                    setTimeout(() => {
                        this.ui.toast.show = false;
                    }, 4000);
                },

                createBlankCanvas(width, height, color = '#FFFFFF') {
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.fillRect(0, 0, width, height);
                    return canvas.toDataURL('image/png');
                },

                createBlankImageForRatio(ratioStr) {
                    let targetWidth, targetHeight;
                    switch (ratioStr) {
                        case '4:3':   targetWidth = 1280; targetHeight = 896;  break;
                        case '3:4':   targetWidth = 896;  targetHeight = 1280; break;
                        case '16:9':  targetWidth = 1408; targetHeight = 768;  break;
                        case '9:16':  targetWidth = 768;  targetHeight = 1408; break;
                        case '1:1':
                        default:
                            return null; // Don't create for 1:1
                    }
                    return this.createBlankCanvas(targetWidth, targetHeight);
                },

                _toTitleCase(str) {
                    if (!str) return '';
                    return str.split(' ').map(word => {
                        // Do not change fully uppercase words like '4K'
                        if (word.toUpperCase() === word) return word; 
                        return word.charAt(0).toUpperCase() + word.substring(1).toLowerCase();
                    }).join(' ');
                },

                // =================================================================
                // IMAGE STATION FUNCTIONS
                // =================================================================
                handleFileUpload(event) {
                    const files = event.target.files;
                    if (files.length === 0) return;
                    Array.from(files).forEach(file => this.readFileAsDataURL(file));
                    event.target.value = null;
                },

                readFileAsDataURL(file) {
                    if (!file.type.startsWith('image/')) return;
                    const reader = new FileReader();
                    reader.onload = (e) => this.addToImageStation(e.target.result, file.name);
                    reader.onerror = () => {}; 
                    reader.readAsDataURL(file);
                },

                addToImageStation(imageDataUrl, fileName = 'pasted_or_drawn_image.png', selectAfterAdding = true) {
                    const newImage = { id: Date.now() + Math.random(), dataUrl: imageDataUrl, name: fileName };
                    this.imageStation.images.push(newImage);
                    if (selectAfterAdding) {
                        this.selectImage(newImage);
                    }
                    return newImage;
                },
                
                removeFromImageStation(id) {
                    const wasCurrentlyDisplayed = this.ui.selectedImageId === id;
                    const removedIndex = this.imageStation.images.findIndex(img => img.id === id);

                    this.imageStation.images = this.imageStation.images.filter(img => img.id !== id);

                    if (wasCurrentlyDisplayed) {
                        if (this.imageStation.images.length > 0) {
                            const newIndex = Math.min(removedIndex, this.imageStation.images.length - 1);
                            this.selectImage(this.imageStation.images[newIndex]);
                        } else {
                            this.ui.generatedImageUrl = null;
                            this.ui.selectedImageId = null;
                        }
                    }
                },

                selectImage(image) {
                    if (this.ui.selectedImageId === image.id) {
                        this.ui.selectedImageId = null;
                        this.ui.generatedImageUrl = null;
                    } else {
                        this.ui.selectedImageId = image.id;
                        this.ui.generatedImageUrl = image.dataUrl;
                    }
                },

                handleImageDragStart(event, image) {
                    this.imageStation.draggingItem = image;
                    event.dataTransfer.effectAllowed = 'move';
                },

                handleImageDragOver(event, index) {
                    event.preventDefault();
                },

                handleImageDrop(event, targetIndex) {
                    event.preventDefault();
                    if (!this.imageStation.draggingItem) return;

                    const draggedItem = this.imageStation.draggingItem;
                    const fromIndex = this.imageStation.images.findIndex(img => img.id === draggedItem.id);

                    if (fromIndex === -1 || fromIndex === targetIndex) {
                        this.imageStation.draggingItem = null;
                        return;
                    }

                    const [itemToMove] = this.imageStation.images.splice(fromIndex, 1);
                    this.imageStation.images.splice(targetIndex, 0, itemToMove);
                    
                    this.imageStation.draggingItem = null;
                },

                navigateToNextImage() {
                    const images = this.imageStation.images;
                    if (images.length < 2) return;
                    const currentIndex = images.findIndex(img => img.id === this.ui.selectedImageId);
                    if (currentIndex > -1 && currentIndex < images.length - 1) {
                        this.selectImage(images[currentIndex + 1]);
                    }
                },

                navigateToPreviousImage() {
                    const images = this.imageStation.images;
                    if (images.length < 2) return;
                    const currentIndex = images.findIndex(img => img.id === this.ui.selectedImageId);
                    if (currentIndex > 0) {
                        this.selectImage(images[currentIndex - 1]);
                    }
                },

                updateImageInfo(image) {
                    if (!image) {
                        this.ui.currentImageInfo = { name: '', resolution: '', size: '' };
                        return;
                    }
                    const img = new Image();
                    img.onload = () => {
                        const sizeInBytes = image.dataUrl.length * (3 / 4) - 2; // Approximation for base64
                        const sizeInKB = sizeInBytes / 1024;
                        const sizeDisplay = sizeInKB > 1024 
                            ? `${(sizeInKB / 1024).toFixed(2)} MB` 
                            : `${sizeInKB.toFixed(1)} KB`;
                        
                        this.ui.currentImageInfo = {
                            name: image.name,
                            resolution: `${img.width}x${img.height}`,
                            size: sizeDisplay
                        };
                    };
                    img.src = image.dataUrl;
                },
                
                // =================================================================
                // IMAGE GENERATION FUNCTIONS
                // =================================================================
                async generateImage() {
                    let finalPrompt = this.getFinalPrompt();
                    
                    let imagesToSend = this.imageStation.images;

                    if (!finalPrompt && imagesToSend.length === 0) {
                        this.showToast("í”„ë¡¬í”„íŠ¸ë¥¼ ìž…ë ¥í•˜ê±°ë‚˜ ì´ë¯¸ì§€ë¥¼ ì²¨ë¶€í•´ì£¼ì„¸ìš”.");
                        return;
                    }
                    
                    this.ui.isLoadingImage = true;
                    
                    let modelToUse;
                    modelToUse = this.settings.generationModel;

                    let numberOfImagesToGenerate = this.settings.numberOfImages;

                    if (modelToUse === 'imagen') {
                        imagesToSend = [];
                    } else {
                        imagesToSend = imagesToSend.slice(0, this.settings.referenceImageCount);
                        // Gemini ì‚¬ìš© ì‹œ, ì¶œë ¥ ê°œìˆ˜ UI ë¹„í™œì„±í™” ë° ê°’ 1ë¡œ ê³ ì •
                        if (this.settings.generationModel === 'gemini') {
                             numberOfImagesToGenerate = 1;
                        }
                    }
                    
                    if (modelToUse === 'gemini' && this.settings.aspectRatio !== '1:1' && imagesToSend.length === 0) {
                        const blankImage = this.createBlankImageForRatio(this.settings.aspectRatio);
                        if (blankImage) {
                            const hackImage = { dataUrl: blankImage, name: 'ratio_hack.png' };
                            imagesToSend.unshift(hackImage);
                        }
                    }
                    
                    const level = this.settings.interpretationLevel;
                    if (level === 'precise') {
                        finalPrompt = `Prioritize a faithful representation of the provided inputs. The text prompt is a strict instruction for modification or detail. If a reference image is included, its core style, subject, and composition must be preserved as the primary foundation. The prompt is: ${finalPrompt}`;
                    } else if (level === 'creative') {
                        finalPrompt = `Use the provided inputs as creative inspiration. You have artistic freedom to dramatically reinterpret the style, composition, and mood, using the text prompt and any reference image as a starting point for a new, imaginative artwork. The prompt is: ${finalPrompt}`;
                    }

                    await this.generateImages(finalPrompt, imagesToSend, modelToUse, numberOfImagesToGenerate);

                    this.ui.isLoadingImage = false;
                },

                // [NEW] Handles all AI actions delegated from the edit canvas
                // [NEW] Handles all AI actions delegated from the edit canvas
                async executeModalAIAction(modalData) {
                    this.ui.isLoadingImage = true;
                    try {
                        let result;
                        const model = 'gemini'; // All modal actions use Gemini

                        if (modalData.mode === 'draw') {
                            const prompt = this.constants[modalData.aISupportType];
                            const imageToSend = { dataUrl: modalData.canvasData };
                            result = await this.callImageAPI(prompt, [imageToSend]);

                        } else if (modalData.mode === 'refine') {
                             const prompt = this.constants[modalData.correctionType];
                            let imagesToSend = [];
                            if (modalData.correctionType === 'id-photo') {
                                const whiteCanvasUrl = this.createBlankCanvas(903, 1161);
                                imagesToSend.push({ dataUrl: whiteCanvasUrl });
                                imagesToSend.push({ dataUrl: modalData.canvasData });
                            } else {
                                imagesToSend.push({ dataUrl: modalData.canvasData });
                            }
                            result = await this.callImageAPI(prompt, imagesToSend);

                        } else if (modalData.mode === 'inpaint' || modalData.mode === 'outpaint') {
                            const imageToSend = { dataUrl: modalData.baseImage };
                            const prompt = modalData.mode === 'inpaint' ? modalData.prompt : "Expand the canvas based on the attached image and mask. The new area should be filled in a way that is consistent with the original image's style and content.";
                            result = await this.callImageAPI(prompt, [imageToSend], modalData.mask);

                        } 
                        // Note: Infuse mode has its own separate logic inside editCanvas's executeAction.

                        // [MODIFIED] Common result handling for single-image outputs.
                        const imageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                        if (imageData) {
                            const newImageUrl = `data:image/png;base64,${imageData}`;
                            // [FIX] Redundant selectImage call removed. addToImageStation now handles selection correctly.
                            this.addToImageStation(newImageUrl, this.generateFilename(model));
                        } else {
                            const reason = this.getFailureReason(result);
                            this.showToast(`AI ì•ˆì „ ì •ì±…: ${reason}`);
                        }

                    } catch (error) {
                        console.error("Modal AI Action Error:", error);
                        this.showToast(`ìž‘ì—… ì‹¤íŒ¨: ${error.message}`);
                    } finally {
                        this.ui.isLoadingImage = false;
                    }
                },

                async generateImages(prompt, images, model, numberOfImages) {
                    try {
                        let result;
                        
                        if (model === 'gemini') {
                            const imageCount = (images.length > 0 && images[0].name === 'ratio_hack.png') ? 1 : numberOfImages;
                            result = await this.callImageAPI(prompt, images, null, imageCount);
                        } else {
                            result = await this.callImagenAPI(prompt, numberOfImages);
                        }
                        
                        const candidates = model === 'gemini' ? result.candidates : result.predictions;

                        if (candidates && candidates.length > 0) {
                            const generatedImages = [];
                            for (const candidate of candidates) {
                                const imageData = model === 'gemini' 
                                    ? candidate?.content?.parts?.[0]?.inlineData?.data
                                    : candidate?.bytesBase64Encoded;
                                
                                if (imageData) {
                                    const newImageUrl = `data:image/png;base64,${imageData}`;
                                    const newFilename = this.generateFilename(model);
                                    const newImage = { id: Date.now() + Math.random(), dataUrl: newImageUrl, name: newFilename };
                                    generatedImages.push(newImage);
                                }
                            }
                            
                            if (generatedImages.length > 0) {
                                this.imageStation.images.unshift(...generatedImages);
                                this.ui.generatedImageUrl = generatedImages[0].dataUrl;
                                this.ui.selectedImageId = generatedImages[0].id;
                                this.addHistory('success', null, model);
                            } else {
                                const reason = this.getFailureReason(result);
                                this.addHistory('failure', reason, model);
                                this.showToast(`AI ì•ˆì „ ì •ì±…ì— ë”°ë¼ ìš”ì²­ì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. (${reason})`);
                            }
                        } else {
                            const reason = this.getFailureReason(result);
                            this.addHistory('failure', reason, model);
                            this.showToast(`AI ì•ˆì „ ì •ì±…ì— ë”°ë¼ ìš”ì²­ì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. (${reason})`);
                        }
                    } catch (error) {
                        console.error("Image Generation Error:", error);
                        this.addHistory('failure', 'technical', model);
                        this.showToast(`ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
                    }
                },

                // =================================================================
                // Keyword Library & CANVAS SYNC FUNCTIONS
                // =================================================================
                
                handleKeywordLibraryClick(event, item, group) {
                    const isUserKeyword = group && !group.isDefault;
                    const isActive = this.promptBoard.activeKeywordIds.includes(item.id);

                    if (isActive) {
                        this.removeKeywordFromAllBoardAreas(item.id);
                    } else {
                        if (isUserKeyword) {
                            this.openAddMenu(event, item);
                        } else {
                            this.addKeywordToPromptBoard(item, group.id);
                        }
                    }
                },

                addKeywordToPromptBoard(item, areaKey) {
                    if (this.promptBoard[areaKey]) {
                        const newKeywordInstance = { ...item, instanceId: Date.now() + Math.random() };
                        this.promptBoard[areaKey].push(newKeywordInstance);
                        this.updateActiveKeywordIds();
                    }
                },

                removeKeywordFromAllBoardAreas(keywordId) {
                    let removedKeywordName = '';
                    ['subject', 'details', 'style', 'composition'].forEach(areaKey => {
                        this.promptBoard[areaKey] = this.promptBoard[areaKey].filter(k => {
                            if (k.id === keywordId) {
                                removedKeywordName = k.keyword;
                                return false;
                            }
                            return true;
                        });
                    });
                    this.updateActiveKeywordIds();
                },
                
                removeKeywordFromPromptBoard(instanceId) {
                    let keywordIdToRemove = null;
                    let removedKeywordName = '';
                    ['subject', 'details', 'style', 'composition'].forEach(areaKey => {
                        this.promptBoard[areaKey] = this.promptBoard[areaKey].filter(k => {
                            if (k.instanceId === instanceId) {
                                keywordIdToRemove = k.id;
                                removedKeywordName = k.keyword;
                                return false;
                            }
                            return true;
                        });
                    });
                    if (keywordIdToRemove) {
                        this.updateActiveKeywordIds();
                    }
                },

                updateActiveKeywordIds() {
                    const allCanvasKeywordIds = ['subject', 'details', 'style', 'composition']
                        .flatMap(areaKey => this.promptBoard[areaKey].map(k => k.id));
                    this.promptBoard.activeKeywordIds = [...new Set(allCanvasKeywordIds)];
                },
                
                // =================================================================
                // Keyword Library MANAGEMENT (Pop-over Menu)
                // =================================================================
                openKeywordLibraryMoveMenu(event, item, group) {
                    const rect = event.currentTarget.getBoundingClientRect();
                    this.ui.moveMenu = {
                        visible: true,
                        top: rect.bottom + window.scrollY,
                        left: rect.left + window.scrollX,
                        keyword: item,
                        fromGroupId: group.id,
                        fromTabName: group.activeTab
                    };
                },

                closeKeywordLibraryMoveMenu() {
                    this.ui.moveMenu.visible = false;
                },
                
                openAddMenu(event, item) {
                    const rect = event.currentTarget.getBoundingClientRect();
                    this.ui.addMenu = {
                        visible: true,
                        top: rect.bottom + window.scrollY,
                        left: rect.left + window.scrollX,
                        keyword: item,
                    };
                },

                closeAddMenu() {
                    this.ui.addMenu.visible = false;
                },

                moveKeyword(toGroupId, toTabName) {
                    const { keyword, fromGroupId, fromTabName } = this.ui.moveMenu;
                    if (!keyword) return;

                    const allGroups = [...this.keywordLibrary.defaultGroups, ...this.keywordLibrary.userGroups];
                    const fromGroup = allGroups.find(g => g.id === fromGroupId);
                    const toGroup = allGroups.find(g => g.id === toGroupId);

                    if (!fromGroup || !toGroup) return;

                    const fromTab = fromGroup.tabs.find(t => t.name === fromTabName);
                    if (!fromTab) return;

                    const fromKeywordIdIndex = fromTab.keywordIds.indexOf(keyword.id);
                    if (fromKeywordIdIndex === -1) return;

                    // 1. Remove from source
                    fromTab.keywordIds.splice(fromKeywordIdIndex, 1);

                    // 2. Move keyword data if group changes
                    if (fromGroupId !== toGroupId) {
                        const keywordDataIndex = fromGroup.keywords.findIndex(k => k.id === keyword.id);
                        if (keywordDataIndex > -1) {
                            const [keywordData] = fromGroup.keywords.splice(keywordDataIndex, 1);
                            toGroup.keywords.push(keywordData);
                        }
                    }

                    // 3. Add to destination
                    const toTab = toGroup.tabs.find(t => t.name === toTabName);
                    if (!toTab) {
                        fromTab.keywordIds.splice(fromKeywordIdIndex, 0, keyword.id); // Revert
                        return;
                    }
                    toTab.keywordIds.unshift(keyword.id);

                    // 4. Reset state and save
                    this.closeKeywordLibraryMoveMenu();
                    this.saveState(false);
                },

                toggleKeywordLibraryTabDeleteMode(groupId) {
                    const state = this.keywordLibrary.tabDeleteState;
                    if (state.active && state.groupId === groupId) {
                        state.active = false;
                        state.groupId = null;
                    } else {
                        state.active = true;
                        state.groupId = groupId;
                    }
                },

                deleteTabFromKeywordLibraryGroup(groupId, tabName) {
                    const data = {
                        groupId: groupId,
                        tabName: tabName,
                        confirmMessage: `'${tabName}' íƒ­ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? íƒ­ ì•ˆì˜ í‚¤ì›Œë“œë„ ëª¨ë‘ ì‚­ì œë©ë‹ˆë‹¤.`
                    };
                    this.openModal('delete-tab-confirm-modal', data);
                },

                confirmDeleteTab() {
                    const { groupId, tabName } = this.ui.modalData;
                    const allGroups = [...this.keywordLibrary.defaultGroups, ...this.keywordLibrary.userGroups];
                    const group = allGroups.find(g => g.id === groupId);
                    if (group) {
                        const tabIndex = group.tabs.findIndex(t => t.name === tabName);
                        if (tabIndex > -1) {
                            const [deletedTab] = group.tabs.splice(tabIndex, 1);
                            group.keywords = group.keywords.filter(k => !deletedTab.keywordIds.includes(k.id));
                            if (group.activeTab === tabName && group.tabs.length > 0) {
                                group.activeTab = group.tabs[0].name;
                            }
                        }
                    }
                    this.keywordLibrary.tabDeleteState = { active: false, groupId: null };
                    this.saveState();
                    this.closeModal();
                },

                async addNewKeywordToKeywordLibrary(keywordInput, descInput) {
                    if (!keywordInput || !keywordInput.trim()) {
                        this.showToast("í‚¤ì›Œë“œ ì´ë¦„ì„ ìž…ë ¥í•´ì£¼ì„¸ìš”.");
                        return;
                    }

                    this.ui.isLoadingCompletion = true;
                    try {
                        const userGroups = this.keywordLibrary.userGroups;
                        if (userGroups.length === 0) {
                            this.addNewKeywordLibraryGroup("ë‚´ í‚¤ì›Œë“œ");
                        }

                        let finalKeyword = keywordInput.trim();
                        let finalDesc = descInput.trim();

                        if (this.settings.aiKeywordSupport) {
                            const isSimpleEnglish = /^[a-zA-Z0-9\s.,'()\-]+$/.test(finalKeyword);
                            if (!isSimpleEnglish) {
                                finalKeyword = await this.callTranslationAPI(finalKeyword);
                                finalKeyword = this._toTitleCase(finalKeyword);
                            }
                            if (!finalDesc) {
                                finalDesc = await this.callDescriptionAPI(finalKeyword);
                            }
                        } else {
                            // AI support is OFF. Enforce English-only.
                            const isEnglishOnly = /^[a-zA-Z0-9\s.,'()\-]+$/.test(finalKeyword);
                            if (!isEnglishOnly) {
                                this.showToast("í‚¤ì›Œë“œëŠ” ì˜ë¬¸ë§Œ ë“±ë¡í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.");
                                this.ui.isLoadingCompletion = false;
                                return;
                            }
                        }
                        
                        if (!finalDesc) {
                            finalDesc = '_';
                        }

                        const newKeyword = {
                            id: 'user-' + Date.now() + Math.random(),
                            type: 'keyword',
                            keyword: finalKeyword.replace(/\s+/g, ' '),
                            desc: finalDesc,
                            isCustom: true
                        };
                        
                        const targetGroup = this.keywordLibrary.userGroups[0];
                        targetGroup.keywords.unshift(newKeyword);
                        
                        const targetTab = targetGroup.tabs[0] || null;
                        if (targetTab) {
                             targetTab.keywordIds.unshift(newKeyword.id);
                        }
                        this.saveState();
                    } catch (error) {
                        console.error("AI Support Error:", error);
                        this.showToast("AI ì§€ì› ì˜¤ë¥˜: " + error.message);
                    } finally {
                        this.ui.isLoadingCompletion = false;
                    }
                },

                addNewKeywordLibraryGroup(name) {
                    if (!name || !name.trim()) {
                        this.showToast("ê·¸ë£¹ ì´ë¦„ì„ ìž…ë ¥í•´ì£¼ì„¸ìš”.");
                        return;
                    }
                    const newGroup = {
                        id: 'user-' + Date.now() + Math.random(),
                        name: name.trim(),
                        keywords: [],
                        collapsed: true,
                        isDefault: false,
                        activeTab: 'ê¸°ë³¸',
                        tabs: [{ name: 'ê¸°ë³¸', keywordIds: [] }]
                    };
                    this.keywordLibrary.userGroups.push(newGroup);
                    this.saveState();
                },

                deleteUserKeywordLibraryGroup(groupId) {
                    const groupIndex = this.keywordLibrary.userGroups.findIndex(g => g.id === groupId);
                    if (groupIndex > -1) {
                        const [deletedGroup] = this.keywordLibrary.userGroups.splice(groupIndex, 1);
                        this.saveState();
                        this.showToast(`'${deletedGroup.name}' ê·¸ë£¹ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    }
                },
                
                removeKeywordFromKeywordLibrary(groupId, itemId) {
                    const allGroups = [...this.keywordLibrary.defaultGroups, ...this.keywordLibrary.userGroups];
                    const group = allGroups.find(g => g.id === groupId);
                    
                    if (group) {
                        const keywordIndex = group.keywords.findIndex(k => k.id === itemId);
                        if (keywordIndex > -1) {
                            const [removedKeyword] = group.keywords.splice(keywordIndex, 1);
                            group.tabs.forEach(tab => {
                                const idIndex = tab.keywordIds.indexOf(itemId);
                                if (idIndex > -1) tab.keywordIds.splice(idIndex, 1);
                            });
                            this.removeKeywordFromAllBoardAreas(removedKeyword.id);
                            this.saveState();
                            this.showToast(`'${removedKeyword.keyword}' í‚¤ì›Œë“œê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                        }
                    }
                },

                // =================================================================
                // PROMPT BOARD DRAG & DROP FUNCTIONS
                // =================================================================
                
                handlePromptBoardDragStart(event, item, fromGroupKey) {
                    this.promptBoard.draggingItem = { item: { ...item }, fromGroupKey: fromGroupKey };
                    event.dataTransfer.effectAllowed = 'move';
                },

                handlePromptBoardDragOver(event) {
                    event.preventDefault();
                },
                
                handlePromptBoardDrop(event, toGroupKey) {
                    if (!this.promptBoard.draggingItem) return;
                
                    const { item, fromGroupKey } = this.promptBoard.draggingItem;
                    const fromArray = this.promptBoard[fromGroupKey];
                    const fromIndex = fromArray.findIndex(k => k.instanceId === item.instanceId);
                
                    if (fromIndex === -1) {
                        this.clearPromptBoardDragState();
                        return;
                    }
                
                    const dropTarget = event.target.closest('.prompt-keyword');
                    const toArray = this.promptBoard[toGroupKey];
                    let toIndex = toArray.length;

                    if (dropTarget) {
                        const targetId = dropTarget.dataset.instanceId;
                        if (targetId !== item.instanceId) {
                           const targetIndexInDOM = Array.from(dropTarget.parentElement.children).indexOf(dropTarget);
                           const rect = dropTarget.getBoundingClientRect();
                           const isAfter = event.clientY > rect.top + rect.height / 2;
                           toIndex = isAfter ? targetIndexInDOM + 1 : targetIndexInDOM;
                        } else {
                            this.clearPromptBoardDragState();
                            return;
                        }
                    }
                
                    const [movedItem] = fromArray.splice(fromIndex, 1);
                
                    if (fromGroupKey === toGroupKey && fromIndex < toIndex) {
                        toIndex--;
                    }
                
                    toArray.splice(toIndex, 0, movedItem);
                
                    this.updateActiveKeywordIds();
                    this.clearPromptBoardDragState();
                },

                clearPromptBoardDragState() {
                    this.promptBoard.draggingItem = null;
                },
                
                // Image Station D&D
                handleImageStationDragStart(event, image) {
                    this.imageStation.draggingItem = image;
                    event.dataTransfer.effectAllowed = 'move';
                },

                handleImageStationOver(event, index) {
                    event.preventDefault();
                },

                handleImageStationDrop(event, targetIndex) {
                    event.preventDefault();
                    if (!this.imageStation.draggingItem) return;

                    const draggedItem = this.imageStation.draggingItem;
                    const fromIndex = this.imageStation.images.findIndex(img => img.id === draggedItem.id);

                    if (fromIndex === -1 || fromIndex === targetIndex) {
                        this.imageStation.draggingItem = null;
                        return;
                    }

                    const [itemToMove] = this.imageStation.images.splice(fromIndex, 1);
                    this.imageStation.images.splice(targetIndex, 0, itemToMove);
                    
                    this.imageStation.draggingItem = null;
                },

                clearImageStationDragState() {
                    this.imageStation.draggingItem = null;
                },

                // =================================================================
                // OTHER UI & STATE MANAGEMENT FUNCTIONS
                // =================================================================
                
                clearPromptBoardAndImageStation() {
                    this.promptBoard = { subject: [], details: [], style: [], composition: [], manualPrompt: '', activeKeywordIds: [] };
                    this.imageStation.images = [];
                    this.ui.generatedImageUrl = null;
                    this.ui.selectedImageId = null;
                    this.showToast("ë³´ë“œì™€ ì´ë¯¸ì§€ ìŠ¤í…Œì´ì…˜ì„ ëª¨ë‘ ë¹„ì› ìŠµë‹ˆë‹¤.");
                },

                factoryReset() {
                    localStorage.removeItem(this.constants.LOCAL_STORAGE_KEY);
                    this.showToast("ëª¨ë“  ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. íŽ˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.");
                    setTimeout(() => location.reload(), 1500);
                },

                openModal(id, data = {}) {
                    this.ui.modalData = data;
                    this.ui.activeModal = id;
                },
                
                closeModal() {
                    this.ui.activeModal = null;
                    this.ui.modalData = {};
                },
                
                copyToClipboard(text) {
                    if (!text) return;
                     const textarea = document.createElement('textarea');
                     textarea.value = text;
                     document.body.appendChild(textarea);
                     textarea.select();
                     try {
                        document.execCommand('copy');
                        this.showToast("í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!");
                     } catch (err) {
                        this.showToast("ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
                     }
                     document.body.removeChild(textarea);
                },
                
                saveState(showToast = true) {
                    try {
                        const dataToSave = {
                            keywordLibrary: {
                                defaultGroups: this.keywordLibrary.defaultGroups,
                                userGroups: this.keywordLibrary.userGroups,
                            },
                            settings: this.settings,
                            history: this.history,
                            presets: this.presets
                        };
                        localStorage.setItem(this.constants.LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
                        if(showToast && this.ui.activeModal === 'settings-modal') this.showToast("ì„¤ì •ì´ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
                    } catch (error) {
                        this.showToast("ì„¤ì •ì„ ì €ìž¥í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì €ìž¥ ê³µê°„ì´ ë¶€ì¡±í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.");
                    }
                },
                
                loadState() {
                    try {
                        const savedData = localStorage.getItem(this.constants.LOCAL_STORAGE_KEY);
                        if (!savedData) return;
                        const parsed = JSON.parse(savedData);
                        if (parsed) {
                           if (parsed.keywordLibrary) {
                                this.keywordLibrary.defaultGroups = parsed.keywordLibrary.defaultGroups || this.keywordLibrary.defaultGroups;
                                this.keywordLibrary.userGroups = parsed.keywordLibrary.userGroups || [];
                            }
                            this.settings = { ...this.settings, ...parsed.settings };
                            this.history = parsed.history || [];
                            this.presets = parsed.presets || [];
                            this.ui.generatedImageUrl = null;
                            this.ui.selectedImageId = null;
                            this.imageStation.images = [];
                            this.showToast("ì €ìž¥ëœ ì„¤ì •ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.");
                        }
                    } catch (error) {
                        console.error("Load state error:", error);
                    }
                },
                
                // =================================================================
                // PRESET & HISTORY REFACTORED FUNCTIONS
                // =================================================================
                saveCurrentPromptBoardAsPreset() {
                    const promptText = this.getFinalPrompt();
                    if (!promptText) {
                        this.showToast("ì €ìž¥í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.");
                        return;
                    }
                    const now = new Date();
                    const name = `Preset ${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    
                    const preset = {
                        id: Date.now(),
                        name: name,
                        promptText: promptText,
                        promptLength: promptText.length,
                        promptBoardState: JSON.parse(JSON.stringify(this.promptBoard))
                    };
                    
                    if (this.settings.generationModel === 'imagen' && this.settings.seed) {
                        preset.seed = this.settings.seed;
                    }

                    this.presets.unshift(preset);
                    this.saveState();
                    this.showToast(`'${name}' í”„ë¦¬ì…‹ì´ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                },
                
                savePresetFromHistory(historyId) {
                    const item = this.history.find(h => h.id === historyId);
                    if (!item) return;

                    const now = new Date();
                    const name = `Preset ${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

                    const preset = {
                        id: Date.now(),
                        name: name,
                        promptText: item.promptText,
                        promptLength: item.promptLength,
                        promptBoardState: JSON.parse(JSON.stringify(item.promptBoardState))
                    };
                    
                    this.presets.unshift(preset);
                    this.saveState();
                    this.showToast(`ížˆìŠ¤í† ë¦¬ë¥¼ í”„ë¦¬ì…‹ìœ¼ë¡œ ì €ìž¥í–ˆìŠµë‹ˆë‹¤: '${name}'`);
                },
                savePromptAsPreset(promptText) {
                    if (!promptText) {
                        this.showToast("ì €ìž¥í•  í”„ë¡¬í”„íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
                        return;
                    }
                    const now = new Date();
                    const name = `ë¶„ì„ í”„ë¦¬ì…‹ ${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    
                    const preset = {
                        id: Date.now(),
                        name: name,
                        promptText: promptText,
                        promptLength: promptText.length,
                        promptBoardState: {
                            subject: [], details: [], style: [], composition: [],
                            manualPrompt: promptText, activeKeywordIds: []
                        }
                    };
                    
                    this.presets.unshift(preset);
                    this.saveState();
                    this.showToast(`'${name}' í”„ë¦¬ì…‹ì´ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                },

                loadPreset(id) {
                    const preset = this.presets.find(p => p.id === id);
                    if (preset) {
                        this.promptBoard = { ...{activeKeywordIds: []}, ...JSON.parse(JSON.stringify(preset.promptBoardState)) };
                        this.imageStation.images = [];
                        this.ui.generatedImageUrl = null;
                        this.ui.selectedImageId = null;
                        this.settings.seed = preset.seed || '';
                        this.showToast(`'${preset.name}' í”„ë¦¬ì…‹ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                        this.closeModal();
                    }
                },
                
                deletePreset(id) {
                    this.presets = this.presets.filter(p => p.id !== id);
                    this.saveState();
                    this.showToast("í”„ë¦¬ì…‹ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.");
                },

                updatePresetName(id, newName) {
                    const preset = this.presets.find(p => p.id === id);
                    if(preset && newName.trim()){
                        preset.name = newName.trim();
                        this.saveState(false);
                    }
                    this.ui.editingPresetId = null;
                },

                deleteHistory(id) {
                    this.history = this.history.filter(i => i.id !== id);
                    this.saveState();
                    this.showToast("ížˆìŠ¤í† ë¦¬ í•­ëª©ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.");
                },

                // =================================================================
                // HISTORY FUNCTIONS
                // =================================================================
                restoreHistory(id) {
                    const item = this.history.find(h => h.id === id);
                    if (item) {
                         this.promptBoard = { ...this.promptBoard, ...item.promptBoardState };
                         if (item.image) {
                            // Find if image still exists in imageStation, otherwise add it.
                            const existingImage = this.imageStation.images.find(img => img.dataUrl === item.image);
                            if(existingImage){
                                this.selectImage(existingImage);
                            } else {
                                this.addToImageStation(item.image, `history_${item.id}.png`);
                            }
                         } else {
                            this.imageStation.images = [];
                            this.ui.generatedImageUrl = null;
                            this.ui.selectedImageId = null;
                         }
                        this.ui.isPromptBoardCollapsed = false;
                        this.showToast("ížˆìŠ¤í† ë¦¬ë¥¼ ë³µì›í–ˆìŠµë‹ˆë‹¤.");
                        this.closeModal();
                    }
                },
                
                addHistory(status, reason, model, prompt = null) {
                    this.history.unshift({
                        id: Date.now(),
                        status,
                        reason,
                        modelUsed: model,
                        promptText: prompt || this.getFinalPrompt(),
                        promptLength: (prompt || this.getFinalPrompt()).length,
                        image: null,
                        promptBoardState: JSON.parse(JSON.stringify(this.promptBoard))
                    });
                }
            });        
   
            Alpine.data('editCanvas', () => ({
                // =================================================================
                // 1. ìƒíƒœ ë³€ìˆ˜ (State Properties)
                // =================================================================
                mode: null,
                canvas: null,
                isLoading: false,
                baseImage: null,
                activeListeners: {}, // To track and remove mode-specific event listeners
                
                // Mode-specific states
                refineState: {},
                brushSize: 20,
                brushColor: '#000000',
                activeAISupport: null,
                inpaintPrompt: '',
                maskMode: 'transform',
                fabricImage: null,
                originalImage: null,
                activeAspectRatioPreset: null,
                padding: {},
                originalWidth: 0,
                originalHeight: 0,
                expansionBudgetPercent: 100,
                scaledResolution: '0x0',
                cornerBudgetConsumption: 0,
                outputs: [],
                outputCount: 1,
                infuseActiveTab: 'expression',
                analyzeState: {},
                emotionDisplayOrder: [
                    { key: 'neutral', label: 'NEUTRAL', color: 'bg-slate-500' },
                    { key: 'joy', label: 'JOY', color: 'bg-amber-400' },
                    { key: 'sadness', label: 'SADNESS', color: 'bg-blue-500' },
                    { key: 'anger', label: 'ANGER', color: 'bg-red-500' },
                    { key: 'fear', label: 'FEAR', color: 'bg-violet-500' },
                    { key: 'surprise', label: 'SURPRISE', color: 'bg-orange-500' },
                    { key: 'contempt', label: 'CONTEMPT', color: 'bg-amber-800' },
                    { key: 'disgust', label: 'DISGUST', color: 'bg-green-500' }
                ],
                
                aiPreparationStrategies: {
                    draw: (context) => ({
                        mode: context.mode,
                        aISupportType: context.activeAISupport,
                        canvasData: context._exportCanvasAtOriginalResolution()
                    }),
                    refine: (context) => ({
                        mode: context.mode,
                        correctionType: context.refineState.activeAICorrection,
                        canvasData: context._exportCanvasAtOriginalResolution()
                    }),
                    inpaint: async (context) => {
                        const maskCanvas = new fabric.StaticCanvas(null, { width: context.canvas.width, height: context.canvas.height });
                        const nonImageObjects = context.canvas.getObjects().filter(obj => obj.type !== 'image');
                        const clonedObjects = await Promise.all(nonImageObjects.map(obj => new Promise(resolve => obj.clone(resolve))));
                        if (context.maskMode === 'transform') {
                            maskCanvas.backgroundColor = 'black';
                            clonedObjects.forEach(clone => maskCanvas.add(clone.set({ stroke: 'white', fill: 'white' })));
                        } else {
                            maskCanvas.backgroundColor = 'white';
                            clonedObjects.forEach(clone => maskCanvas.add(clone.set({ stroke: 'black', fill: 'black' })));
                        }
                        maskCanvas.renderAll();
                        return {
                            mode: context.mode,
                            prompt: context.inpaintPrompt,
                            baseImage: context.baseImage,
                            mask: maskCanvas.toDataURL({ format: 'png' })
                        };
                    },
                    outpaint: (context) => {
                        const originalImageDataUrl = context.baseImage;
                        if (!originalImageDataUrl) throw new Error("ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                        const finalWidth = Math.round(context.originalWidth * (1 + (context.padding.left + context.padding.right) / 100));
                        const finalHeight = Math.round(context.originalHeight * (1 + (context.padding.top + context.padding.bottom) / 100));
                        const maskCanvas = document.createElement('canvas');
                        maskCanvas.width = finalWidth;
                        maskCanvas.height = finalHeight;
                        const maskCtx = maskCanvas.getContext('2d');
                        maskCtx.fillStyle = 'black';
                        maskCtx.fillRect(0, 0, finalWidth, finalHeight);
                        maskCtx.fillStyle = 'white';
                        maskCtx.fillRect(
                            Math.round(context.originalWidth * (context.padding.left / 100)),
                            Math.round(context.originalHeight * (context.padding.top / 100)),
                            context.originalWidth, context.originalHeight);
                        return {
                            mode: context.mode,
                            baseImage: originalImageDataUrl,
                            mask: maskCanvas.toDataURL('image/png')
                        };
                    }
                },

                actionHandlers: {
                    // í‘œì¤€ AI ì•¡ì…˜ì„ ì²˜ë¦¬í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
                    _executeStandardAIAction: async (context) => {
                        const strategy = context.aiPreparationStrategies[context.mode];
                        if (strategy) {
                            const modalAIActionData = await strategy(context);
                            await Alpine.store('app').executeModalAIAction(modalAIActionData);
                            context.reset();
                        } else {
                            throw new Error(`AI ì „ëžµì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${context.mode}`);
                        }
                    },
                    
                    // í‘œì¤€ ë¡œì»¬(ë¹„-AI) ì•¡ì…˜ì„ ì²˜ë¦¬í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
                    _executeStandardLocalAction: (context) => {
                        const dataUrl = context._exportCanvasAtOriginalResolution();
                        if (dataUrl) {
                            Alpine.store('app').addToImageStation(dataUrl, Alpine.store('app').generateFilename('gemini'));
                        }
                        context.reset();
                    },

                    // ëª¨ë“œë³„ í•¸ë“¤ëŸ¬
                    draw: async function(context) {
                        if (context.activeAISupport) {
                            await this._executeStandardAIAction(context);
                        } else {
                            this._executeStandardLocalAction(context);
                        }
                    },
                    refine: async function(context) {
                        if (context.refineState.activeAICorrection) {
                            await this._executeStandardAIAction(context);
                        } else {
                            this._executeStandardLocalAction(context);
                        }
                    },
                    inpaint: async function(context) {
                        await this._executeStandardAIAction(context);
                    },
                    outpaint: async function(context) {
                        await this._executeStandardAIAction(context);
                    },
                    infuse: async (context) => {
                        const promises = context.outputs.map(async (output) => {
                            const keywordText = output.attributes.map(keywordId => {
                                const keyword = Alpine.store('app').getKeywordById(keywordId);
                                return keyword ? keyword.keyword : '';
                            }).join(', ');
                            
                            if (!keywordText) {
                                return { outputId: output.id, result: null }; // í‚¤ì›Œë“œê°€ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ë˜, IDëŠ” ìœ ì§€
                            }
                            
                            const finalPrompt = `Modify the provided image based on these instructions: ${keywordText}`;
                            const imageToSend = { dataUrl: context.baseImage };
                            const apiResult = await Alpine.store('app').callImageAPI(finalPrompt, [imageToSend]);
                            return { outputId: output.id, result: apiResult }; // ê²°ê³¼ì™€ ì›ë³¸ IDë¥¼ í•¨ê»˜ ë°˜í™˜
                        });
                        
                        const results = (await Promise.all(promises)).filter(item => item.result);
                        const generatedImages = [];
                        
                        results.forEach(item => {
                            const imageData = item.result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            if (imageData) {
                                const newImageUrl = `data:image/png;base64,${imageData}`;
                                const newFilename = Alpine.store('app').generateFilename('gemini');
                                
                                generatedImages.push({ 
                                    outputId: item.outputId, 
                                    dataUrl: newImageUrl, 
                                    name: newFilename 
                                });
                            }
                        });

                        if (generatedImages.length > 0) {
                            context._displayInfuseResults(generatedImages);
                            generatedImages.forEach(img => {
                                Alpine.store('app').addToImageStation(img.dataUrl, img.name, false);
                            });
                            Alpine.store('app').showToast(`${generatedImages.length}ê°œì˜ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ì—¬ ì²¨ë¶€í–ˆìŠµë‹ˆë‹¤.`);
                        } else {
                            Alpine.store('app').showToast(`ìƒì„±ëœ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.`);
                        }
                    },
                    analyze: async (context) => {
                        await context.executeAnalyzeAction();
                    }
                },

                modeConfigs: {
                    draw:       { loadImage: true,  asBackground: true,  drawingMode: true,  selection: false, cursor: 'crosshair' },
                    refine:     { loadImage: true,  asBackground: false, drawingMode: false, selection: false, cursor: 'default' },
                    inpaint:    { loadImage: true,  asBackground: true,  drawingMode: true,  selection: false, cursor: 'crosshair' },
                    outpaint:   { loadImage: true,  asBackground: false, drawingMode: false, selection: false, cursor: 'default' },
                    infuse:     { loadImage: true,  asBackground: false, drawingMode: false, selection: false, cursor: 'default' },
                    analyze:    { loadImage: true,  asBackground: false, drawingMode: false, selection: false, cursor: 'default' }
                },
                
                initialModeStates: {
                    refineState: { brightness: 0, contrast: 0, saturation: 0, hue: 0, activeFilter: null, angle: 0, flipX: false, flipY: false, activeAICorrection: null },
                    brushSize: 20,
                    brushColor: '#000000',
                    activeAISupport: null,
                    inpaintPrompt: '',
                    maskMode: 'transform',
                    activeAspectRatioPreset: null,
                    padding: { top: 0, right: 0, bottom: 0, left: 0 },
                    outputCount: 1,
                    outputs: [{ id: 1, active: true, attributes: [] }],
                    infuseActiveTab: 'expression',
                    analyzeState: { activeTab: 'extract', isLoading: false, promptResult: '', keywordResult: [], expressionResult: null, commentResult: '', costumeResult: null, costumeSheetType: 'costume', zoom: 1 }
                },

                // =================================================================
                // 2. ê³„ì‚°ëœ ì†ì„± (Computed Properties)
                // =================================================================
                get title() {
                    return { draw: 'ðŸŽ¨ ê·¸ë¦¼ ê·¸ë¦¬ê¸°', refine: 'ðŸ“¸ ì´ë¯¸ì§€ ë³´ì •', inpaint: 'ðŸ–Œï¸ ë¶€ë¶„ ìˆ˜ì •', outpaint: 'ðŸ“ ìº”ë²„ìŠ¤ í™•ìž¥', infuse: 'ðŸ§ª í”¼ì‚¬ì²´ ì œì–´', analyze: 'ðŸ”¬ ì´ë¯¸ì§€ ë¶„ì„' }[this.mode] || '';
                },
                get currentImageIndex() {
                    const images = Alpine.store('app').imageStation.images;
                    const selectedId = Alpine.store('app').ui.selectedImageId;
                    return images.findIndex(img => img.id === selectedId);
                },
                get canNavigatePrevious() { return this.currentImageIndex > 0; },
                get canNavigateNext() {
                    const images = Alpine.store('app').imageStation.images;
                    return this.currentImageIndex > -1 && this.currentImageIndex < images.length - 1;
                },

                // =================================================================
                // 3. ì¤‘ì•™ ì œì–´ (Dispatchers & Initializers)
                // =================================================================
                init() {
                    this.$watch('$store.app.ui.activeModal', (newValue) => {
                        if (newValue === 'edit-canvas') {
                            this.$nextTick(() => this.initialize());
                        } else {
                            if (this.canvas) this.canvas.dispose();
                            this.canvas = null;
                        }
                    });
                    this.$watch('$store.app.ui.selectedImageId', (newId, oldId) => {
                        if (this.$store.app.ui.activeModal === 'edit-canvas' && newId !== oldId) {
                            this.switchMode(this.mode); // Reload content in the same mode
                        }
                    });
                    this.$watch('analyzeState.activeTab', () => {
                        // [MODIFIED] Only reset the loading state, preserving the results of each tab.
                        this.analyzeState.isLoading = false;
                    });
                },

                // [REFACTORED] initialize now only runs ONCE when the modal opens.
                initialize() {
                    this.$nextTick(() => {
                        const canvasEl = this.$refs.canvas;
                        if (!canvasEl) return;
                        const parent = canvasEl.parentElement;
                        const size = Math.min(parent.clientWidth, parent.clientHeight);
                        
                        this.canvas = new fabric.Canvas(this.$refs.canvas);
                        this.canvas.setDimensions({ width: size, height: size });

                        const initialMode = Alpine.store('app').ui.modalData.mode;
                        this.switchMode(initialMode);
                    });
                },

                // [NEW] switchMode is now the core logic for changing modes.
                switchMode(newMode) {
                    if (!this.canvas) return;
                    
                    // 1. Clean up the previous mode
                    this.cleanupCurrentMode();
                    
                    // 2. Set up the new mode
                    this.mode = newMode;
                    const config = this.modeConfigs[this.mode];
                    if (!config) return;

                    // 3. Reset all UI-related state variables
                    this.resetAllModeStates();

                    // 4. Apply new canvas settings from config
                    this.canvas.isDrawingMode = config.drawingMode;
                    this.canvas.selection = config.selection;
                    this.canvas.defaultCursor = config.cursor;
                    this.canvas.hoverCursor = config.cursor;

                    // 5. Load image if required
                    if (config.loadImage) {
                        const selectedImageUrl = Alpine.store('app').ui.generatedImageUrl;
                        if (selectedImageUrl) {
                            this._loadImage({ asBackground: config.asBackground, onComplete: () => this.onModeReady() });
                        } else {
                            this.onModeReady();
                        }
                    } else {
                        this.onModeReady();
                    }
                },
                
                // [NEW] Helper to clean up canvas and events
                cleanupCurrentMode() {
                    if (!this.canvas) return;

                    // [MODIFIED] Reset zoom and pan state to default before cleaning up
                    this.canvas.setZoom(1);
                    this.canvas.viewportTransform = [1, 0, 0, 1, 0, 0];

                    // Remove all objects
                    this.canvas.clear();
                    // Remove all event listeners attached in the previous mode
                    for (const eventName in this.activeListeners) {
                        this.canvas.off(eventName, this.activeListeners[eventName]);
                    }
                    this.activeListeners = {};
                    this.baseImage = null;
                    this.fabricImage = null;
                },

                onModeReady() {
                    this.updateBrush();
                    
                    if (this.mode === 'analyze' && this.baseImage) {
                        this.resetZoom();
                    }
                },
                
                resetAllModeStates() {
                    const initialStates = JSON.parse(JSON.stringify(this.initialModeStates));
                    Object.assign(this, initialStates);
                },

                reset() {
                    this.switchMode(this.mode);
                },

                async executeAction() {
                    const modesRequiringImage = ['refine', 'inpaint', 'outpaint', 'infuse', 'analyze'];
                    if (modesRequiringImage.includes(this.mode) && !this.baseImage) {
                        Alpine.store('app').showToast("ì´ ìž‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ë©´ ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì™€ì•¼ í•©ë‹ˆë‹¤.");
                        return;
                    }
                    if (this.isLoading) return;
                    this.isLoading = true;

                    try {
                        const handler = this.actionHandlers[this.mode];
                        if (handler) {
                            // .callì„ ì‚¬ìš©í•˜ì—¬ í•¸ë“¤ëŸ¬ ë‚´ë¶€ì˜ 'this'ê°€ actionHandlers ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ë„ë¡ ì„¤ì •
                            await handler.call(this.actionHandlers, this); 
                        } else {
                            throw new Error(`ì•¡ì…˜ í•¸ë“¤ëŸ¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${this.mode}`);
                        }
                    } catch (error) {
                        console.error("Edit Canvas Action Error:", error);
                        Alpine.store('app').showToast(`ìž‘ì—… ì‹¤íŒ¨: ${error.message}`);
                    } finally {
                        this.isLoading = false;
                    }
                },

                _displayInfuseResults(generatedImages) {
                    if (!this.canvas || generatedImages.length === 0) return;

                    this.canvas.clear();
                    this.canvas.backgroundColor = '#1e2b3b';

                    const canvasWidth = this.canvas.width;
                    const canvasHeight = this.canvas.height;
                    const numImages = generatedImages.length;

                    let cols = numImages >= 2 ? 2 : 1;
                    let rows = numImages > 2 ? 2 : 1;
                    if (numImages === 2) rows = 1;

                    const cellWidth = canvasWidth / cols;
                    const cellHeight = canvasHeight / rows;

                    const imagePromises = generatedImages.map((imageInfo, index) => {
                        return new Promise(resolve => {
                            fabric.Image.fromURL(imageInfo.dataUrl, (img) => {
                                const scale = Math.min((cellWidth * 0.9) / img.width, (cellHeight * 0.9) / img.height);
                                img.scale(scale);
                                
                                const col = index % cols;
                                const row = Math.floor(index / cols);
                                
                                const left = (col * cellWidth) + (cellWidth - img.getScaledWidth()) / 2;
                                const top = (row * cellHeight) + (cellHeight - img.getScaledHeight()) / 2;

                                img.set({ left, top, selectable: false, evented: false });

                                const textBg = new fabric.Rect({
                                    width: 30, height: 30, fill: 'rgba(0,0,0,0.6)',
                                    rx: 5, ry: 5, left: left + 5, top: top + 5,
                                    selectable: false, evented: false
                                });
                                
                                const numberText = new fabric.Text(String(imageInfo.outputId), {
                                    fontSize: 20, fill: '#fff', fontFamily: 'Inter, sans-serif',
                                    left: left + 5 + 15, top: top + 5 + 15,
                                    originX: 'center', originY: 'center',
                                    selectable: false, evented: false
                                });

                                resolve([img, textBg, numberText]);
                            }, { crossOrigin: 'anonymous' });
                        });
                    });

                    Promise.all(imagePromises).then(objects => {
                        const validObjects = objects.filter(Boolean);
                        validObjects.forEach(objGroup => objGroup.forEach(obj => this.canvas.add(obj)));
                        this.canvas.renderAll();
                    });
                },
                
                handleResize() {
                    if (this.mode === 'draw' && !this.baseImage && this.canvas) {
                        const wrapper = this.$refs.canvasWrapper;
                        if (wrapper) {
                            this.canvas.setDimensions({ width: wrapper.clientWidth, height: wrapper.clientHeight });
                        }
                    }
                },
                _exportCanvasAtOriginalResolution() {
                    if (!this.canvas) return null;

                    if (['draw', 'refine', 'inpaint', 'outpaint', 'infuse'].includes(this.mode) && this.fabricImage && this.fabricImage.scaleX > 0) {
                        const multiplier = 1 / this.fabricImage.scaleX;
                        return this.canvas.toDataURL({ format: 'png', multiplier: multiplier });
                    }
                    
                    return this.canvas.toDataURL({ format: 'png' });
                },
                _loadImage(options = {}) {
                    const { imageUrlToLoad = null, asBackground = false, onComplete = () => {} } = options;
                    
                    const imageUrl = imageUrlToLoad || Alpine.store('app').ui.generatedImageUrl;
                    if (!imageUrl) {
                        if (this.mode === 'draw') {
                             if (onComplete) onComplete();
                        }
                        return;
                    }

                    this.baseImage = imageUrl;
                    if (!this.canvas) return;
                    this.canvas.clear();
                    this.canvas.backgroundColor = 'transparent';

                    fabric.Image.fromURL(imageUrl, (img) => {
                        this.fabricImage = img;
                        const canvasWrapper = this.$refs.canvasWrapper;
                        const containerSize = Math.min(canvasWrapper.clientWidth, canvasWrapper.clientHeight);
                        
                        const scale = Math.min(containerSize / img.width, containerSize / img.height);
                        
                        const canvasWidth = img.width * scale;
                        const canvasHeight = img.height * scale;
                        this.canvas.setDimensions({ width: canvasWidth, height: canvasHeight });
                        
                        img.scale(scale);
                        img.set({ selectable: false, evented: false });
                        
                        this.canvas.add(img);
                        img.center();
                        
                        if (asBackground) {
                            this.canvas.sendToBack(img);
                        }

                        this.originalImage = img.getElement();
                        this.originalWidth = img.width;
                        this.originalHeight = img.height;
                        
                        this.canvas.renderAll();
                        if (onComplete) onComplete();

                    }, { crossOrigin: 'anonymous' });
                },

                _updateStateAndApply(updates, type = 'transform') {
                    if (!this.fabricImage) return;
                    Object.assign(this.refineState, updates);
                    if (type === 'transform') this.applyTransforms();
                    else if (type === 'filter') this.applyRefineFilters();
                },
                
                updateBrush() {
                    if (!this.canvas || !this.canvas.freeDrawingBrush) return;
                    const brush = this.canvas.freeDrawingBrush;
                    if (this.mode === 'draw') {
                        brush.color = this.brushColor;
                    } else if (this.mode === 'inpaint') {
                        brush.color = 'rgba(255, 0, 255, 0.5)';
                    }
                    brush.width = parseInt(this.brushSize, 10) || 1;
                },

                // --- REFINE MODE FUNCTIONS ---
                rotateImage(degrees) {
                    const newAngle = (this.refineState.angle + degrees) % 360;
                    this._updateStateAndApply({ angle: newAngle }, 'transform');
                },
                flipImage(axis) {
                    if (axis === 'X') {
                        this._updateStateAndApply({ flipX: !this.refineState.flipX }, 'transform');
                    } else if (axis === 'Y') {
                        this._updateStateAndApply({ flipY: !this.refineState.flipY }, 'transform');
                    }
                },
                applyTransforms() {
                    if (!this.canvas || !this.fabricImage) return;
                    this.fabricImage.set({
                        angle: this.refineState.angle,
                        flipX: this.refineState.flipX,
                        flipY: this.refineState.flipY
                    });
                    this.fabricImage.center();
                    this.canvas.renderAll();
                },
                applyRefineFilters() {
                    if (!this.canvas || !this.fabricImage) return;
                    this.fabricImage.filters = [];
                    const state = this.refineState;
                    switch(state.activeFilter) {
                        case 'grayscale': this.fabricImage.filters.push(new fabric.Image.filters.Grayscale()); break;
                        case 'sepia': this.fabricImage.filters.push(new fabric.Image.filters.Sepia()); break;
                        case 'invert': this.fabricImage.filters.push(new fabric.Image.filters.Invert()); break;
                        case 'blur': this.fabricImage.filters.push(new fabric.Image.filters.Blur({ blur: 0.15 })); break;
                    }
                    if (state.brightness !== 0) this.fabricImage.filters.push(new fabric.Image.filters.Brightness({ brightness: state.brightness }));
                    if (state.contrast !== 0) this.fabricImage.filters.push(new fabric.Image.filters.Contrast({ contrast: state.contrast }));
                    if (state.saturation !== 0) this.fabricImage.filters.push(new fabric.Image.filters.Saturation({ saturation: state.saturation }));
                    if (state.hue !== 0) this.fabricImage.filters.push(new fabric.Image.filters.HueRotation({ rotation: state.hue }));
                    this.fabricImage.applyFilters();
                    this.canvas.renderAll();
                },
                handleFilterChange() {
                    this._updateStateAndApply({}, 'filter');
                },
                
                setInpaintPreset(type) {
                    if (type === 'remove') {
                        this.inpaintPrompt = 'remove any text or other distracting overlays from the marked area, seamlessly blending it with the surrounding background.';
                    } else if (type === 'fix') {
                        this.inpaintPrompt = 'identify the incorrect body structure(such as too many fingers and toes, added arms and legs, or unnatural joints) in the marked area and redraw it into a universal and natural form.';
                    }
                },
                
                toggleAspectRatioPreset(ratioStr) {
                    if (this.activeAspectRatioPreset === ratioStr) {
                        this.activeAspectRatioPreset = null;
                        this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
                    } else {
                        this.activeAspectRatioPreset = ratioStr;
                        if (!this.originalWidth || !this.originalHeight) return;
                        const [targetW, targetH] = ratioStr.split(':').map(Number);
                        const targetAspectRatio = targetW / targetH;
                        const currentAspectRatio = this.originalWidth / this.originalHeight;
                        this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
                        if (Math.abs(targetAspectRatio - currentAspectRatio) < 0.01) {
                            this.updateExpansionState();
                            return;
                        }
                        if (targetAspectRatio > currentAspectRatio) {
                            const newTotalWidth = this.originalHeight * targetAspectRatio;
                            const totalHorizontalPadding = newTotalWidth - this.originalWidth;
                            const horizontalPaddingPercent = (totalHorizontalPadding / this.originalWidth) * 100;
                            this.padding.left = horizontalPaddingPercent / 2;
                            this.padding.right = horizontalPaddingPercent / 2;
                        } else {
                            const newTotalHeight = this.originalWidth / targetAspectRatio;
                            const totalVerticalPadding = newTotalHeight - this.originalHeight;
                            const verticalPaddingPercent = (totalVerticalPadding / this.originalHeight) * 100;
                            this.padding.top = verticalPaddingPercent / 2;
                            this.padding.bottom = verticalPaddingPercent / 2;
                        }
                    }
                    this.updateExpansionState();
                },
                drawPreview() {
                    if (!this.canvas || !this.fabricImage) return;
                    const container = this.$refs.canvasWrapper;
                    const containerSize = Math.min(container.clientWidth, container.clientHeight);
                    const totalWidth = this.originalWidth * (1 + (this.padding.left + this.padding.right) / 100);
                    const totalHeight = this.originalHeight * (1 + (this.padding.top + this.padding.bottom) / 100);
                    const paddedAspectRatio = totalWidth / totalHeight;
                    let canvasWidth, canvasHeight;
                    if (paddedAspectRatio > 1) {
                        canvasWidth = containerSize;
                        canvasHeight = containerSize / paddedAspectRatio;
                    } else {
                        canvasHeight = containerSize;
                        canvasWidth = containerSize * paddedAspectRatio;
                    }
                    this.canvas.setDimensions({ width: canvasWidth, height: canvasHeight });
                    this.canvas.clear();
                    this.canvas.backgroundColor = 'rgba(128, 128, 128, 0.4)';
                    const imageScale = canvasWidth / totalWidth;
                    this.fabricImage.set({
                        scaleX: imageScale, scaleY: imageScale,
                        left: (this.padding.left / 100) * this.originalWidth * imageScale,
                        top: (this.padding.top / 100) * this.originalHeight * imageScale
                    });
                    this.canvas.add(this.fabricImage).renderAll();
                },
                updateExpansionState(activeSide = null) {
                    if (activeSide) this.activeAspectRatioPreset = null;
                    if (!this.originalWidth) return;
                    const originalArea = this.originalWidth * this.originalHeight;
                    const maxTotalArea = originalArea * 2.0;
                    const maxSliderValue = 100;
                    const maxPaddings = {};
                    ['top', 'right', 'bottom', 'left'].forEach(side => {
                        const otherHorizontal = side === 'left' ? this.padding.right : this.padding.left;
                        const otherVertical = side === 'top' ? this.padding.bottom : this.padding.top;
                        let maxBudget = maxSliderValue;
                        if (['left', 'right'].includes(side)) {
                            const currentTotalHeight = this.originalHeight * (1 + (this.padding.top + this.padding.bottom) / 100);
                            if (currentTotalHeight > 0) {
                                const maxTotalWidth = maxTotalArea / currentTotalHeight;
                                const totalHorizontalPaddingPercent = ((maxTotalWidth / this.originalWidth) - 1) * 100;
                                maxBudget = totalHorizontalPaddingPercent - otherHorizontal;
                            } else { maxBudget = 0; }
                        } else {
                            const currentTotalWidth = this.originalWidth * (1 + (this.padding.left + this.padding.right) / 100);
                            if (currentTotalWidth > 0) {
                                const maxTotalHeight = maxTotalArea / currentTotalWidth;
                                const totalVerticalPaddingPercent = ((maxTotalHeight / this.originalHeight) - 1) * 100;
                                maxBudget = totalVerticalPaddingPercent - otherVertical;
                            } else { maxBudget = 0; }
                        }
                        maxPaddings[side] = Math.max(0, Math.min(maxSliderValue, maxBudget));
                    });
                    if (activeSide && this.padding[activeSide] > maxPaddings[activeSide]) this.padding[activeSide] = maxPaddings[activeSide];
                    const linearWidthExpansion = this.originalWidth * (this.padding.left + this.padding.right) / 100;
                    const linearHeightExpansion = this.originalHeight * (this.padding.top + this.padding.bottom) / 100;
                    const linearExpandedArea = linearWidthExpansion * this.originalHeight + linearHeightExpansion * this.originalWidth;
                    const currentWidth = this.originalWidth * (1 + (this.padding.left + this.padding.right) / 100);
                    const currentHeight = this.originalHeight * (1 + (this.padding.top + this.padding.bottom) / 100);
                    const currentTotalArea = currentWidth * currentHeight;
                    const actualExpandedArea = currentTotalArea - originalArea;
                    const cornerArea = actualExpandedArea - linearExpandedArea;
                    this.cornerBudgetConsumption = (cornerArea / (maxTotalArea - originalArea)) * 100;
                    const budgetUsedPercent = (actualExpandedArea / (maxTotalArea - originalArea)) * 100;
                    this.expansionBudgetPercent = Math.max(0, 100 - budgetUsedPercent);
                    if (currentWidth > 0 && currentHeight > 0) {
                        const aspectRatio = currentWidth / currentHeight;
                        const totalPixels = 1024 * 1024;
                        const scaledHeight = Math.round(Math.sqrt(totalPixels / aspectRatio));
                        const scaledWidth = Math.round(aspectRatio * scaledHeight);
                        this.scaledResolution = `${scaledWidth}x${scaledHeight}`;
                    }
                    this.drawPreview();
                },

                // --- INFUSE MODE FUNCTIONS ---
                addRemoveAttribute(keywordId) {
                    const activeOutput = this.outputs.find(o => o.active);
                    if (!activeOutput) return;

                    const masterTable = Alpine.store('app').infuseMasterTable;
                    let categoryKey = null;
                    for (const key in masterTable) {
                        if (masterTable[key].recipes.some(r => r.keywordId === keywordId)) {
                            categoryKey = key;
                            break;
                        }
                    }
                    if (!categoryKey) return;

                    const categoryRecipes = masterTable[categoryKey].recipes.map(r => r.keywordId);
                    const existingAttrInSameCategory = activeOutput.attributes.find(id => categoryRecipes.includes(id));

                    if (existingAttrInSameCategory === keywordId) {
                        activeOutput.attributes = activeOutput.attributes.filter(id => id !== keywordId);
                    } else {
                        if (existingAttrInSameCategory) {
                             activeOutput.attributes = activeOutput.attributes.filter(id => id !== existingAttrInSameCategory);
                        }
                        activeOutput.attributes.push(keywordId);
                    }
                },
                updateOutputs() {
                    this.outputs = Array.from({ length: this.outputCount }, (_, i) => {
                        const existing = this.outputs[i];
                        if (existing) {
                            return { ...existing, active: i === 0 };
                        } else {
                            return { id: i + 1, active: i === 0, attributes: [] };
                        }
                    });
                },
                getInfuseDisplay(keywordId) {
                    const masterTable = Alpine.store('app').infuseMasterTable;
                    for (const category of Object.values(masterTable)) {
                        const recipe = category.recipes.find(r => r.keywordId === keywordId);
                        if (recipe) return recipe.display;
                    }
                    return '?';
                },

                // --- ANALYZE MODE FUNCTIONS ---
                setZoom(level) {
                    if (!this.canvas || !this.fabricImage) return;
                    let newZoom = parseFloat(level);
                    if (newZoom < 1) newZoom = 1;
                    if (newZoom > 5) newZoom = 5;
                    this.analyzeState.zoom = newZoom;
                    
                    this.canvas.zoomToPoint(new fabric.Point(this.canvas.width / 2, this.canvas.height / 2), newZoom);
                    
                    this.panCanvas(null); // Clamp viewport after zooming
                    this.canvas.renderAll();
                },
                resetZoom() {
                    this.analyzeState.zoom = 1; 
                    if (!this.canvas || !this.fabricImage) return;
                    
                    this.canvas.setZoom(1);
                    
                    const vpt = this.canvas.viewportTransform;
                    vpt[4] = (this.canvas.width - this.fabricImage.getScaledWidth()) / 2;
                    vpt[5] = (this.canvas.height - this.fabricImage.getScaledHeight()) / 2;
                    this.canvas.requestRenderAll();
                },
                panCanvas(direction) {
                    if (!this.canvas || !this.fabricImage) return;

                    if (this.analyzeState.zoom <= 1 && direction) return;

                    const vpt = this.canvas.viewportTransform;
                    const panAmount = 50;
                    
                    const currentWidth = this.fabricImage.getScaledWidth() * this.canvas.getZoom();
                    const currentHeight = this.fabricImage.getScaledHeight() * this.canvas.getZoom();

                    const rightBound = this.canvas.width - currentWidth;
                    const bottomBound = this.canvas.height - currentHeight;

                    if (direction) {
                        if (direction === 'up') vpt[5] += panAmount;
                        if (direction === 'down') vpt[5] -= panAmount;
                        if (direction === 'left') vpt[4] += panAmount;
                        if (direction === 'right') vpt[4] -= panAmount;
                    }

                    if (vpt[4] > 0) vpt[4] = 0;
                    if (vpt[5] > 0) vpt[5] = 0;
                    if (vpt[4] < rightBound) vpt[4] = rightBound;
                    if (vpt[5] < bottomBound) vpt[5] = bottomBound;

                    this.canvas.requestRenderAll();
                },
            async executeAnalyzeAction() {
                this.analyzeState.isLoading = true; 
                try {
                    const appStore = Alpine.store('app');
                    const imageToSend = { dataUrl: this.baseImage };
                    const actionType = this.analyzeState.activeTab;
                    
                    if (actionType === 'extract') {
                        const systemPrompt = "You are a world-class prompt engineer. Analyze the provided image and generate a detailed, descriptive English prompt that could create a similar image. Also, extract 5-7 relevant keywords as hashtags. The response must be a single JSON object with two keys: 'generatedPrompt' (string) and 'keywords' (array of strings).";
                        const userQuery = "Analyze this image and provide a generative prompt and keywords in JSON format.";
                        const jsonString = await appStore.callMultimodalTextAPI(systemPrompt, userQuery, [imageToSend]);
                        const result = JSON.parse(jsonString);
                        this.analyzeState.promptResult = result.generatedPrompt || 'í”„ë¡¬í”„íŠ¸ë¥¼ ì¶”ì¶œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
                        
                        const keywords = result.keywords || [];
                        this.analyzeState.keywordResult = keywords.map(k => appStore._toTitleCase(k));

                    } else if (actionType === 'expression') {
                        const systemPrompt = "You are an expert in facial expression analysis. Analyze the main subject's face in the image based on these eight emotions: neutral, joy, sadness, anger, fear, surprise, contempt, and disgust. Provide a score from 0.0 to 1.0 for each. Also, provide a one-paragraph situational commentary in Korean. The response must be a single JSON object with two keys: 'expressionAnalysis' (an object with emotion scores) and 'situationalCommentary' (a string).";
                        const userQuery = "Analyze the facial expression and situation in this image and provide the results in JSON format.";
                        const jsonString = await appStore.callMultimodalTextAPI(systemPrompt, userQuery, [imageToSend]);
                        const result = JSON.parse(jsonString);

                        this.analyzeState.expressionResult = result.expressionAnalysis || null;
                        this.analyzeState.commentResult = result.situationalCommentary || 'ì½”ë©˜íŠ¸ë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';

                        if (this.analyzeState.expressionResult) {
                            try {
                                const resultImageUrl = await this._createAnalysisResultImage(
                                    this.baseImage,
                                    this.analyzeState.expressionResult,
                                    this.analyzeState.commentResult,
                                    this.emotionDisplayOrder
                                );
                                const filename = `analysis-${Date.now()}.png`;
                                appStore.addToImageStation(resultImageUrl, filename, false);
                                appStore.showToast("ë¶„ì„ ê²°ê³¼ ì´ë¯¸ì§€ë¥¼ ìŠ¤í…Œì´ì…˜ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.");
                            } catch (imgError) {
                                console.error("Failed to create analysis image:", imgError);
                                appStore.showToast("ë¶„ì„ ê²°ê³¼ ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
                            }
                        }

                    } else if (actionType === 'costume') {
                        let prompt;
                        if (this.analyzeState.costumeSheetType === 'character') {
                            prompt = "Analyze the character in the image. Create a 'character sheet' that includes a full-body view from the front, side, and back. Maintain a consistent art style and character design across all views, and present it on a clean white background.";
                        } else {
                            prompt = "Analyze the clothing and accessories worn by the person in the image. Isolate each item and arrange them neatly on a clean, white background to create a 'costume sheet'.";
                        }
                        const result = await appStore.callImageAPI(prompt, [imageToSend]);
                        const imageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                        if (imageData) {
                            const newImageUrl = `data:image/png;base64,${imageData}`;
                            this.analyzeState.costumeResult = newImageUrl;
                            const newFilename = `sheet-${Date.now()}.png`;
                            appStore.addToImageStation(newImageUrl, newFilename, false);
                            appStore.showToast("ì‹œíŠ¸ë¥¼ ìƒì„±í•˜ì—¬ ìŠ¤í…Œì´ì…˜ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.");
                        } else {
                            throw new Error("AIê°€ ì‹œíŠ¸ë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
                        }
                    }
                } catch (error) {
                    Alpine.store('app').showToast(`ë¶„ì„ ì‹¤íŒ¨: ${error.message}`);
                } finally {
                    this.analyzeState.isLoading = false;
                }
            },

            sortAttributes(attributes) {
                const masterTable = Alpine.store('app').infuseMasterTable;
                const categoryOrder = Object.keys(masterTable);

                const getCategory = (id) => {
                    for (const key of categoryOrder) {
                        if (masterTable[key].recipes.some(r => r.keywordId === id)) {
                            return key;
                        }
                    }
                    return null;
                };

                return [...attributes].sort((a, b) => {
                    const categoryA = getCategory(a);
                    const categoryB = getCategory(b);
                    return categoryOrder.indexOf(categoryA) - categoryOrder.indexOf(categoryB);
                });
            },
            
            _wrapText(context, text, maxWidth, fontSize, fontFace) {
                context.font = `${fontSize}px ${fontFace}`;
                if(!text) return [''];
                const words = text.split(' ');
                let lines = [];
                let currentLine = words[0] || '';

                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = context.measureText(currentLine + " " + word).width;
                    if (width < maxWidth) {
                        currentLine += " " + word;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
                return lines;
            },

            _drawRoundRect(ctx, x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                if (width <= 0 || height <= 0) return;
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + width, y, x + width, y + height, radius);
                ctx.arcTo(x + width, y + height, x, y + height, radius);
                ctx.arcTo(x, y + height, x, y, radius);
                ctx.arcTo(x, y, x + width, y, radius);
                ctx.closePath();
                ctx.fill();
            },

            _createAnalysisResultImage(baseImageUrl, expressionResult, commentResult, emotionOrder) {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    const width = 1080;
                    const padding = 10;
                    const contentWidth = width - padding * 2;
                    
                    const colorMap = {
                        'bg-slate-500': '#64748b', 'bg-amber-400': '#facc15', 'bg-blue-500': '#3b82f6',
                        'bg-red-500': '#ef4444', 'bg-violet-500': '#8b5cf6', 'bg-orange-500': '#f97316',
                        'bg-amber-800': '#92400e', 'bg-green-500': '#22c55e'
                    };

                    const lineHeight = 40;
                    const graphHeight = 50;
                    const sectionSpacing = 20;
                    const commentLines = this._wrapText(ctx, commentResult, contentWidth - 80, 26, '"Noto Sans KR", sans-serif');
                    
                    const analysisSectionHeight = 50 + (graphHeight * emotionOrder.length) + 30;
                    const commentSectionHeight = 50 + (commentLines.length * lineHeight) + 30;
                    
                    const fixedVerticalSpace = (padding * 2) + 40 + sectionSpacing * 2 + analysisSectionHeight + commentSectionHeight;
                    const thumbnailHeight = 1350 - fixedVerticalSpace;
                    const totalHeight = 1350;

                    canvas.width = width;
                    canvas.height = totalHeight;
                    
                    ctx.fillStyle = '#4285F4'; // Gemini Blue
                    ctx.fillRect(0, 0, width, totalHeight);
                    
                    ctx.fillStyle = 'white';
                    this._drawRoundRect(ctx, padding, padding, contentWidth, totalHeight - padding * 2, 15);

                    let currentY = padding;

                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        ctx.save();
                        const thumbX = padding + 20;
                        const thumbY = currentY + 20;
                        const thumbAreaWidth = contentWidth - 40;
                        const thumbAreaHeight = thumbnailHeight - 20;
                        this._drawRoundRect(ctx, thumbX, thumbY, thumbAreaWidth, thumbAreaHeight, 10);
                        ctx.strokeStyle = '#e2e8f0';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.clip();

                        const thumbRatio = Math.min(thumbAreaWidth / img.width, thumbAreaHeight / img.height);
                        const thumbW = img.width * thumbRatio;
                        const thumbH = img.height * thumbRatio;
                        ctx.drawImage(img, thumbX + (thumbAreaWidth - thumbW) / 2, thumbY + (thumbAreaHeight - thumbH) / 2, thumbW, thumbH);
                        ctx.restore();

                        currentY += thumbnailHeight;
                        currentY += sectionSpacing;

                        const analysisBoxX = padding + 20;
                        const analysisBoxY = currentY;
                        const analysisBoxWidth = contentWidth - 40;
                        
                        ctx.fillStyle = '#f8fafc'; // slate-50 background
                        this._drawRoundRect(ctx, analysisBoxX, analysisBoxY, analysisBoxWidth, analysisSectionHeight, 10);
                        ctx.fill();
                        ctx.strokeStyle = '#e2e8f0';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        let innerY = analysisBoxY + 40; 
                        ctx.font = 'bold 32px Inter, sans-serif';
                        ctx.fillStyle = '#1e293b';
                        ctx.fillText('í‘œì • ë¶„ì„ ê²°ê³¼', analysisBoxX + 20, innerY);
                        innerY += 40; 

                        emotionOrder.forEach(emotion => {
                            const score = (expressionResult && expressionResult[emotion.key]) !== undefined ? expressionResult[emotion.key] : 0;
                            
                            ctx.font = '26px Inter, sans-serif';
                            ctx.fillStyle = '#475569';
                            ctx.textAlign = 'left';
                            ctx.fillText(emotion.label, analysisBoxX + 20, innerY + 24);

                            const barX = analysisBoxX + 180;
                            const barWidth = analysisBoxWidth - 300; 
                            
                            ctx.fillStyle = '#e2e8f0';
                            this._drawRoundRect(ctx, barX, innerY, barWidth, 36, 18);
                            
                            ctx.fillStyle = colorMap[emotion.color] || '#64748b';
                            this._drawRoundRect(ctx, barX, innerY, barWidth * score, 36, 18);

                            ctx.fillStyle = '#334155';
                            ctx.textAlign = 'right';
                            ctx.font = 'bold 26px Inter, sans-serif';
                            ctx.fillText(`${(score * 100).toFixed(0)}%`, analysisBoxX + analysisBoxWidth - 20, innerY + 24);

                            innerY += graphHeight;
                        });

                        currentY += analysisSectionHeight + sectionSpacing;
                        
                        const commentBoxX = padding + 20;
                        const commentBoxY = currentY;
                        const commentBoxWidth = contentWidth - 40;
                        
                        ctx.fillStyle = '#f8fafc'; // slate-50 background
                        this._drawRoundRect(ctx, commentBoxX, commentBoxY, commentBoxWidth, commentSectionHeight, 10);
                        ctx.fill();
                        ctx.strokeStyle = '#e2e8f0';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        innerY = commentBoxY + 40;
                        ctx.font = 'bold 32px Inter, sans-serif';
                        ctx.fillStyle = '#1e293b';
                        ctx.textAlign = 'left';
                        ctx.fillText('í•´ì„', commentBoxX + 20, innerY);
                        innerY += 40;

                        ctx.fillStyle = '#334155';
                        ctx.font = '26px "Noto Sans KR", sans-serif';
                        commentLines.forEach(line => {
                            ctx.fillText(line, commentBoxX + 20, innerY);
                            innerY += lineHeight;
                        });

                        resolve(canvas.toDataURL('image/png'));
                    };
                    img.onerror = reject;
                    img.src = baseImageUrl;
                });
            },
            
            async saveKeywordsToLibrary() {
                const appStore = Alpine.store('app');
                const keywordsToSave = this.analyzeState.keywordResult;

                if (!keywordsToSave || keywordsToSave.length === 0) {
                    appStore.showToast("ì €ìž¥í•  í‚¤ì›Œë“œê°€ ì—†ìŠµë‹ˆë‹¤.");
                    return;
                }

                const groupName = "ì´ë¯¸ì§€ ë¶„ì„";
                const tabName = "ë¶„ì„01";

                let targetGroup = appStore.keywordLibrary.userGroups.find(g => g.name === groupName);
                if (!targetGroup) {
                    const newGroup = {
                        id: 'user-' + Date.now() + Math.random(),
                        name: groupName,
                        keywords: [],
                        collapsed: false,
                        isDefault: false,
                        activeTab: tabName,
                        tabs: []
                    };
                    appStore.keywordLibrary.userGroups.unshift(newGroup);
                    targetGroup = newGroup;
                }

                let targetTab = targetGroup.tabs.find(t => t.name === tabName);
                if (!targetTab) {
                    const newTab = { name: tabName, keywordIds: [] };
                    targetGroup.tabs.push(newTab);
                    targetTab = newTab;
                }

                const newKeywords = [];
                const newKeywordIds = [];

                keywordsToSave.forEach(keywordStr => {
                    const newKeyword = {
                        id: 'user-' + Date.now() + Math.random(),
                        type: 'keyword',
                        keyword: keywordStr,
                        desc: '_',
                        isCustom: true
                    };
                    newKeywords.push(newKeyword);
                    newKeywordIds.push(newKeyword.id);
                });

                targetGroup.keywords.unshift(...newKeywords);
                targetTab.keywordIds.unshift(...newKeywordIds);

                appStore.saveState(false);
                appStore.showToast(`'${groupName}' ê·¸ë£¹ì— í‚¤ì›Œë“œ ${newKeywords.length}ê°œë¥¼ ì €ìž¥í–ˆìŠµë‹ˆë‹¤.`);
            }
        }));

            Alpine.store('app').loadState();
        });
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        body { font-family: 'Inter', 'Noto Sans KR', sans-serif; }
        .material-symbols-outlined { vertical-align: middle; font-variation-settings: 'FILL' 0, 'wght' 200, 'GRAD' 0, 'opsz' 24; }
        .toast { min-width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 8px; padding: 16px; position: fixed; z-index: 10000; left: 50%; bottom: 50px; transform: translateX(-50%); transition: all 0.5s; }
        .spinner { animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .library-item .item-controls { opacity: 0; }
        .library-item:hover .item-controls { opacity: 1; }

        .library-item { transition: all 0.2s ease-in-out; }
        .library-item.selected-in-promptBoard {
            background-color: #dbeafe !important; /* blue-200 */
        }
        .library-item:not(.selected-in-promptBoard):hover { background-color: #f0f9ff; }
        
        .keyword-tab { transition: all 0.2s ease-in-out; }
        .keyword-tab.active { border-color: #3b82f6; background-color: #3b82f6; color: white; }
        
        .promptBoard-area { transition: all 0.2s ease-in-out; border: 2px dashed transparent; }
        
        .prompt-keyword:hover .remove-keyword-btn { opacity: 1; }
        .remove-keyword-btn { opacity: 0; transition: opacity 0.2s; }
        .toggle-icon { transition: transform 0.2s ease-in-out; }
        .group-container.collapsed .toggle-icon { transform: rotate(-90deg); }
        .group-content { transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.3s; max-height: 1000px; overflow: hidden; opacity: 1;}
        .group-container.collapsed .group-content { max-height: 0; padding-top: 0; padding-bottom: 0; opacity: 0;}
        
        #image-result-container .loader { width: 50px; height: 50px; border-radius: 50%; display: inline-block; border-top: 5px solid #3498db; border-right: 5px solid transparent; box-sizing: border-box; animation: spin 1s linear infinite; }
        .thumbnail-item .remove-img-btn { opacity: 0; transition: opacity 0.2s; }
        .thumbnail-item:hover .remove-img-btn { opacity: 1; }
        .modal-backdrop { transition: opacity 0.3s ease-in-out; }
        .interactive-panel { transform: translateY(10px); transition: transform 0.3s ease-out, opacity 0.3s ease-out; }
        
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: #3b82f6; } /* blue-500 */
        input:checked + .toggle-slider:before { transform: translateX(22px); }
        #edit-canvas { z-index: 60; }
        #manual-prompt-textarea { min-height: 80px; resize: vertical; overflow-y: auto; }
        .interactive-btn { background-color: transparent; border-radius: 9999px; padding: 0.25rem; transition: all 0.2s ease-in-out; margin: 1px; }
        .interactive-btn:hover { background-color: rgba(255, 255, 255, 0.2); transform: scale(1.1); }
        .interactive-btn.selected { background-color: rgba(46, 213, 115, 0.3); outline: 2px solid #2ed573; }
        .group-header .group-controls { opacity: 0; transition: opacity 0.2s ease-in-out; }
        .group-header:hover .group-controls { opacity: 1; }

        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800"
    x-data="{ isMobile: window.innerWidth < 768 }"
    @resize.window="isMobile = window.innerWidth < 768"
    x-init="
        $watch('$store.app.keywordLibrary.searchTerm', (newValue, oldValue) => {
            const store = $store.app;
            const allGroups = [...store.keywordLibrary.defaultGroups, ...store.keywordLibrary.userGroups];
            
            if (newValue && !oldValue) { // Search starts
                store.keywordLibrary.preSearchCollapsedState = allGroups.reduce((acc, group) => {
                    acc[group.id] = group.collapsed;
                    return acc;
                }, {});
                 store.keywordLibrary.preSearchActiveTabState = allGroups.reduce((acc, group) => {
                    acc[group.id] = group.activeTab;
                    return acc;
                }, {});
            }

            if (newValue) { // While searching: Centralized logic to avoid race conditions
                const termLower = newValue.toLowerCase();
                allGroups.forEach(group => {
                    let isGroupVisible = false;
                    let matchingTabName = null;

                    const groupName = group.isDefault ? { subject: 'ì£¼ì œ', details: 'ì„¸ë¶€ ë¬˜ì‚¬', style: 'í‘œí˜„ ê¸°ë²•', composition: 'êµ¬ë„' }[group.id] : group.name;
                    if (groupName && groupName.toLowerCase().includes(termLower)) {
                        isGroupVisible = true;
                    }
                    
                    for (const tab of group.tabs) {
                        let tabContainsResult = false;
                        if (tab.name.toLowerCase().includes(termLower)) {
                            tabContainsResult = true;
                        } else {
                            tabContainsResult = tab.keywordIds.some(id => {
                                const keyword = group.keywords.find(k => k.id === id);
                                return keyword && (
                                    keyword.keyword.toLowerCase().includes(termLower) || 
                                    (keyword.desc && keyword.desc.toLowerCase().includes(termLower))
                                );
                            });
                        }
                        if (tabContainsResult) {
                            isGroupVisible = true;
                            if (!matchingTabName) { // Set only the first matching tab
                                matchingTabName = tab.name;
                            }
                        }
                    }

                    if (isGroupVisible) {
                        group.collapsed = false;
                        if (matchingTabName) {
                            group.activeTab = matchingTabName;
                        }
                    }
                });
            } else if (!newValue && oldValue) { // Search ends
                allGroups.forEach(group => {
                    if (store.keywordLibrary.preSearchCollapsedState && store.keywordLibrary.preSearchCollapsedState.hasOwnProperty(group.id)) {
                        group.collapsed = store.keywordLibrary.preSearchCollapsedState[group.id];
                    }
                    if (store.keywordLibrary.preSearchActiveTabState && store.keywordLibrary.preSearchActiveTabState.hasOwnProperty(group.id)) {
                        group.activeTab = store.keywordLibrary.preSearchActiveTabState[group.id];
                    }
                });
                store.keywordLibrary.preSearchCollapsedState = null;
                store.keywordLibrary.preSearchActiveTabState = null;
            }
        });
        $watch('$store.app.isPromptBoardEmpty', (isEmpty) => {
            $store.app.ui.isPromptBoardCollapsed = isEmpty;
        });
        $watch('$store.app.ui.selectedImageId', (newId) => {
            const store = $store.app;
            if (newId) {
                const selectedImage = store.imageStation.images.find(img => img.id === newId);
                if (selectedImage) {
                    store.updateImageInfo(selectedImage);
                }
            } else {
                store.ui.currentImageInfo = { name: '', resolution: '', size: '' };
            }
        });
        $watch('$store.app.settings.generationModel', (newValue) => {
            const settings = $store.app.settings;
            if (newValue === 'gemini') {
                settings.numberOfImages = 1;
            }
        });
    ">

    <div class="container mx-auto p-4 sm:p-6 max-w-7xl">
        <header class="flex justify-between items-center mb-6 sm:mb-8">
            <div class="w-10"></div>
            <div class="text-center">
                <!-- Responsive Font Size for Title -->
                <h1 class="text-3xl sm:text-5xl font-bold text-slate-900">âœ¨ ì„¸ë¹› ìŠ¤íŠœë””ì˜¤</h1>
            </div>
            <button id="settings-btn" class="text-slate-500 hover:text-blue-600 transition-colors w-10 h-10 flex items-center justify-center" title="ì„¤ì •" @click="$store.app.openModal('settings-modal')">
                <span class="material-symbols-outlined text-3xl">settings</span>
            </button>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <div 
                x-data="{ isAdding: false }"
                class="lg:col-span-1 bg-white p-4 sm:p-6 rounded-2xl shadow-lg flex flex-col"
                >
                <div class="flex justify-between items-center mb-4 border-b pb-2 border-slate-200">
                    <h2 class="text-xl sm:text-2xl font-bold">ðŸ“š í‚¤ì›Œë“œ ë¼ì´ë¸ŒëŸ¬ë¦¬</h2>
                    <button @click="isAdding = !isAdding"
                        class="text-slate-500 hover:text-blue-600 transition-colors"
                        title="ìƒˆ í‚¤ì›Œë“œ/ê·¸ë£¹ ì¶”ê°€">
                        <span class="material-symbols-outlined transition-transform text-2xl" :class="{'rotate-45': isAdding}">add_circle</span>
                    </button>
                </div>

                <div x-show="isAdding" x-transition class="mb-4 space-y-2">
                    <!-- Add Keyword Section -->
                    <div class="p-4 bg-slate-50 rounded-lg space-y-4">
                         <div x-data="{ newKeyword: '', newDesc: '' }">
                             <h4 class="font-bold text-slate-800">ìƒˆ í‚¤ì›Œë“œ ì¶”ê°€</h4>
                             <p class="text-sm text-slate-500">ì²«ë²ˆì§¸ ì‚¬ìš©ìž ê·¸ë£¹ì— ì¶”ê°€ë©ë‹ˆë‹¤.</p>
                             <div class="mt-2 space-y-2">
                                 <input type="text" placeholder="í‚¤ì›Œë“œ ì´ë¦„ (AI ì§€ì› ì‹œ ìžìœ ë¡­ê²Œ ìž…ë ¥)" class="w-full p-2 border rounded-md border-slate-300 bg-white" x-model="newKeyword" @keydown.enter="$store.app.addNewKeywordToKeywordLibrary(newKeyword, newDesc); newKeyword=''; newDesc='';">
                                 <input type="text" placeholder="ì„¤ëª… (ì„ íƒ, ë¹„ì›Œë‘˜ ìˆ˜ ìžˆìŒ)" class="w-full p-2 border rounded-md border-slate-300 bg-white" x-model="newDesc" @keydown.enter="$store.app.addNewKeywordToKeywordLibrary(newKeyword, newDesc); newKeyword=''; newDesc='';">
                                 <button class="w-full bg-blue-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-blue-600 flex items-center justify-center" @click="$store.app.addNewKeywordToKeywordLibrary(newKeyword, newDesc); newKeyword=''; newDesc='';" :disabled="$store.app.ui.isLoadingCompletion">
                                     <span class="material-symbols-outlined spinner text-base" x-show="$store.app.ui.isLoadingCompletion" x-cloak>progress_activity</span>
                                     <span x-show="!$store.app.ui.isLoadingCompletion">ë“±ë¡</span>
                                 </button>
                             </div>
                         </div>
                    </div>
                     <!-- Add Group Section -->
                    <div x-data="{ newGroupName: '' }" class="p-4 bg-slate-50 rounded-lg space-y-2">
                         <h4 class="font-bold text-slate-800">ìƒˆ ê·¸ë£¹ ì¶”ê°€</h4>
                        <input type="text" x-ref="newGroupNameInput" placeholder="ìƒˆ ê·¸ë£¹ ì´ë¦„ ìž…ë ¥..."
                               x-model="newGroupName"
                               @keydown.enter.prevent="$store.app.addNewKeywordLibraryGroup(newGroupName); newGroupName='';"
                               class="w-full p-2 border rounded-md border-slate-300 bg-white"
                               >
                        <button @click="$store.app.addNewKeywordLibraryGroup(newGroupName); newGroupName='';" class="w-full bg-blue-500 text-white font-semibold py-2 px-3 rounded-lg hover:bg-blue-600">ì¶”ê°€</button>
                    </div>
                </div>

                <div class="relative mb-4">
                    <span class="material-symbols-outlined absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">search</span>
                    <input type="text" id="keyword-search-input" placeholder="í‚¤ì›Œë“œ ê²€ìƒ‰..." class="w-full p-2 pl-10 border rounded-md border-slate-300 bg-white" x-model="$store.app.keywordLibrary.searchTerm">
                </div>

                <div id="keyword-list-container" class="space-y-3 flex-grow overflow-y-auto pr-2">
                    <template x-for="group in [...$store.app.keywordLibrary.defaultGroups, ...$store.app.keywordLibrary.userGroups]" :key="group.id">
                        <div x-data="keywordGroup(group)"
                             @click.outside="$store.app.keywordLibrary.tabDeleteState.groupId === group.id ? $store.app.keywordLibrary.tabDeleteState.active = false : null"
                             x-show="hasSearchResults"
                             class="group-container bg-slate-50 px-2 py-3 rounded"
                             :class="{'collapsed': !$store.app.keywordLibrary.searchTerm && group.collapsed}"
                             :data-group-id="group.id" 
                            >
                            <div class="group-header flex justify-between items-center cursor-pointer group" @click="!$store.app.keywordLibrary.searchTerm && (group.collapsed = !group.collapsed)">
                                <div class="flex items-center">
                                    <span class="material-symbols-outlined toggle-icon text-slate-500 mr-2">expand_more</span>
                                    <span class="font-bold text-slate-800 text-base sm:text-lg" x-text="group.isDefault ? { subject: 'ì£¼ì œ', details: 'ì„¸ë¶€ ë¬˜ì‚¬', style: 'í‘œí˜„ ê¸°ë²•', composition: 'êµ¬ë„' }[group.id] : group.name"></span>
                                    <span class="keyword-count ml-2 text-xs text-slate-500" x-text="`(${filteredCount})`"></span>
                                </div>
                                <div class="group-controls flex items-center gap-1">
                                    <button x-show="!group.isDefault" @click.stop="$store.app.deleteUserKeywordLibraryGroup(group.id)" class="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100" title="ê·¸ë£¹ ì‚­ì œ">
                                        <span class="material-symbols-outlined text-base">delete</span>
                                    </button>
                                </div>
                            </div>
                            <div x-show="!(!$store.app.keywordLibrary.searchTerm && group.collapsed)" class="group-content pt-3">
                                <div class="flex items-center flex-wrap gap-1 mb-3 border-t pt-3 border-slate-200">
                                    <template x-for="tab in group.tabs" :key="tab.name">
                                        <div class="relative shrink-0">
                                            <button @click.stop="group.activeTab = tab.name" 
                                                    class="keyword-tab text-xs font-semibold py-1 px-3 rounded-full border"
                                                    :class="{ 'active': group.activeTab === tab.name, 'bg-white': group.activeTab !== tab.name }">
                                                <span x-text="tab.name"></span>
                                            </button>
                                            <button x-show="$store.app.keywordLibrary.tabDeleteState.active && $store.app.keywordLibrary.tabDeleteState.groupId === group.id && group.tabs.length > 1"
                                                    @click.stop="$store.app.deleteTabFromKeywordLibraryGroup(group.id, tab.name)"
                                                    class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-4 h-4 flex items-center justify-center text-xs leading-none hover:bg-red-700 transition-colors" x-cloak>&times;</button>
                                        </div>
                                    </template>
                                    <template x-if="!group.isDefault">
                                        <div class="relative shrink-0">
                                            <button x-show="!isAddingTab"
                                                    @click.stop="isAddingTab = true; $nextTick(() => $refs.newTabInput?.focus()); group.collapsed=false"
                                                    class="bg-blue-100 text-blue-600 rounded-full w-6 h-6 flex items-center justify-center hover:bg-blue-200"
                                                    title="íƒ­ ì¶”ê°€">
                                                <span class="material-symbols-outlined text-base">add</span>
                                            </button>
                                            <div x-show="isAddingTab" @click.stop @keydown.escape.prevent="isAddingTab = false; newTabName = ''" class="flex items-center gap-1 p-1 bg-slate-200 rounded-lg" x-cloak>
                                                <input type="text" x-ref="newTabInput" x-model="newTabName" placeholder="ìƒˆ íƒ­ ì´ë¦„"
                                                       class="text-xs p-1 rounded-md border-slate-300 w-24"
                                                       @keydown.enter.prevent="confirmAddTab()">
                                                <button @click="confirmAddTab()" class="text-green-600 hover:bg-green-100 rounded-full p-0.5">
                                                    <span class="material-symbols-outlined text-sm">check</span>
                                                </button>
                                                <button @click="isAddingTab = false; newTabName = ''" class="text-red-500 hover:bg-red-100 rounded-full p-0.5">
                                                    <span class="material-symbols-outlined text-sm">close</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="relative shrink-0">
                                             <button @click.stop="$store.app.toggleKeywordLibraryTabDeleteMode(group.id); group.collapsed=false" x-show="group.tabs.length > 1"
                                                    class="rounded-full w-6 h-6 flex items-center justify-center"
                                                    :class="$store.app.keywordLibrary.tabDeleteState.active && $store.app.keywordLibrary.tabDeleteState.groupId === group.id ? 'bg-red-200 text-red-700 hover:bg-red-300' : 'bg-red-100 text-red-600 hover:bg-red-200'"
                                                    title="íƒ­ ì‚­ì œ">
                                                <span class="material-symbols-outlined text-base">remove</span>
                                            </button>
                                        </div>
                                    </template>
                                </div>
                                <ul class="space-y-1 max-h-96 overflow-y-auto">
                                    <template x-for="(item, index) in filteredKeywords" :key="item.id">
                                        <li>
                                             <div class="library-item bg-white p-3 rounded-lg border shadow-sm flex justify-between items-center cursor-pointer"
                                                  @click="$store.app.handleKeywordLibraryClick($event, item, group)"
                                                  :class="{ 'selected-in-promptBoard': $store.app.promptBoard.activeKeywordIds.includes(item.id) }">
                                                <div>
                                                    <p class="font-bold" x-text="item.keyword"></p>
                                                    <p class="text-sm text-slate-500" x-text="item.desc"></p>
                                                </div>
                                                <template x-if="item.isCustom">
                                                    <div class="item-controls flex items-center gap-1 transition-opacity">
                                                        <button @click.stop="$store.app.openKeywordLibraryMoveMenu($event, item, group)" 
                                                                class="p-1 rounded-full text-slate-500 hover:bg-slate-200"
                                                                title="ìœ„ì¹˜ ë³€ê²½">
                                                            <span class="material-symbols-outlined text-base">open_with</span>
                                                        </button>
                                                        <button @click.stop="$store.app.removeKeywordFromKeywordLibrary(group.id, item.id)"
                                                                class="p-1 rounded-full text-red-500 hover:bg-red-100"
                                                                title="ì‚­ì œ">
                                                            <span class="material-symbols-outlined text-base">delete</span>
                                                        </button>
                                                    </div>
                                                </template>
                                             </div>
                                        </li>
                                    </template>
                                </ul>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Right Column: Prompt Board, Image Station & Generator Deck -->
            <div class="lg:col-span-2 space-y-4">
                <div id="promptBoard-container"
                     class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg group-container transition-all"
                     :class="{'collapsed': $store.app.ui.isPromptBoardCollapsed}">
                    <div class="flex flex-wrap justify-between items-center border-b pb-2 gap-2 border-slate-200">
                        <div class="flex items-center gap-4">
                            <h2 class="text-xl sm:text-2xl font-bold">ðŸ“ í”„ë¡¬í”„íŠ¸ ë³´ë“œ</h2>
                            <button class="text-slate-500 hover:text-blue-600 transition-colors" title="ìˆ˜ë™ í”„ë¡¬í”„íŠ¸ íŽ¸ì§‘" @click="$store.app.openModal('manual-prompt-modal')">
                                <span class="material-symbols-outlined">keyboard</span>
                            </button>
                            <button class="text-slate-500 hover:text-blue-600 transition-colors" title="í”„ë¦¬ì…‹ ê´€ë¦¬" @click.stop="$store.app.openModal('load-preset-modal')">
                                <span class="material-symbols-outlined">folder</span>
                            </button>
                        </div>
                        <div class="flex gap-2 flex-wrap">
                            <button class="bg-[#4285F4] hover:bg-[#3367D6] text-white font-bold py-2 px-4 rounded-lg transition-colors inline-flex items-center gap-2 disabled:opacity-50 text-sm sm:text-base" @click="$store.app.generatePromptSentence()" :disabled="$store.app.ui.isLoadingCompletion">
                                <span class="material-symbols-outlined text-base spinner" x-show="$store.app.ui.isLoadingCompletion" x-cloak>progress_activity</span>
                                <span class="material-symbols-outlined text-base" x-show="!$store.app.ui.isLoadingCompletion">lightbulb</span>
                                <span>AI í”„ë¡¬í”„íŠ¸ ì™„ì„±</span>
                            </button>
                             <button class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition-opacity inline-flex items-center gap-2 text-sm sm:text-base" @click="$store.app.clearPromptBoardAndImageStation()">
                                <span class="material-symbols-outlined text-base">delete</span> 
                                <span>ë¹„ìš°ê¸°</span>
                            </button>
                        </div>
                    </div>
                    <div class="group-content pt-4">
                        <div id="promptBoard" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <template x-for="area in $store.app.promptBoardAreaInfo" :key="area.key">
                                <div x-data="promptBoardArea(area.key, area.title)"
                                     :id="`area-${key}`"
                                     class="promptBoard-area bg-slate-50 px-4 py-3 rounded-lg relative"
                                     @dragover.prevent="$store.app.handlePromptBoardDragOver($event, key)"
                                     @drop.prevent="$store.app.handlePromptBoardDrop($event, key)">
                                    <h3 class="font-bold text-base sm:text-lg mb-2" x-text="title"></h3>
                                    <div class="flex flex-wrap gap-2 min-h-[36px] relative">
                                        <template x-for="(item, index) in keywords" :key="item.instanceId">
                                            <div class="prompt-keyword bg-blue-100 text-blue-800 text-sm font-semibold px-3 py-1 rounded-full flex items-center gap-2 cursor-grab border-2 border-transparent" 
                                                :data-instance-id="item.instanceId" :data-id="item.id" draggable="true" 
                                                @dragstart="$store.app.handlePromptBoardDragStart($event, item, key)"
                                                :class="{'opacity-25': $store.app.promptBoard.draggingItem && $store.app.promptBoard.draggingItem.item.instanceId === item.instanceId}">
                                                <span x-text="item.keyword"></span>
                                                <button class="remove-keyword-btn text-blue-600 hover:text-blue-900" @click="$store.app.removeKeywordFromPromptBoard(item.instanceId)">
                                                    <span class="material-symbols-outlined text-base pointer-events-none">cancel</span>
                                                </button>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                            </template>
                        </div>
                        <div class="mt-4 pt-4 border-t border-slate-200">
                            <div class="flex justify-between items-center gap-4 mb-2">
                                <h3 class="text-lg font-bold">ìµœì¢… í”„ë¡¬í”„íŠ¸</h3>
                                <div class="text-sm text-slate-500 ml-auto" :class="{ 'text-red-500 font-bold': $store.app.promptLengthInfo.exceeds }">
                                    <span x-text="`${$store.app.promptLengthInfo.current} / ${$store.app.promptLengthInfo.max} ìž`"></span>
                                </div>
                            </div>
                             <div class="relative group">
                                <textarea id="result-output" rows="4" class="w-full p-4 border border-slate-300 rounded-lg bg-slate-100 text-slate-700 transition-all" readonly :value="$store.app.getFinalPrompt()"></textarea>
                                 <button @click="$store.app.copyToClipboard($store.app.getFinalPrompt())" title="í”„ë¡¬í”„íŠ¸ ë³µì‚¬"
                                        class="absolute top-2 right-2 p-1.5 bg-slate-200 text-slate-600 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity hover:bg-slate-300">
                                    <span class="material-symbols-outlined text-base">content_copy</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg">
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-2 border-b pb-2 border-slate-200">
                        <div class="flex items-center gap-4">
                            <h2 class="text-xl sm:text-2xl font-bold">ðŸ–¼ï¸ ì´ë¯¸ì§€ ìŠ¤í…Œì´ì…˜</h2>
                            <label for="image-upload-input" class="cursor-pointer text-slate-500 hover:text-blue-600" title="ì´ë¯¸ì§€ ì²¨ë¶€">
                                <span class="material-symbols-outlined">attachment</span>
                            </label>
                            <div class="relative">
                                <button @click="!isMobile && ($store.app.ui.isToolboxOpen = !$store.app.ui.isToolboxOpen)"
                                        :title="isMobile ? 'íŽ¸ì§‘ ë„êµ¬ëŠ” PCì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤' : 'íŽ¸ì§‘ ë„êµ¬ ìƒìž'"
                                        :disabled="isMobile"
                                        class="cursor-pointer text-slate-500 hover:text-blue-600"
                                        :class="{ 'opacity-50 cursor-not-allowed': isMobile }">
                                    <span class="material-symbols-outlined">construction</span>
                                </button>
                                <div x-show="$store.app.ui.isToolboxOpen"
                                     @click.outside="$store.app.ui.isToolboxOpen = false"
                                     x-transition
                                     class="absolute top-0 left-full ml-2 w-52 bg-white rounded-lg shadow-xl border z-10 p-2 space-y-1" x-cloak>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'draw'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>ðŸŽ¨ ê·¸ë¦¼ ê·¸ë¦¬ê¸°</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'refine'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>ðŸ“¸ ì´ë¯¸ì§€ ë³´ì •</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'inpaint'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>ðŸ–Œï¸ ë¶€ë¶„ ìˆ˜ì •</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'outpaint'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>ðŸ“ ìº”ë²„ìŠ¤ í™•ìž¥</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'infuse'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>ðŸ§ª í”¼ì‚¬ì²´ ì œì–´</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'analyze'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>ðŸ”¬ ì´ë¯¸ì§€ ë¶„ì„</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="text-sm text-slate-500" :class="{ 'text-red-500 font-bold': $store.app.referenceImagesSizeInfo.exceeds }">
                            <span x-text="`${$store.app.referenceImagesSizeInfo.current.toFixed(1)} / ${$store.app.referenceImagesSizeInfo.max.toFixed(1)} MB`"></span>
                        </div>
                        <input type="file" id="image-upload-input" multiple accept="image/*" class="hidden" @change="$store.app.handleFileUpload($event)">
                    </div>
                    <div id="image-thumbnail-container" class="flex flex-wrap items-center gap-1.5 bg-slate-50 rounded-lg transition-all duration-300 ease-in-out overflow-hidden"
                        :class="{
                             'min-h-[80px] p-1': $store.app.imageStation.images.length > 0,
                             'max-h-0': $store.app.imageStation.images.length === 0
                         }">
                        <template x-for="(img, index) in $store.app.imageStation.images" :key="img.id">
                            <div class="thumbnail-item relative cursor-pointer"
                                @click="$store.app.selectImage(img)"
                                draggable="true"
                                @dragstart="$store.app.handleImageDragStart($event, img)"
                                @dragover.prevent="$store.app.handleImageDragOver($event, index)"
                                @drop.prevent="$store.app.handleImageDrop($event, index)">
                                <img :src="img.dataUrl" class="w-16 h-16 object-cover rounded-md pointer-events-none" :class="{ 'ring-2 ring-offset-2 ring-blue-500': $store.app.ui.selectedImageId === img.id, 'opacity-50': $store.app.imageStation.draggingItem && $store.app.imageStation.draggingItem.id === img.id }">
                                <div x-show="index < $store.app.settings.referenceImageCount" class="absolute top-0 left-0 bg-black bg-opacity-60 text-white rounded-br-md rounded-tl-md text-xs font-bold w-4 h-4 flex items-center justify-center" x-text="index + 1" x-cloak></div>
                                <button class="remove-img-btn absolute top-0 right-0 bg-black bg-opacity-50 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs -mt-1 -mr-1" @click.stop="$store.app.removeFromImageStation(img.id)">
                                    <span class="material-symbols-outlined text-sm pointer-events-none">close</span>
                                </button>
                            </div>
                        </template>
                    </div>
                </div>

                <!-- Generator Deck -->
                <div id="generatorDeck-container" class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg">
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center sm:gap-3 mb-4">
                         <div class="flex-grow flex flex-col sm:flex-row sm:items-center sm:justify-start sm:gap-4 gap-y-3">
                            <h2 class="text-xl sm:text-2xl font-bold">ðŸš€ ì œë„ˆë ˆì´í„° ë±</h2>
                            <div class="flex items-center gap-4">
                                <div x-data="{ open: false }" class="relative">
                                    <button @click="open = !open"
                                            class="text-slate-500 hover:text-blue-600 transition-colors" title="íŒŒë¼ë¯¸í„° ì„¤ì •">
                                        <span class="material-symbols-outlined">tune</span>
                                    </button>
                                    <div x-show="open" @click.outside="open = false" x-transition class="absolute z-10 top-full mt-2 right-0 sm:left-0 sm:right-auto bg-white rounded-lg shadow-xl border w-80 p-4 space-y-4">
                                        <div class="space-y-2">
                                            <label class="text-sm font-bold text-slate-700">ìƒì„± ëª¨ë¸</label>
                                             <div class="inline-flex rounded-md shadow-sm w-full" role="group">
                                                <button type="button" @click="$store.app.settings.generationModel = 'gemini'" class="w-1/2 px-4 py-2 text-sm font-medium rounded-l-lg border focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.generationModel === 'gemini', 'bg-white text-gray-900 border-gray-200': $store.app.settings.generationModel !== 'gemini' }">ðŸŒ Gemini Flash</button>
                                                <button type="button" @click="$store.app.settings.generationModel = 'imagen'" class="w-1/2 px-4 py-2 text-sm font-medium rounded-r-lg border focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.generationModel === 'imagen', 'bg-white text-gray-900 border-gray-200': $store.app.settings.generationModel !== 'imagen' }">ðŸ”® Imagen 3</button>
                                             </div>
                                        </div>
                                        <div class="space-y-2">
                                            <label class="text-sm font-bold text-slate-700">AI í•´ì„ ìˆ˜ì¤€</label>
                                             <div class="inline-flex rounded-md shadow-sm w-full" role="group">
                                                <button type="button" @click="$store.app.settings.interpretationLevel = 'precise'" class="w-1/3 px-4 py-2 text-sm font-medium rounded-l-lg border focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.interpretationLevel === 'precise', 'bg-white text-gray-900 border-gray-200': $store.app.settings.interpretationLevel !== 'precise' }">ì •í™•í•˜ê²Œ</button>
                                                <button type="button" @click="$store.app.settings.interpretationLevel = 'balanced'" class="w-1/3 px-4 py-2 text-sm font-medium border-t border-b focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.interpretationLevel === 'balanced', 'bg-white text-gray-900 border-gray-200': $store.app.settings.interpretationLevel !== 'balanced' }">ê· í˜• ìžˆê²Œ</button>
                                                <button type="button" @click="$store.app.settings.interpretationLevel = 'creative'" class="w-1/3 px-4 py-2 text-sm font-medium rounded-r-lg border focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.interpretationLevel === 'creative', 'bg-white text-gray-900 border-gray-200': $store.app.settings.interpretationLevel !== 'creative' }">ìžìœ ë¡­ê²Œ</button>
                                             </div>
                                        </div>
                                        <div class="space-y-2">
                                            <label for="reference-image-count" class="text-sm font-bold text-slate-700">ì°¸ì¡° ì´ë¯¸ì§€: <span x-text="$store.app.settings.referenceImageCount"></span></label>
                                            <input id="reference-image-count" type="range" min="0" max="4" x-model.number="$store.app.settings.referenceImageCount" class="w-full">
                                        </div>
                                        <div class="space-y-2">
                                            <label for="number-of-images" class="text-sm font-bold text-slate-700" :class="{'text-slate-400': $store.app.settings.generationModel === 'gemini'}">ì¶œë ¥ ì´ë¯¸ì§€: <span x-text="$store.app.settings.numberOfImages"></span></label>
                                            <input id="number-of-images" type="range" min="1" max="4" step="1" x-model.number="$store.app.settings.numberOfImages" class="w-full" :disabled="$store.app.settings.generationModel === 'gemini'">
                                        </div>
                                        <div class="space-y-4 pt-2 border-t border-slate-200">
                                             <div class="space-y-2">
                                                <div class="flex items-center">
                                                    <label class="text-sm font-bold text-slate-700">ë¹„ìœ¨</label>
                                                </div>
                                                <select x-model="$store.app.settings.aspectRatio" class="w-full p-2 border rounded-md border-slate-300 bg-white" :disabled="$store.app.settings.generationModel === 'gemini' && $store.app.imageStation.images.slice(0, $store.app.settings.referenceImageCount).length > 0">
                                                    <template x-for="option in $store.app.aspectRatioOptions" :key="option.ratio">
                                                        <option :value="option.ratio" x-text="`${option.ratio} ${option.desc}`"></option>
                                                    </template>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button class="text-slate-500 hover:text-blue-600 transition-colors" title="í”„ë¡¬í”„íŠ¸ ìƒì„± ížˆìŠ¤í† ë¦¬" @click="$store.app.openModal('history-modal')">
                                    <span class="material-symbols-outlined">history</span>
                                </button>
                            </div>
                        </div>
                        <div class="w-full sm:w-auto">
                            <button id="generate-image-btn" class="w-full sm:w-auto bg-[#4285F4] hover:bg-[#3367D6] text-white font-bold py-2 px-4 rounded-lg transition-colors inline-flex items-center justify-center gap-2 disabled:opacity-50" @click="$store.app.generateImage()" :disabled="$store.app.ui.isLoadingImage">
                                <span class="material-symbols-outlined text-base spinner" x-show="$store.app.ui.isLoadingImage" x-cloak>progress_activity</span>
                                <span class="material-symbols-outlined text-base" x-show="!$store.app.ui.isLoadingImage">auto_awesome</span>
                                <span>ì´ë¯¸ì§€ ìƒì„±</span>
                            </button>
                        </div>
                    </div>
                    
                    <div id="deck-output-container" 
                        class="w-full aspect-square bg-slate-100 rounded-lg flex items-center justify-center relative transition-all">
                        <div id="image-loader" class="loader" x-show="$store.app.ui.isLoadingImage" x-cloak></div>
                        <img id="deck-generated-image" :src="$store.app.ui.generatedImageUrl" alt="AI Generated Image" class="w-full h-full object-contain rounded-lg" x-show="$store.app.ui.generatedImageUrl && !$store.app.ui.isLoadingImage" draggable="false" x-cloak>
                        <p id="deck-placeholder-text" class="text-slate-500" x-show="!$store.app.ui.generatedImageUrl && !$store.app.ui.isLoadingImage">AI ìƒì„± ì´ë¯¸ì§€ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
                        
                        <div class="absolute top-3 left-3 flex items-start gap-2" x-show="$store.app.ui.generatedImageUrl && !$store.app.ui.isLoadingImage" x-cloak>
                            <div class="group relative">
                                <button @click="$store.app.ui.isImageInfoPinned = !$store.app.ui.isImageInfoPinned"
                                        class="bg-white text-slate-700 font-bold py-1 px-3 rounded-lg hover:bg-slate-200 transition-all shadow-md"
                                        :class="{ 'bg-blue-500 text-white hover:bg-blue-600': $store.app.ui.isImageInfoPinned }">
                                    <span class="material-symbols-outlined text-base">info</span>
                                </button>
                                <div class="absolute left-0 top-full mt-2 w-48 bg-black/70 backdrop-blur-sm text-white text-xs rounded-lg p-2 shadow-lg transition-opacity pointer-events-none"
                                     :class="{
                                         'opacity-100': $store.app.ui.isImageInfoPinned,
                                         'opacity-0 group-hover:opacity-100': !$store.app.ui.isImageInfoPinned
                                     }">
                                    <p class="font-bold truncate" x-text="$store.app.ui.currentImageInfo.name || '...'" title="íŒŒì¼ëª…"></p>
                                    <p x-text="`í•´ìƒë„: ${$store.app.ui.currentImageInfo.resolution || '...'}`"></p>
                                    <p x-text="`í¬ê¸°: ${$store.app.ui.currentImageInfo.size || '...'}`"></p>
                                </div>
                            </div>
                        </div>

                        <div class="absolute top-3 right-3 flex gap-2" x-show="$store.app.ui.generatedImageUrl && !$store.app.ui.isLoadingImage" x-cloak>
                            <a :href="$store.app.ui.generatedImageUrl" :download="$store.app.ui.currentImageInfo.name || `sevit_studio_${Date.now()}.png`" class="bg-white text-slate-700 font-bold py-1 px-3 rounded-lg hover:bg-slate-200 transition-all shadow-md" title="ë‹¤ìš´ë¡œë“œ" id="download-image-btn">
                                <span class="material-symbols-outlined text-base">download</span>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Unified Edit Canvas -->
    <div id="edit-canvas" x-data="editCanvas()" x-show="$store.app.ui.activeModal === 'edit-canvas'" 
         x-transition class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-stretch justify-center p-4" 
         @click.self="$store.app.closeModal()" 
         @resize.window.debounce.250ms="handleResize()" 
         x-cloak>
        <div class="flex items-stretch gap-2 w-full h-full mx-auto">
            <div x-ref="canvasWrapper" class="relative flex items-center justify-center flex-grow h-full bg-slate-900/50 rounded-lg w-full">
                <canvas x-ref="canvas" class="rounded-lg shadow-xl"></canvas>
                <div x-show="isLoading && mode === 'infuse'" class="absolute inset-0 bg-black/50 flex items-center justify-center rounded-lg" x-cloak>
                    <div class="w-16 h-16 border-8 border-dashed rounded-full animate-spin border-sky-400"></div>
                </div>
                <!-- [MODIFIED] Image Navigation for ALL Modes -->
                <template x-if="$store.app.imageStation.images.length > 1">
                    <div class="absolute inset-0 flex items-center justify-between pointer-events-none p-2">
                        <button @click="$store.app.navigateToPreviousImage()"
                                :disabled="!canNavigatePrevious"
                                class="w-10 h-10 bg-black/30 text-white rounded-full hover:bg-black/60 disabled:opacity-20 disabled:cursor-not-allowed pointer-events-auto transition-all backdrop-blur-sm">
                            &#9664;
                        </button>
                        <button @click="$store.app.navigateToNextImage()"
                                :disabled="!canNavigateNext"
                                class="w-10 h-10 bg-black/30 text-white rounded-full hover:bg-black/60 disabled:opacity-20 disabled:cursor-not-allowed pointer-events-auto transition-all backdrop-blur-sm">
                            &#9654;
                        </button>
                    </div>
                </template>
            </div>
            <div class="flex-shrink-0 self-start mt-16 flex flex-col gap-2 bg-slate-800 p-4 rounded-lg shadow-2xl w-full md:w-80">
                <div class="flex justify-center items-center relative">
                    <h3 class="text-white font-bold text-center text-xl" x-text="title"></h3>
                </div>

                <div class="relative">
                    <div class="grid grid-cols-6 gap-1 p-1 bg-slate-700 rounded-lg">
                        <template x-for="item in [
                            { mode: 'draw', icon: 'ðŸŽ¨', title: 'ê·¸ë¦¼ ê·¸ë¦¬ê¸°' },
                            { mode: 'refine', icon: 'ðŸ“¸', title: 'ì´ë¯¸ì§€ ë³´ì •' },
                            { mode: 'inpaint', icon: 'ðŸ–Œï¸', title: 'ë¶€ë¶„ ìˆ˜ì •' },
                            { mode: 'outpaint', icon: 'ðŸ“', title: 'ìº”ë²„ìŠ¤ í™•ìž¥' },
                            { mode: 'infuse', icon: 'ðŸ§ª', title: 'í”¼ì‚¬ì²´ ì œì–´' },
                            { mode: 'analyze', icon: 'ðŸ”¬', title: 'ì´ë¯¸ì§€ ë¶„ì„' }
                        ]" :key="item.mode">
                            <button 
                                @click="switchMode(item.mode)"
                                :disabled="isLoading || mode === item.mode"
                                :title="item.title"
                                class="py-2 rounded-md text-xl transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                :class="{
                                    'bg-sky-500': mode === item.mode,
                                    'hover:bg-slate-600': mode !== item.mode
                                }">
                                <span x-text="item.icon"></span>
                            </button>
                        </template>
                    </div>
                </div>

                <!-- [REVISED] Main Content Wrapper for proper layout -->
                <div class="flex-grow flex flex-col min-h-0">
                    <div class="flex-grow overflow-y-auto space-y-2 pr-2 -mr-2 scrollbar-hide">
                        <!-- Dynamic Controls Area -->
                        <div class="space-y-2">
                            <!-- Draw Controls -->
                            <template x-if="mode === 'draw'">
                                <div class="space-y-4">
                                    <div>
                                        <label class="font-semibold text-sm text-white">ìƒ‰ìƒ</label>
                                        <input type="color" x-model="brushColor" @input="updateBrush()" class="w-full h-10 p-1 border rounded-md cursor-pointer">
                                    </div>
                                    <div>
                                        <label class="font-semibold text-sm text-white"><span>í¬ê¸°</span>: <span x-text="brushSize"></span></label>
                                        <input type="range" min="1" max="50" x-model="brushSize" @input="updateBrush()" class="w-full">
                                    </div>
                                    <div class="pt-4 border-t border-slate-700 space-y-2">
                                        <label class="text-sm font-semibold text-white mb-2 block">AI ì§€ì›</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <button @click="activeAISupport = (activeAISupport === 'line-cleanup' ? null : 'line-cleanup')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="activeAISupport === 'line-cleanup' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                ì„  ì •ë¦¬
                                            </button>
                                            <button @click="activeAISupport = (activeAISupport === 'sketch-complete' ? null : 'sketch-complete')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="activeAISupport === 'sketch-complete' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                ìŠ¤ì¼€ì¹˜ ì™„ì„±
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </template>

                            <!-- Refine Controls -->
                            <template x-if="mode === 'refine'">
                                <div class="space-y-4">
                                    <div class="space-y-2">
                                        <label class="text-sm font-semibold text-white mb-2 block">ê¸°ë³¸ ë³€í™˜</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <button @click="rotateImage(-90)" class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors bg-slate-600 text-slate-200 hover:bg-slate-500 flex items-center justify-center gap-1">
                                                <span class="material-symbols-outlined text-sm">rotate_left</span> ì¢ŒíšŒì „
                                            </button>
                                            <button @click="rotateImage(90)" class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors bg-slate-600 text-slate-200 hover:bg-slate-500 flex items-center justify-center gap-1">
                                                <span class="material-symbols-outlined text-sm">rotate_right</span> ìš°íšŒì „
                                            </button>
                                            <button @click="flipImage('X')" class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors bg-slate-600 text-slate-200 hover:bg-slate-500 flex items-center justify-center gap-1">
                                                <span class="material-symbols-outlined text-sm">flip</span> ì¢Œìš° ë°˜ì „
                                            </button>
                                            <button @click="flipImage('Y')" class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors bg-slate-600 text-slate-200 hover:bg-slate-500 flex items-center justify-center gap-1">
                                                <span class="material-symbols-outlined text-sm" style="transform: rotate(90deg);">flip</span> ìƒí•˜ ë°˜ì „
                                            </button>
                                        </div>
                                    </div>
                                     <div class="pt-4 border-t border-slate-700">
                                        <div class="grid grid-cols-2 gap-x-4 gap-y-3">
                                            <div>
                                                <label class="text-sm font-semibold text-white">ë°ê¸°: <span x-text="(refineState.brightness * 100).toFixed(0)"></span></label>
                                                <input type="range" x-model.number="refineState.brightness" min="-1" max="1" step="0.01" class="w-full" @input.debounce.10ms="handleFilterChange()">
                                            </div>
                                            <div>
                                                <label class="text-sm font-semibold text-white">ëŒ€ë¹„: <span x-text="(refineState.contrast * 100).toFixed(0)"></span></label>
                                                <input type="range" x-model.number="refineState.contrast" min="-1" max="1" step="0.01" class="w-full" @input.debounce.10ms="handleFilterChange()">
                                            </div>
                                            <div>
                                                <label class="text-sm font-semibold text-white">ì±„ë„: <span x-text="(refineState.saturation * 100).toFixed(0)"></span></label>
                                                <input type="range" x-model.number="refineState.saturation" min="-1" max="1" step="0.01" class="w-full" @input.debounce.10ms="handleFilterChange()">
                                            </div>
                                            <div>
                                                <label class="text-sm font-semibold text-white">ìƒ‰ì¡°: <span x-text="(refineState.hue * 100).toFixed(0)"></span></label>
                                                <input type="range" x-model.number="refineState.hue" min="-1" max="1" step="0.01" class="w-full" @input.debounce.10ms="handleFilterChange()">
                                            </div>
                                        </div>
                                    </div>
                                    <div class="pt-4 border-t border-slate-700 space-y-2">
                                        <label class="text-sm font-semibold text-white mb-2 block">í•„í„°</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <button @click="refineState.activeFilter = (refineState.activeFilter === 'grayscale' ? null : 'grayscale'); handleFilterChange()" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeFilter === 'grayscale' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">í‘ë°±</button>
                                            <button @click="refineState.activeFilter = (refineState.activeFilter === 'sepia' ? null : 'sepia'); handleFilterChange()" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeFilter === 'sepia' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">ì„¸í”¼ì•„</button>
                                            <button @click="refineState.activeFilter = (refineState.activeFilter === 'invert' ? null : 'invert'); handleFilterChange()" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeFilter === 'invert' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">ìƒ‰ìƒ ë°˜ì „</button>
                                            <button @click="refineState.activeFilter = (refineState.activeFilter === 'blur' ? null : 'blur'); handleFilterChange()" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeFilter === 'blur' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">ë¸”ëŸ¬</button>
                                        </div>
                                    </div>                            
                                    <div class="pt-4 border-t border-slate-700 space-y-2">
                                        <label class="text-sm font-semibold text-white mb-2 block">AI ë³´ì •</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <button @click="refineState.activeAICorrection = (refineState.activeAICorrection === 'background-removal' ? null : 'background-removal')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeAICorrection === 'background-removal' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                ë°°ê²½ ì œê±°
                                            </button>
                                            <button @click="refineState.activeAICorrection = (refineState.activeAICorrection === 'colorize' ? null : 'colorize')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeAICorrection === 'colorize' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                AI ì±„ìƒ‰
                                            </button>
                                            <button @click="refineState.activeAICorrection = (refineState.activeAICorrection === 'quality-enhance' ? null : 'quality-enhance')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeAICorrection === 'quality-enhance' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                í’ˆì§ˆ ê°œì„ 
                                            </button>
                                            <button @click="refineState.activeAICorrection = (refineState.activeAICorrection === 'id-photo' ? null : 'id-photo')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeAICorrection === 'id-photo' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                ì¦ëª…ì‚¬ì§„ ë³€í™˜
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Inpaint Controls -->
                            <template x-if="mode === 'inpaint'">
                                <div class="space-y-4">
                                    <div class="space-y-2">
                                        <label class="text-white text-sm font-semibold">ë§ˆìŠ¤í¬ ëª¨ë“œ</label>
                                        <div class="inline-flex rounded-md shadow-sm w-full" role="group">
                                            <button type="button" @click="maskMode = 'transform'" class="w-1/2 px-4 py-2 text-sm font-medium text-white bg-transparent rounded-l-lg border border-gray-500 hover:bg-sky-600 hover:border-sky-600 focus:z-10 focus:ring-2 focus:ring-sky-500 transition-colors" :class="{'bg-sky-500 border-sky-500': maskMode === 'transform'}">ì˜ì—­ ë³€í™˜</button>
                                            <button type="button" @click="maskMode = 'preserve'" class="w-1/2 px-4 py-2 text-sm font-medium text-white bg-transparent rounded-r-lg border border-gray-500 hover:bg-sky-600 hover:border-sky-600 focus:z-10 focus:ring-2 focus:ring-sky-500 transition-colors" :class="{'bg-sky-500 border-sky-500': maskMode === 'preserve'}">ì˜ì—­ ìœ ì§€</button>
                                        </div>
                                    </div>
                                    <div class="space-y-2">
                                        <label class="text-white text-sm font-semibold"><span>ë¸ŒëŸ¬ì‹œ í¬ê¸°</span>: <span x-text="brushSize"></span></label>
                                        <input type="range" min="5" max="100" x-model="brushSize" @input="updateBrush()" class="w-full">
                                    </div>
                                    <div class="space-y-2">
                                        <div class="flex justify-between items-center mb-1">
                                            <label class="text-white text-sm font-semibold">ìˆ˜ì • ë‚´ìš©:</label>
                                            <div class="flex flex-wrap gap-2">
                                                <button @click="setInpaintPreset('remove')"
                                                        class="text-xs font-semibold py-1 px-2 rounded-full border transition-colors bg-slate-600 border-slate-500 text-slate-200 hover:bg-slate-500">
                                                    í…ìŠ¤íŠ¸ ì œê±°
                                                </button>
                                                <button @click="setInpaintPreset('fix')"
                                                        class="text-xs font-semibold py-1 px-2 rounded-full border transition-colors bg-slate-600 border-slate-500 text-slate-200 hover:bg-slate-500">
                                                    ì‹ ì²´ ì˜¤ë¥˜ ìˆ˜ì •
                                                </button>
                                            </div>
                                        </div>
                                        <input type="text" placeholder="ì˜ˆ: a cute silver tabby cat" x-model="inpaintPrompt" @keydown.enter.prevent.stop="executeAction()" class="w-full bg-slate-700 text-white p-2 rounded-md border border-slate-600 focus:outline-none focus:ring-2 focus:ring-sky-500">
                                    </div>
                                </div>
                            </template>
                            <!-- Outpaint Controls -->
                            <template x-if="mode === 'outpaint'">
                                 <div class="space-y-4">
                                    <div class="bg-slate-700 text-white p-3 rounded-md text-center space-y-2">
                                        <label class="block text-sm font-semibold text-slate-300">ì˜ˆìƒ í•´ìƒë„ (1MP í™˜ì‚°)</label>
                                        <span class="font-mono text-lg" x-text="scaledResolution">1024x1024</span>
                                    </div>
                                    <div class="bg-slate-700 text-white p-3 rounded-md text-center space-y-2">
                                        <label class="block text-sm font-semibold text-slate-300">ë‚¨ì€ í™•ìž¥ ìš©ëŸ‰: <span x-text="expansionBudgetPercent.toFixed(0) + '%'"></span></label>
                                        <div class="w-full bg-slate-600 rounded-full h-2">
                                            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300" :style="`width: ${expansionBudgetPercent}%`"></div>
                                        </div>
                                        <div class="h-4">
                                            <p x-show="cornerBudgetConsumption > 0.1" x-transition class="text-xs text-amber-400" x-text="`ëª¨ì„œë¦¬ í™•ìž¥ìœ¼ë¡œ ${cornerBudgetConsumption.toFixed(0)}% ì¶”ê°€ ì†Œëª¨`" x-cloak></p>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="text-sm font-semibold text-white mb-2 block">ë¹„ìœ¨ í”„ë¦¬ì…‹</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <template x-for="option in $store.app.aspectRatioOptions.filter(o => o.ratio !== '1:1')" :key="option.ratio">
                                                <button @click="toggleAspectRatioPreset(option.ratio)"
                                                        class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors flex items-center justify-center gap-1"
                                                        :class="activeAspectRatioPreset === option.ratio ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                    <span x-text="option.desc"></span>
                                                </button>
                                            </template>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-x-4 gap-y-3 pt-2 border-t border-slate-700">
                                        <div>
                                            <label class="text-sm font-semibold text-white">ìœ„: <span x-text="padding.top.toFixed(0) + '%'"></span></label>
                                            <input type="range" x-model.number="padding.top" min="0" max="100" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer" @input="updateExpansionState('top')">
                                        </div>
                                        <div>
                                            <label class="text-sm font-semibold text-white">ì˜¤ë¥¸ìª½: <span x-text="padding.right.toFixed(0) + '%'"></span></label>
                                            <input type="range" x-model.number="padding.right" min="0" max="100" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer" @input="updateExpansionState('right')">
                                        </div>
                                        <div>
                                            <label class="text-sm font-semibold text-white">ì•„ëž˜: <span x-text="padding.bottom.toFixed(0) + '%'"></span></label>
                                            <input type="range" x-model.number="padding.bottom" min="0" max="100" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer" @input="updateExpansionState('bottom')">
                                        </div>
                                        <div>
                                            <label class="text-sm font-semibold text-white">ì™¼ìª½: <span x-text="padding.left.toFixed(0) + '%'"></span></label>
                                            <input type="range" x-model.number="padding.left" min="0" max="100" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer" @input="updateExpansionState('left')">
                                        </div>
                                    </div>
                                </div>
                            </template>
                            <!-- Infuse Controls -->
                            <template x-if="mode === 'infuse'">
                                <div class="space-y-4">
                                    <div class="pt-2">
                                        <label class="text-sm font-semibold text-white mb-2 block text-center">ì›ë³¸ ì´ë¯¸ì§€</label>
                                        <div class="flex justify-center">
                                            <img :src="baseImage" class="w-28 h-28 object-contain rounded-md border-2 border-slate-600 bg-slate-900" alt="Original Image"
                                                x-show="baseImage">
                                            <div class="w-28 h-28 rounded-md border-2 border-slate-600 bg-slate-900 flex items-center justify-center text-slate-500 text-xs"
                                                x-show="!baseImage">
                                                <span>ì´ë¯¸ì§€ ì—†ìŒ</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="flex gap-2 justify-center pt-4 border-t border-slate-700">
                                        <template x-for="output in outputs" :key="output.id">
                                            <div class="p-2 border-2 rounded-lg cursor-pointer transition-colors flex flex-col min-w-[50px] min-h-[6rem]"
                                                :class="output.active ? 'border-sky-500 bg-sky-100' : 'border-slate-300 bg-white'"
                                                @click="outputs.forEach(o => o.active = false); output.active = true">
                                                <div class="flex items-center justify-between text-slate-600">
                                                    <span class="font-bold text-xl" x-text="output.id"></span>
                                                    <span class="material-symbols-outlined text-sm" x-show="output.attributes.length > 0" x-cloak>check_circle</span>
                                                </div>
                                                <div class="flex-grow flex flex-wrap items-center justify-center gap-2 mt-2">
                                                    <template x-for="attrId in sortAttributes(output.attributes)" :key="attrId">
                                                        <span class="text-slate-500 text-lg" :title="$store.app.getKeywordById(attrId)?.desc" x-text="getInfuseDisplay(attrId)"></span>
                                                    </template>
                                                </div>
                                            </div>
                                        </template>
                                    </div>
                                    <div class="space-y-2">
                                        <label class="text-sm font-semibold text-white">ì¶œë ¥ ì´ë¯¸ì§€: <span x-text="outputCount"></span></label>
                                        <input type="range" min="1" max="4" step="1" x-model.number="outputCount" @input="updateOutputs" class="w-full">
                                    </div>

                                    <div class="pt-2 border-t border-slate-700">
                                        <div class="flex border-b border-slate-600 -mx-4 px-2">
                                            <template x-for="(category, catKey) in $store.app.infuseMasterTable" :key="catKey">
                                                <button @click="infuseActiveTab = catKey" 
                                                        class="flex-1 text-sm font-semibold py-2 px-1 text-center border-b-2 transition-colors"
                                                        :class="{
                                                            'text-sky-400 border-sky-400': infuseActiveTab === catKey,
                                                            'text-slate-400 border-transparent hover:text-white': infuseActiveTab !== catKey
                                                        }">
                                                    <span x-text="category.title"></span>
                                                </button>
                                            </template>
                                        </div>
                                        <div class="relative overflow-y-auto pt-3">
                                            <template x-for="(category, catKey) in $store.app.infuseMasterTable" :key="catKey">
                                                <div x-show="infuseActiveTab === catKey" class="flex flex-wrap gap-2">
                                                    <template x-for="recipe in category.recipes" :key="recipe.keywordId">
                                                        <button 
                                                            x-data="{ keyword: $store.app.getKeywordById(recipe.keywordId) }"
                                                            @click="addRemoveAttribute(recipe.keywordId)"
                                                            class="text-xs font-semibold py-1 px-3 rounded-full border transition-colors"
                                                            :class="{
                                                                'bg-sky-500 border-sky-500 text-white': outputs.find(o => o.active)?.attributes.includes(recipe.keywordId),
                                                                'bg-slate-600 border-slate-500 text-slate-200 hover:bg-slate-500': !outputs.find(o => o.active)?.attributes.includes(recipe.keywordId)
                                                            }">
                                                            <span x-text="keyword ? keyword.desc : '...'"></span>
                                                        </button>
                                                    </template>
                                                </div>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                            </template>
                            <!-- Analyze Controls -->
                            <template x-if="mode === 'analyze'">
                                <div class="space-y-4 text-white">
                                    <div class="p-3 bg-slate-700 rounded-lg text-xs text-slate-300 space-y-1">
                                        <p class="font-bold text-white truncate" x-text="$store.app.ui.currentImageInfo.name || '...'" title="íŒŒì¼ëª…"></p>
                                        <p x-text="`í•´ìƒë„: ${$store.app.ui.currentImageInfo.resolution || '...'}`"></p>
                                        <p x-text="`í¬ê¸°: ${$store.app.ui.currentImageInfo.size || '...'}`"></p>
                                    </div>
                                    <div class="p-3 bg-slate-700 rounded-lg space-y-3">
                                        <div>
                                            <label class="text-sm font-semibold text-white">í™•ëŒ€: <span x-text="`${(analyzeState.zoom * 100).toFixed(0)}%`"></span></label>
                                            <input type="range" min="1" max="5" step="0.1" x-model.number="analyzeState.zoom" @input="setZoom($event.target.value)" class="w-full mt-1">
                                        </div>
                                        <div class="flex items-center justify-center gap-2">
                                           <button @click="panCanvas('left')" class="w-8 h-8 bg-slate-600 rounded-md flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed" :disabled="analyzeState.zoom <= 1"><span class="material-symbols-outlined">arrow_back</span></button>
                                           <button @click="panCanvas('up')" class="w-8 h-8 bg-slate-600 rounded-md flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed" :disabled="analyzeState.zoom <= 1"><span class="material-symbols-outlined">arrow_upward</span></button>
                                           <button @click="panCanvas('down')" class="w-8 h-8 bg-slate-600 rounded-md flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed" :disabled="analyzeState.zoom <= 1"><span class="material-symbols-outlined">arrow_downward</span></button>
                                           <button @click="panCanvas('right')" class="w-8 h-8 bg-slate-600 rounded-md flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed" :disabled="analyzeState.zoom <= 1"><span class="material-symbols-outlined">arrow_forward</span></button>
                                        </div>
                                    </div>
                                    <div class="flex border-b border-slate-600 -mx-4 px-2">
                                        <button @click="analyzeState.activeTab = 'extract'" 
                                                class="flex-1 text-sm font-semibold py-2 px-1 text-center border-b-2 transition-colors"
                                                :class="{
                                                    'text-sky-400 border-sky-400': analyzeState.activeTab === 'extract',
                                                    'text-slate-400 border-transparent hover:text-white': analyzeState.activeTab !== 'extract'
                                                }">
                                            <span>í”„ë¡¬í”„íŠ¸ ì¶”ì¶œ</span>
                                        </button>
                                        <button @click="analyzeState.activeTab = 'expression'" 
                                                class="flex-1 text-sm font-semibold py-2 px-1 text-center border-b-2 transition-colors"
                                                :class="{
                                                    'text-sky-400 border-sky-400': analyzeState.activeTab === 'expression',
                                                    'text-slate-400 border-transparent hover:text-white': analyzeState.activeTab !== 'expression'
                                                }">
                                            <span>í‘œì • ë¶„ì„</span>
                                        </button>
                                        <button @click="analyzeState.activeTab = 'costume'" 
                                                class="flex-1 text-sm font-semibold py-2 px-1 text-center border-b-2 transition-colors"
                                                :class="{
                                                    'text-sky-400 border-sky-400': analyzeState.activeTab === 'costume',
                                                    'text-slate-400 border-transparent hover:text-white': analyzeState.activeTab !== 'costume'
                                                }">
                                            <span>ì‹œíŠ¸ ì¶”ì¶œ</span>
                                        </button>
                                    </div>

                                    <div class="relative min-h-[300px]">
                                        <!-- Extract Tab -->
                                        <div x-show="analyzeState.activeTab === 'extract'">
                                            <div x-show="analyzeState.isLoading" class="flex justify-center items-center py-10" x-cloak>
                                                <div class="w-8 h-8 border-4 border-dashed rounded-full animate-spin border-sky-400"></div>
                                            </div>
                                            <div x-show="!analyzeState.isLoading" class="space-y-4">
                                                <div>
                                                    <label class="font-semibold text-sm">ì¶”ì¶œëœ í”„ë¡¬í”„íŠ¸</label>
                                                    <div class="relative group mt-1">
                                                        <textarea readonly :value="analyzeState.promptResult" class="w-full h-28 p-2 bg-slate-700 rounded-md text-sm resize-none" placeholder="ì´ê³³ì— AIê°€ ë¶„ì„í•œ í”„ë¡¬í”„íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤..."></textarea>
                                                        <div x-show="analyzeState.promptResult" class="absolute top-2 right-2 flex flex-col gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity" x-cloak>
                                                            <button @click="$store.app.copyToClipboard(analyzeState.promptResult)" title="í”„ë¡¬í”„íŠ¸ ë³µì‚¬" class="p-1 bg-slate-600 rounded-md hover:bg-slate-500"><span class="material-symbols-outlined text-xs">content_copy</span></button>
                                                            <button @click="$store.app.savePromptAsPreset(analyzeState.promptResult)" title="í”„ë¦¬ì…‹ìœ¼ë¡œ ì €ìž¥" class="p-1 bg-slate-600 rounded-md hover:bg-slate-500"><span class="material-symbols-outlined text-xs">save</span></button>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label class="font-semibold text-sm">ì¶”ì²œ í‚¤ì›Œë“œ</label>
                                                    <div class="relative group mt-1">
                                                        <div class="p-2 bg-slate-700 rounded-md flex flex-wrap gap-2 min-h-[36px]">
                                                            <template x-for="keyword in analyzeState.keywordResult" :key="keyword">
                                                                <span class="bg-slate-600 text-slate-200 text-xs font-semibold px-2 py-1 rounded-full" x-text="keyword"></span>
                                                            </template>
                                                        </div>
                                                        <div x-show="analyzeState.keywordResult.length > 0" class="absolute top-2 right-2 flex flex-col gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity" x-cloak>
                                                            <button @click="$store.app.copyToClipboard(analyzeState.keywordResult.map(k => '#' + k).join(' '))" title="íƒœê·¸ ë³µì‚¬ (#)" class="p-1 bg-slate-600 rounded-md hover:bg-slate-500">
                                                                <span class="material-symbols-outlined text-xs">tag</span>
                                                            </button>
                                                            <button @click="saveKeywordsToLibrary()" title="ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì €ìž¥" class="p-1 bg-slate-600 rounded-md hover:bg-slate-500">
                                                                <span class="material-symbols-outlined text-xs">library_add</span>
                                                            </button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Expression Tab -->
                                        <div x-show="analyzeState.activeTab === 'expression'">
                                             <div x-show="analyzeState.isLoading" class="flex justify-center items-center py-10" x-cloak>
                                                <div class="w-8 h-8 border-4 border-dashed rounded-full animate-spin border-sky-400"></div>
                                            </div>
                                            <div x-show="!analyzeState.isLoading" class="space-y-4">
                                                <div>
                                                    <label class="font-semibold text-sm">í‘œì • ë¶„ì„ ê²°ê³¼</label>
                                                    <div class="mt-1 space-y-2 p-3 bg-slate-700 rounded-md">
                                                        <template x-for="emotion in emotionDisplayOrder" :key="emotion.key">
                                                            <div class="flex items-center gap-2">
                                                                <span class="w-16 text-right text-xs uppercase text-slate-300" x-text="emotion.label"></span>
                                                                <div class="flex-1 bg-slate-600 rounded-full h-3">
                                                                    <div class="h-3 rounded-full" :class="emotion.color" :style="`width: ${((analyzeState.expressionResult && analyzeState.expressionResult[emotion.key]) || 0) * 100}%`"></div>
                                                                </div>
                                                                <span class="w-8 text-left text-xs text-slate-300" x-text="`${(((analyzeState.expressionResult && analyzeState.expressionResult[emotion.key]) || 0) * 100).toFixed(0)}%`"></span>
                                                            </div>
                                                        </template>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label class="font-semibold text-sm">í•´ì„</label>
                                                    <p class="mt-1 text-sm text-slate-300 p-3 bg-slate-700 rounded-md min-h-[60px]" x-text="analyzeState.commentResult || 'ì´ê³³ì— AIê°€ ë¶„ì„í•œ ì´ë¯¸ì§€ í•´ì„ì´ í‘œì‹œë©ë‹ˆë‹¤...'"></p>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Costume Tab -->
                                        <div x-show="analyzeState.activeTab === 'costume'" class="space-y-3">
                                             <div class="inline-flex rounded-md shadow-sm w-full" role="group">
                                                <button type="button" @click="analyzeState.costumeSheetType = 'costume'" class="w-1/2 px-4 py-2 text-sm font-medium rounded-l-lg border focus:z-10 focus:ring-2" :class="{'bg-sky-500 text-white border-sky-500': analyzeState.costumeSheetType === 'costume', 'bg-slate-600 text-gray-200 border-gray-500': analyzeState.costumeSheetType !== 'costume' }">ì˜ìƒ ì‹œíŠ¸</button>
                                                <button type="button" @click="analyzeState.costumeSheetType = 'character'" class="w-1/2 px-4 py-2 text-sm font-medium rounded-r-lg border focus:z-10 focus:ring-2" :class="{'bg-sky-500 text-white border-sky-500': analyzeState.costumeSheetType === 'character', 'bg-slate-600 text-gray-200 border-gray-500': analyzeState.costumeSheetType !== 'character' }">ìºë¦­í„° ì‹œíŠ¸</button>
                                             </div>
                                             <div class="mt-2">
                                                <div class="w-full aspect-square bg-slate-900/50 rounded-md flex items-center justify-center relative">
                                                    <div x-show="analyzeState.isLoading" class="w-8 h-8 border-4 border-dashed rounded-full animate-spin border-sky-400" x-cloak></div>
                                                    <p x-show="!analyzeState.isLoading && !analyzeState.costumeResult" class="text-slate-500 text-sm">ìƒì„±ëœ ì‹œíŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
                                                    <img :src="analyzeState.costumeResult" x-show="!analyzeState.isLoading && analyzeState.costumeResult" class="w-full h-full object-contain rounded-md" x-cloak>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <div class="mt-auto pt-4 border-t border-slate-700">
                    <div class="flex flex-col gap-2">
                        <div class="flex gap-2">
                            <button class="flex-1 bg-slate-600 text-white font-bold py-2 px-3 rounded-lg hover:bg-slate-500 transition-colors flex items-center justify-center" title="ì´ˆê¸°í™”" @click="reset()">
                                 <span>ì´ˆê¸°í™”</span>
                            </button>
                            <button class="flex-1 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center justify-center gap-1 disabled:opacity-50"
                                    :class="{
                                        'bg-green-500 hover:bg-green-600': (mode === 'draw' && !activeAISupport) || (mode === 'refine' && !refineState.activeAICorrection),
                                        'bg-[#4285F4] hover:bg-[#3367D6]': !((mode === 'draw' && !activeAISupport) || (mode === 'refine' && !refineState.activeAICorrection))
                                    }"
                                    title="ì‹¤í–‰" 
                                    @click="executeAction()"
                                    :disabled="isLoading">
                                <span class="material-symbols-outlined spinner text-base" x-show="isLoading" x-cloak>progress_activity</span>
                                
                                <template x-if="!isLoading">
                                    <span class="material-symbols-outlined text-base" 
                                          x-text="(mode === 'draw' && !activeAISupport) || (mode === 'refine' && !refineState.activeAICorrection) ? 'play_arrow' : 'auto_awesome'">
                                    </span>
                                </template>
                                
                                <span x-show="!isLoading">ì‹¤í–‰</span>
                            </button>
                        </div>
                        <div class="">
                            <button class="w-full bg-slate-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors" @click="$store.app.closeModal()">
                                ë‹«ê¸°
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="settings-modal" x-show="$store.app.ui.activeModal === 'settings-modal'" x-transition class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal-backdrop" @click.self="$store.app.closeModal()" x-cloak>
        <div class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg w-full max-w-xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6 border-b pb-3 border-slate-200">
                <h3 class="text-2xl font-bold">âš™ï¸ ì„¤ì •</h3>
                <button class="text-slate-500 hover:text-slate-800" @click="$store.app.closeModal()"><span class="material-symbols-outlined">close</span></button>
            </div>
            <div class="space-y-6">
                <div>
                     <div class="flex items-center mb-2">
                        <label class="font-bold text-slate-700">Gemini API í‚¤</label>
                    </div>
                    <input type="password" id="api-key-input" class="w-full p-2 border rounded-md border-slate-300 bg-white" placeholder="API í‚¤ë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”" x-model="$store.app.settings.apiKey">
                    <!-- ìš”êµ¬ì‚¬í•­ 1: ì•ˆë‚´ ë©”ì‹œì§€ ìˆ˜ì • -->
                    <p class="text-xs text-slate-500 mt-1">API í‚¤ëŠ” ë¸Œë¼ìš°ì €ì—ë§Œ ì €ìž¥ë˜ë©° ì™¸ë¶€ë¡œ ì „ì†¡ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p>
                </div>
                 <div class="flex items-center justify-between">
                    <div>
                        <label class="font-bold text-slate-700">AI í‚¤ì›Œë“œ ìƒì„± ì§€ì›</label>
                        <p class="text-sm text-slate-600">í‚¤ì›Œë“œ ì¶”ê°€ ì‹œ, ìžë™ìœ¼ë¡œ ì˜ë¬¸ ë²ˆì—­ ë° ì„¤ëª…ì„ ìƒì„±í•©ë‹ˆë‹¤.</p>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="ai-support-toggle" x-model="$store.app.settings.aiKeywordSupport">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="flex items-center justify-between pt-6">
                    <div>
                        <label class="font-bold text-slate-700">ì´ˆê¸°í™”</label>
                        <p class="text-sm text-slate-600">ëª¨ë“  ì‚¬ìš©ìž ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  í”„ë¡œê·¸ëž¨ì„ ì²˜ìŒ ìƒíƒœë¡œ ë˜ëŒë¦½ë‹ˆë‹¤.</p>
                    </div>
                    <button class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition-opacity" @click="$store.app.openModal('confirm-modal')">ì´ˆê¸°í™”</button>
                </div>
            </div>
            <div class="mt-8 pt-4 border-t flex justify-end gap-3 border-slate-200">
                 <button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600" @click="$store.app.saveState(); $store.app.closeModal()">ì €ìž¥í•˜ê³  ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <!-- ================================================================= -->
    <!-- UNIFIED SIMPLE MODAL CONTAINER                                    -->
    <!-- ================================================================= -->
    <div id="unified-simple-modal" 
         x-show="['confirm-modal', 'delete-tab-confirm-modal', 'manual-prompt-modal'].includes($store.app.ui.activeModal)"
         x-transition class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal-backdrop" 
         @click.self="$store.app.closeModal()" x-cloak>
        
        <div class="bg-white p-6 rounded-2xl shadow-lg w-full max-h-[90vh] overflow-y-auto"
             :class="{
                 'max-w-sm': ['confirm-modal', 'delete-tab-confirm-modal'].includes($store.app.ui.activeModal),
                 'max-w-2xl': $store.app.ui.activeModal === 'manual-prompt-modal'
             }">
    
            <!-- Template for: confirm-modal (Factory Reset) -->
            <template x-if="$store.app.ui.activeModal === 'confirm-modal'">
                <div>
                    <h3 class="text-xl font-bold mb-4 text-red-600">âš ï¸ ì´ˆê¸°í™”ë¥¼ ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</h3>
                    <p class="text-slate-600 mb-6">ëª¨ë“  ì‚¬ìš©ìž ë°ì´í„°(í‚¤ì›Œë“œ, ê·¸ë£¹, í”„ë¦¬ì…‹, ížˆìŠ¤í† ë¦¬, ì„¤ì • ë“±)ê°€ ì˜êµ¬ì ìœ¼ë¡œ ì‚­ì œë©ë‹ˆë‹¤. <span class="font-bold">ì´ ìž‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span></p>
                    <div class="flex justify-end gap-3">
                        <button class="bg-gray-200 text-slate-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300" @click="$store.app.closeModal()">ì·¨ì†Œ</button>
                        <button class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600" @click="$store.app.factoryReset()">í™•ì¸</button>
                    </div>
                </div>
            </template>
            
            <!-- Template for: delete-tab-confirm-modal -->
            <template x-if="$store.app.ui.activeModal === 'delete-tab-confirm-modal'">
                <div>
                    <h3 class="text-xl font-bold mb-4 text-red-600">íƒ­ ì‚­ì œ í™•ì¸</h3>
                    <p class="text-slate-600 mb-6" x-text="$store.app.ui.modalData.confirmMessage"></p>
                    <div class="flex justify-end gap-3">
                        <button class="bg-gray-200 text-slate-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300" @click="$store.app.closeModal()">ì·¨ì†Œ</button>
                        <button class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600" @click="$store.app.confirmDeleteTab()">ì‚­ì œ</button>
                    </div>
                </div>
            </template>
            
            <!-- Template for: manual-prompt-modal -->
            <template x-if="$store.app.ui.activeModal === 'manual-prompt-modal'">
                 <div>
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-2xl font-bold">ìˆ˜ë™ í”„ë¡¬í”„íŠ¸ íŽ¸ì§‘</h3>
                        <div class="flex items-center gap-2">
                             <button class="text-indigo-600 hover:text-indigo-800 disabled:opacity-50" title="AI ì–‘ë°©í–¥ ë²ˆì—­" @click="$store.app.translateManualPrompt()" :disabled="$store.app.ui.isLoadingTranslation">
                                <span class="material-symbols-outlined spinner text-base" x-show="$store.app.ui.isLoadingTranslation" x-cloak>progress_activity</span>
                                <span class="material-symbols-outlined" x-show="!$store.app.ui.isLoadingTranslation">translate</span>
                            </button>
                             <div class="inline-flex rounded-lg shadow-sm" role="group">
                                <button type="button" class="px-3 py-1 text-sm font-medium transition-colors" @click="$store.app.ui.manualPromptPosition = 'prepend'" :class="{'bg-blue-600 text-white': $store.app.ui.manualPromptPosition === 'prepend', 'bg-white text-gray-900': $store.app.ui.manualPromptPosition !== 'prepend' }">ë§¨ ì•ž</button>
                                <button type="button" class="px-3 py-1 text-sm font-medium transition-colors" @click="$store.app.ui.manualPromptPosition = 'append'" :class="{'bg-blue-600 text-white': $store.app.ui.manualPromptPosition === 'append', 'bg-white text-gray-900': $store.app.ui.manualPromptPosition !== 'append' }">ë§¨ ë’¤</button>
                             </div>
                        </div>
                    </div>
                    <!-- ìš”êµ¬ì‚¬í•­ 6: Ctrl+Enter ë‹¨ì¶•í‚¤ ì¶”ê°€ -->
                    <textarea id="manual-prompt-textarea" class="w-full p-2 border rounded-md border-slate-300 bg-white" rows="6" placeholder="ì¶”ê°€í•˜ê³  ì‹¶ì€ í”„ë¡¬í”„íŠ¸ë¥¼ ì§ì ‘ ìž…ë ¥í•˜ì„¸ìš”..." x-model="$store.app.promptBoard.manualPrompt" @keydown.ctrl.enter.prevent="$store.app.closeModal()"></textarea>
                    <div class="mt-6 flex justify-end gap-3">
                        <button class="bg-gray-200 text-slate-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300" @click="$store.app.closeModal()">ì·¨ì†Œ</button>
                        <button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600" @click="$store.app.closeModal()">ì™„ë£Œ</button>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <!-- REFACTORED PRESET/HISTORY MODALS -->
    <template x-ref="listItemComponent">
        <div class="bg-slate-50 p-4 rounded-lg border border-slate-200 flex flex-col gap-2">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <!-- Title for Preset -->
                    <template x-if="type === 'preset'">
                        <div class="flex items-center gap-2">
                            <template x-if="$store.app.ui.editingPresetId !== item.id">
                                <span class="text-lg font-bold" x-text="item.name"></span>
                            </template>
                            <input type="text" x-show="$store.app.ui.editingPresetId === item.id" :value="item.name"
                                   class="text-lg font-bold bg-white border border-blue-500 rounded px-1"
                                   @keydown.enter="$store.app.updatePresetName(item.id, $event.target.value)"
                                   @blur="$store.app.updatePresetName(item.id, $event.target.value)"
                                   :x-ref="`preset-input-${item.id}`"
                                   x-cloak>
                        </div>
                    </template>
                    <!-- Title for History -->
                    <template x-if="type === 'history'">
                        <span class="text-sm font-bold text-slate-500" x-text="new Date(item.id).toLocaleString()"></span>
                    </template>
                    
                    <span class="text-sm text-slate-500">- <span x-text="item.promptLength + 'ìž'"></span></span>

                    <!-- Metadata Icons -->
                     <div class="flex items-center gap-2">
                        <template x-if="type === 'history'">
                            <div class="flex items-center gap-2">
                                <span x-show="item.modelUsed === 'gemini'" title="Gemini 2.5 Flash Image">ðŸŒ</span>
                                <span x-show="item.modelUsed === 'imagen'" title="Imagen 3">ðŸ”®</span>
                                <span x-show="item.status === 'success'" class="material-symbols-outlined text-green-500" title="ì„±ê³µ">check_circle</span>
                                <div x-show="item.status === 'failure'" class="flex items-center gap-1 text-red-500" title="ì‹¤íŒ¨">
                                    <span class="material-symbols-outlined">warning</span>
                                    <span class="text-xs font-bold" x-text="{ technical: 'ê¸°ìˆ ì  ì˜¤ë¥˜', recitation: 'ì €ìž‘ê¶Œ', other: 'ê¸°íƒ€', sexually_explicit: 'ì„±ì  ì½˜í…ì¸ ', hate_speech: 'í˜ì˜¤ ë°œì–¸', harassment: 'ê´´ë¡­íž˜', dangerous_content: 'í­ë ¥/ìœ„í—˜' }[item.reason] || ''"></span>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                     <!-- ìš”êµ¬ì‚¬í•­ 2: í”„ë¦¬ì…‹ ì´ë¦„ íŽ¸ì§‘ ë°©ì‹ ë³€ê²½ -->
                     <button x-show="type === 'preset'" class="text-slate-500 hover:text-slate-600" title="ì´ë¦„ ìˆ˜ì •" @click="$store.app.ui.editingPresetId = item.id; $nextTick(() => $refs[`preset-input-${item.id}`]?.focus())"><span class="material-symbols-outlined">edit</span></button>
                     <button x-show="type === 'history'" class="text-green-500 hover:text-green-600" title="í”„ë¦¬ì…‹ìœ¼ë¡œ ì €ìž¥" @click="$store.app.savePresetFromHistory(item.id)"><span class="material-symbols-outlined">save</span></button>
                     <button class="text-blue-500 hover:text-blue-600" title="ë¶ˆëŸ¬ì˜¤ê¸°" @click="type === 'preset' ? $store.app.loadPreset(item.id) : $store.app.restoreHistory(item.id)"><span class="material-symbols-outlined">undo</span></button>
                     <button class="text-red-500 hover:text-red-600" title="ì‚­ì œ" @click="type === 'preset' ? $store.app.deletePreset(item.id) : $store.app.deleteHistory(item.id)"><span class="material-symbols-outlined">delete</span></button>
                </div>
            </div>
            <div class="text-sm bg-slate-100 p-3 rounded-md text-slate-700">
                <span x-text="item.promptText"></span>
            </div>
        </div>
    </template>

    <div id="load-preset-modal" x-show="$store.app.ui.activeModal === 'load-preset-modal'" x-transition class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal-backdrop" @click.self="$store.app.closeModal()" x-cloak>
        <div class="bg-white p-6 rounded-2xl shadow-lg w-full max-w-3xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-2xl font-bold">ðŸ“‚ í”„ë¦¬ì…‹ ê´€ë¦¬</h3>
                <div class="flex items-center gap-2">
                    <button class="text-blue-500 hover:text-blue-600 transition-colors" title="í˜„ìž¬ í”„ë¡¬í”„íŠ¸ ì €ìž¥" @click="$store.app.saveCurrentPromptBoardAsPreset()">
                        <span class="material-symbols-outlined">save</span>
                    </button>
                    <button class="text-slate-500 hover:text-slate-800" @click="$store.app.closeModal()"><span class="material-symbols-outlined">close</span></button>
                </div>
            </div>
            <div class="relative mb-4 flex-shrink-0">
                <span class="material-symbols-outlined absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">search</span>
                <input type="text" placeholder="í”„ë¦¬ì…‹ ê²€ìƒ‰..." class="w-full p-2 pl-10 border rounded-md border-slate-300 bg-white" x-model="$store.app.ui.presetSearchTerm">
            </div>
            <div class="overflow-y-auto flex-grow">
                <template x-if="$store.app.filteredPresets.length === 0">
                    <div class="text-center text-slate-500 p-8">ì €ìž¥ëœ í”„ë¦¬ì…‹ì´ ì—†ìŠµë‹ˆë‹¤.</div>
                </template>
                <div class="space-y-4">
                    <template x-for="item in $store.app.filteredPresets" :key="item.id">
                        <div x-data="{ item: item, type: 'preset' }" x-html="$refs.listItemComponent.innerHTML"></div>
                    </template>
                </div>
            </div>
        </div>
    </div>
    
    <div id="history-modal" x-show="$store.app.ui.activeModal === 'history-modal'" x-transition class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal-backdrop" @click.self="$store.app.closeModal()" x-cloak>
        <div class="bg-white p-6 rounded-2xl shadow-lg w-full max-w-3xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-2xl font-bold">ðŸ“œ í”„ë¡¬í”„íŠ¸ ížˆìŠ¤í† ë¦¬</h3>
                <button class="text-slate-500 hover:text-slate-800" @click="$store.app.closeModal()"><span class="material-symbols-outlined">close</span></button>
            </div>
             <div class="relative mb-4 flex-shrink-0">
                <span class="material-symbols-outlined absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">search</span>
                <input type="text" placeholder="ížˆìŠ¤í† ë¦¬ ê²€ìƒ‰..." class="w-full p-2 pl-10 border rounded-md border-slate-300 bg-white" x-model="$store.app.ui.historySearchTerm">
            </div>
            <div class="overflow-y-auto flex-grow">
                <template x-if="$store.app.filteredHistory.length === 0">
                    <div class="text-center text-slate-500 p-8">ìƒì„± ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>
                </template>
                <div class="space-y-4">
                    <template x-for="item in $store.app.filteredHistory" :key="item.id">
                        <div x-data="{ item: item, type: 'history' }" x-html="$refs.listItemComponent.innerHTML"></div>
                    </template>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast-message" class="toast" x-show="$store.app.ui.toast.show" x-text="$store.app.ui.toast.message" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0 translate-y-full" x-transition:enter-end="opacity-100 translate-y-0" x-transition:leave="transition ease-in duration-300" x-transition:leave-start="opacity-100 translate-y-0" x-transition:leave-end="opacity-0 translate-y-full"></div>

    <!-- Keyword Move Menu -->
    <div x-show="$store.app.ui.moveMenu.visible"
        @click.outside="$store.app.closeKeywordLibraryMoveMenu()"
        x-transition
        :style="`position: absolute; top: ${$store.app.ui.moveMenu.top}px; left: ${$store.app.ui.moveMenu.left}px; z-index: 50;`"
        class="bg-white rounded-lg shadow-2xl border border-slate-200 w-64 max-h-80 overflow-y-auto p-2"
        x-cloak>
        <p class="text-lg font-bold px-2 py-1 text-slate-800">ì´ë™í•  ìœ„ì¹˜ ì„ íƒ</p>
        <template x-for="group in $store.app.keywordLibrary.userGroups" :key="group.id">
            <div class="my-1">
                <p class="text-base font-bold text-slate-800 px-2 py-1" x-text="group.name"></p>
                <template x-for="tab in group.tabs" :key="group.id + '-' + tab.name">
                    <button 
                        @click="$store.app.moveKeyword(group.id, tab.name)"
                        :disabled="$store.app.ui.moveMenu.fromGroupId === group.id && $store.app.ui.moveMenu.fromTabName === tab.name"
                        class="w-full text-left text-sm px-3 py-1.5 rounded hover:bg-blue-50 disabled:bg-slate-200 disabled:cursor-not-allowed">
                        <span x-text="tab.name"></span>
                    </button>
                </template>
            </div>
        </template>
    </div>

    <!-- Keyword Add Menu -->
    <div x-show="$store.app.ui.addMenu.visible"
        @click.outside="$store.app.closeAddMenu()"
        x-transition
        :style="`position: absolute; top: ${$store.app.ui.addMenu.top}px; left: ${$store.app.ui.addMenu.left}px; z-index: 50;`"
        class="bg-white rounded-lg shadow-2xl border border-slate-200 w-64 max-h-80 overflow-y-auto p-2"
        x-cloak>
        <p class="text-lg font-bold px-2 py-1 text-slate-800">ì¶”ê°€í•  ì˜ì—­ ì„ íƒ</p>
        <template x-for="area in $store.app.promptBoardAreaInfo" :key="area.key">
            <button 
                @click="$store.app.addKeywordToPromptBoard($store.app.ui.addMenu.keyword, area.key); $store.app.closeAddMenu()"
                class="w-full text-left text-base px-2 py-1.5 rounded hover:bg-blue-50">
                <span x-text="area.title"></span>
            </button>
        </template>
    </div>

</body>
</html>
