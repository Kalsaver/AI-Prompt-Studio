<!DOCTYPE html>
<html lang="ko" x-data>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sevit Studio</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {}
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script>
        document.addEventListener('alpine:init', () => {
            const CONSTANTS = {
                LOCAL_STORAGE_KEY: 'promptStudioData_v6.0_renewal', // Version up
                PROMPT_CHAR_LIMIT: 500,
                IMAGE_SIZE_LIMIT_MB: 20,
                GEMINI_SAFETY_SETTINGS: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ],
                // --- Refined & New AI Prompts for Modal ---
                'line-cleanup': 'Analyze the attached rough sketch image and refine it into clean, well-defined line art. Preserve the original composition and character poses.',
                'sketch-complete': 'Based on the attached sketch image, complete a creative and detailed final image.',
                colorize: 'Do not damage the original lines of the attached image, and color it naturally.',
                'background-removal': 'Identify the main subject in the image and completely remove the background, leaving the subject on a transparent canvas.',
                'quality-enhance': 'Perform a comprehensive quality enhancement on the provided image. Upscale the resolution, sharpen the details, and remove any digital noise or grain. The core subject, composition, and style of the original image must be strictly preserved.',
                'id-photo': "You are provided with two images:\n- Image 1: A blank, pure white vertical canvas for the background.\n- Image 2: A portrait of a person.\n\nYour primary goal is to preserve the identity and all core facial features of the person in Image 2 while adjusting their portrait to meet the standards of a Korean ID photo on the white canvas of Image 1.\n\nModify the person from Image 2 with the following minimal adjustments:\n\n1. Pose & Composition: Adjust the pose to be strictly frontal. Center the subject on the canvas, ensuring proper headroom. Crucially, do not alter the subject's inherent facial structure.\n\n2. Expression: Subtly shift the facial expression to neutral with the mouth closed. Avoid any significant changes that would alter the person's likeness.\n\n3. Lighting & Tone: Balance the existing lighting to be even and frontal. Do not re-light from scratch. Your task is to soften or remove harsh shadows on the face and background while faithfully maintaining the original skin tone and facial details.\n\n4. Hair & Accessories: Ensure hair does not cover the eyes or eyebrows. Remove any non-essential items like hats, sunglasses, or headphones.\n\n5. Final Output: The result must clearly be the same person from Image 2, now presented as a high-quality, sharp, and clear studio-lit portrait."
            };
            
            Alpine.data('keywordGroup', (group) => ({
                group: group,
                isAddingTab: false,
                newTabName: '',
                getKeywordsForActiveTab() {
                    const activeTab = this.group.tabs.find(t => t.name === this.group.activeTab);
                    if (!activeTab) return [];
                    return activeTab.keywordIds.map(id => this.group.keywords.find(k => k.id === id)).filter(Boolean);
                },
                get filteredKeywords() {
                    let keywords = this.getKeywordsForActiveTab();
                    const searchTerm = Alpine.store('app').keywordLibrary.searchTerm;
                    if (searchTerm) {
                        const termLower = searchTerm.toLowerCase();
                        keywords = keywords.filter(item => 
                            item.keyword.toLowerCase().includes(termLower) ||
                            (item.desc && item.desc.toLowerCase().includes(termLower))
                        );
                    }
                    return keywords;
                },
                get filteredCount() {
                    return this.group.keywords ? this.group.keywords.length : 0;
                },
                get hasSearchResults() {
                    if (!Alpine.store('app').keywordLibrary.searchTerm) return true;
                    
                    const term = Alpine.store('app').keywordLibrary.searchTerm.toLowerCase();
                    const groupName = this.group.isDefault ? { subject: '주제', details: '세부 묘사', style: '표현 기법', composition: '구도' }[this.group.id] : this.group.name;
                    if (groupName && groupName.toLowerCase().includes(term)) return true;

                    return this.group.tabs.some(tab => {
                        if (tab.name.toLowerCase().includes(term)) return true;
                        return tab.keywordIds.some(id => {
                            const keyword = this.group.keywords.find(k => k.id === id);
                            return keyword && (
                                keyword.keyword.toLowerCase().includes(term) ||
                                (keyword.desc && keyword.desc.toLowerCase().includes(term))
                            );
                        });
                    });
                },
                confirmAddTab() {
                    const name = this.newTabName.trim();
                    if (!name) return;
                    
                    if (this.group && !this.group.tabs.some(t => t.name.toLowerCase() === name.toLowerCase())) {
                        this.group.tabs.push({ name: name, keywordIds: [] });
                        this.group.activeTab = name;
                        Alpine.store('app').saveState(false);
                    }
                    this.isAddingTab = false;
                    this.newTabName = '';
                }
            }));

            Alpine.data('promptBoardArea', (areaKey, title) => ({
                key: areaKey,
                title: title,
                get keywords() {
                    return Alpine.store('app').promptBoard[this.key] || [];
                }
            }));
            
            Alpine.store('app', {
                constants: CONSTANTS,
                keywordLibrary: { 
                    defaultGroups: [
                        { 
                            id: 'subject', 
                            keywords: [
                                { id: 1001, type: 'keyword', keyword: 'Man', desc: '남성' }, { id: 1002, type: 'keyword', keyword: 'Woman', desc: '여성' }, { id: 1003, type: 'keyword', keyword: 'Boy', desc: '소년' }, { id: 1004, type: 'keyword', keyword: 'Girl', desc: '소녀' }, { id: 1005, type: 'keyword', keyword: 'Old Man', desc: '노인 (남)' }, { id: 1006, type: 'keyword', keyword: 'Old Woman', desc: '노인 (여)' }, { id: 1007, type: 'keyword', keyword: 'Knight', desc: '기사' }, { id: 1008, type: 'keyword', keyword: 'Wizard', desc: '마법사' }, { id: 1009, type: 'keyword', keyword: 'Cyborg', desc: '사이보그' }, { id: 1010, type: 'keyword', keyword: 'Elf', desc: '엘프' },
                                { id: 1011, type: 'keyword', keyword: 'Cat', desc: '고양이' }, { id: 1012, type: 'keyword', keyword: 'Dog', desc: '개' }, { id: 1013, type: 'keyword', keyword: 'Wolf', desc: '늑대' }, { id: 1014, type: 'keyword', keyword: 'Fox', desc: '여우' }, { id: 1015, type: 'keyword', keyword: 'Bird', desc: '새' }, { id: 1016, type: 'keyword', keyword: 'Dragon', desc: '용' }, { id: 1017, type: 'keyword', keyword: 'Phoenix', desc: '불사조' }, { id: 1018, type: 'keyword', keyword: 'Unicorn', desc: '유니콘' },
                                { id: 1019, type: 'keyword', keyword: 'Cityscape', desc: '도시 풍경' }, { id: 1020, type: 'keyword', keyword: 'Forest', desc: '숲' }, { id: 1021, type: 'keyword', keyword: 'Ocean', desc: '대양' }, { id: 1022, type: 'keyword', keyword: 'Mountains', desc: '산맥' }, { id: 1023, type: 'keyword', keyword: 'Sky', desc: '하늘' }, { id: 1024, type: 'keyword', keyword: 'Outer Space', desc: '우주 공간' }, { id: 1025, type: 'keyword', keyword: 'Ruins', desc: '폐허' }, { id: 1026, type: 'keyword', keyword: 'Library', desc: '도서관' },
                                { id: 1027, type: 'keyword', keyword: 'Sword', desc: '검' }, { id: 1028, type: 'keyword', keyword: 'Book', desc: '책' }, { id: 1029, type: 'keyword', keyword: 'Spaceship', desc: '우주선' }, { id: 1030, type: 'keyword', keyword: 'Car', desc: '자동차' }, { id: 1031, type: 'keyword', keyword: 'Cap', desc: '모자' }, { id: 1032, type: 'keyword', keyword: 'Umbrella', desc: '우산' }, { id: 1033, type: 'keyword', keyword: 'Flower', desc: '꽃' }, { id: 1034, type: 'keyword', keyword: 'Camera', desc: '사진기' }, { id: 1035, type: 'keyword', keyword: 'Microphone', desc: '마이크' }, { id: 1036, type: 'keyword', keyword: 'Guitar', desc: '기타' }, { id: 1037, type: 'keyword', keyword: 'Mobile', desc: '스마트폰' }, { id: 1038, type: 'keyword', keyword: 'Newspaper', desc: '신문' }, { id: 1039, type: 'keyword', keyword: 'Bag', desc: '가방' }
                            ], 
                            collapsed: true, 
                            isDefault: true,
                            activeTab: '인물',
                            tabs: [
                                { name: '인물', keywordIds: [1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010] },
                                { name: '동물', keywordIds: [1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018] },
                                { name: '배경', keywordIds: [1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026] },
                                { name: '사물', keywordIds: [1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039] }
                            ]
                        },
                        { 
                            id: 'details', 
                            keywords: [
                                { id: 2001, type: 'keyword', keyword: 'Long Hair', desc: '긴 머리' }, { id: 2002, type: 'keyword', keyword: 'Short Hair', desc: '짧은 머리' }, { id: 2003, type: 'keyword', keyword: 'Blonde Hair', desc: '금발' }, { id: 2004, type: 'keyword', keyword: 'Red Eyes', desc: '붉은 눈' }, { id: 2005, type: 'keyword', keyword: 'Blue Eyes', desc: '파란 눈' }, { id: 2006, type: 'keyword', keyword: 'Glowing Eyes', desc: '빛나는 눈' }, { id: 2007, type: 'keyword', keyword: 'Muscular', desc: '근육질' }, { id: 2008, type: 'keyword', keyword: 'Detailed Face', desc: '상세한 얼굴' }, { id: 2009, type: 'keyword', keyword: 'Jewelry', desc: '보석' }, { id: 2010, type: 'keyword', keyword: 'Tattoo', desc: '문신' },
                                { id: 2011, type: 'keyword', keyword: 'Dress', desc: '드레스' }, { id: 2012, type: 'keyword', keyword: 'Suit', desc: '정장' }, { id: 2013, type: 'keyword', keyword: 'Armor', desc: '갑옷' }, { id: 2014, type: 'keyword', keyword: 'Hoodie', desc: '후드티' }, { id: 2015, type: 'keyword', keyword: 'School Uniform', desc: '교복' }, { id: 2016, type: 'keyword', keyword: 'Sunglasses', desc: '선글라스' }, { id: 2017, type: 'keyword', keyword: 'Hat', desc: '모자' }, { id: 2018, type: 'keyword', keyword: 'Boots', desc: '부츠' }, { id: 2019, type: 'keyword', keyword: 'Cape', desc: '망토' }, { id: 5001, type: 'keyword', keyword: 'Barefoot', desc: '맨발' }, { id: 5002, type: 'keyword', keyword: 'Jeans', desc: '청바지' }, { id: 5003, type: 'keyword', keyword: 'Crop Top', desc: '크롭탑' },
                                { id: 2033, type: 'keyword', keyword: 'Neutral', desc: '무표정' }, { id: 2020, type: 'keyword', keyword: 'Joy', desc: '기쁨' }, { id: 2021, type: 'keyword', keyword: 'Sadness', desc: '슬픔' }, { id: 2029, type: 'keyword', keyword: 'Anger', desc: '화남' }, { id: 2030, type: 'keyword', keyword: 'Fear', desc: '공포' }, { id: 2031, type: 'keyword', keyword: 'Surprise', desc: '놀람' }, { id: 2032, type: 'keyword', keyword: 'Disgust', desc: '혐오' }, { id: 2037, type: 'keyword', keyword: 'Wink', desc: '윙크' }, { id: 2041, type: 'keyword', keyword: 'Pout', desc: '삐짐' }, { id: 2042, type: 'keyword', keyword: 'Slight Tongue', desc: '혀' }, { id: 2043, type: 'keyword', keyword: 'Sullen', desc: '시무룩' }, { id: 2044, type: 'keyword', keyword: 'Kiss Face', desc: '키스' },
                                { id: 2022, type: 'keyword', keyword: 'Looking At Viewer', desc: '바라보는' }, { id: 2023, type: 'keyword', keyword: 'Sit', desc: '앉아있는' }, { id: 2024, type: 'keyword', keyword: 'Standing', desc: '서있는' }, { id: 2025, type: 'keyword', keyword: 'Run', desc: '달리는' }, { id: 2026, type: 'keyword', keyword: 'Jump', desc: '점프하는' }, { id: 2027, type: 'keyword', keyword: 'Holding', desc: '들고있는' }, { id: 2028, type: 'keyword', keyword: 'Glowing', desc: '빛나는' },  { id: 2034, type: 'keyword', keyword: 'Cartwheel', desc: '재주넘기' }, { id: 2035, type: 'keyword', keyword: 'Lie', desc: '눕다' }, { id: 2036, type: 'keyword', keyword: 'Prone', desc: '엎드리다' },  { id: 2038, type: 'keyword', keyword: 'Hug', desc: '껴안다' }, { id: 2039, type: 'keyword', keyword: 'Punch', desc: '펀치' }, { id: 2040, type: 'keyword', keyword: 'Kick', desc: '발차기' }                           
                            ], 
                            collapsed: true, 
                            isDefault: true,
                            activeTab: '외형',
                            tabs: [
                                { name: '외형', keywordIds: [2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010] },
                                { name: '의상', keywordIds: [2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 5001, 5002, 5003] },
                                { name: '표정', keywordIds: [2033, 2020, 2021, 2029, 2030, 2031, 2032, 2037, 2041,2042, 2043, 2044] },
                                { name: '동작', keywordIds: [2022, 2023, 2024, 2025, 2026, 2027, 2028, 2034, 2035, 2036, 2038, 2039, 2040] }
                            ]
                        },
                        { 
                            id: 'style', 
                            keywords: [
                                { id: 3001, type: 'keyword', keyword: 'Anime', desc: '애니메이션' }, { id: 3002, type: 'keyword', keyword: 'Manga', desc: '만화' }, { id: 3003, type: 'keyword', keyword: 'Concept Art', desc: '컨셉 아트' }, { id: 3004, type: 'keyword', keyword: 'Pixel Art', desc: '픽셀 아트' }, { id: 3005, type: 'keyword', keyword: 'Realistic', desc: '사실적인' }, { id: 3006, type: 'keyword', keyword: 'Photorealistic', desc: '사진같은' }, { id: 3007, type: 'keyword', keyword: 'Impressionism', desc: '인상주의' }, { id: 3008, type: 'keyword', keyword: 'Studio Ghibli Style', desc: '지브리 스타일' }, { id: 5004, type: 'keyword', keyword: 'Shinkai Makoto Style', desc: '신카이 마코토 스타일' }, { id: 5005, type: 'keyword', keyword: 'Playmobil', desc: '플레이모빌' }, { id: 5006, type: 'keyword', keyword: 'Korean', desc: '한국적인' }, { id: 5007, type: 'keyword', keyword: 'Japanese', desc: '일본적인' },
                                { id: 3009, type: 'keyword', keyword: 'Fantasy', desc: '판타지' }, { id: 3010, type: 'keyword', keyword: 'Sci-Fi', desc: '공상과학' }, { id: 3011, type: 'keyword', keyword: 'Cyberpunk', desc: '사이버펑크' }, { id: 3012, type: 'keyword', keyword: 'Steampunk', desc: '스팀펑크' }, { id: 3013, type: 'keyword', keyword: 'Horror', desc: '호러' }, { id: 3014, type: 'keyword', keyword: 'Dystopian', desc: '디스토피아' }, { id: 3015, type: 'keyword', keyword: 'Post-Apocalyptic', desc: '포스트 아포칼립스' },
                                { id: 3016, type: 'keyword', keyword: 'Cinematic Lighting', desc: '영화적 조명' }, { id: 3017, type: 'keyword', keyword: 'Dramatic Lighting', desc: '드라마틱 조명' }, { id: 3018, type: 'keyword', keyword: 'Glowing', desc: '발광' }, { id: 3019, type: 'keyword', keyword: 'Dark', desc: '어두운' }, { id: 3020, type: 'keyword', keyword: 'Vibrant Colors', desc: '생생한 색감' }, { id: 3021, type: 'keyword', keyword: 'Monochrome', desc: '단색' }, { id: 3022, type: 'keyword', keyword: 'Night', desc: '밤' }, { id: 3028, type: 'keyword', keyword: 'Day', desc: '낮' }, { id: 3029, type: 'keyword', keyword: 'Dawn', desc: '새벽' }, { id: 3030, type: 'keyword', keyword: 'Rain', desc: '비' }, { id: 3031, type: 'keyword', keyword: 'Spring', desc: '봄' }, { id: 3032, type: 'keyword', keyword: 'Summer', desc: '여름' }, { id: 3033, type: 'keyword', keyword: 'Fall', desc: '가을' }, { id: 3034, type: 'keyword', keyword: 'Winter', desc: '겨울' }, { id: 3035, type: 'keyword', keyword: 'Wind', desc: '바람' },
                                { id: 3023, type: 'keyword', keyword: 'Oil Painting', desc: '유화' }, { id: 3024, type: 'keyword', keyword: 'Watercolor', desc: '수채화' }, { id: 3025, type: 'keyword', keyword: 'Sketch', desc: '스케치' }, { id: 3026, type: 'keyword', keyword: '3D Render', desc: '3D 렌더' }, { id: 3027, type: 'keyword', keyword: 'Cel Shading', desc: '셀 셰이딩' }
                            ], 
                            collapsed: true, 
                            isDefault: true,
                            activeTab: '화풍',
                            tabs: [
                                { name: '화풍', keywordIds: [3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 5004, 5005, 5006, 5007] },
                                { name: '장르', keywordIds: [3009, 3010, 3011, 3012, 3013, 3014, 3015] },
                                { name: '분위기', keywordIds: [3016, 3017, 3018, 3019, 3020, 3021, 3022, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035] },
                                { name: '매체', keywordIds: [3023, 3024, 3025, 3026, 3027] }
                            ]
                        },
                        { 
                            id: 'composition', 
                            keywords: [
                                { id: 4001, type: 'keyword', keyword: 'Full Body', desc: '전신 샷' }, { id: 4002, type: 'keyword', keyword: 'Portrait', desc: '초상화' }, { id: 4003, type: 'keyword', keyword: 'Close-Up', desc: '클로즈업' }, { id: 4004, type: 'keyword', keyword: 'Cowboy Shot', desc: '카우보이 샷' }, { id: 4005, type: 'keyword', keyword: 'Low Angle', desc: '로우 앵글' }, { id: 4006, type: 'keyword', keyword: 'High Angle', desc: '하이 앵글' }, { id: 4007, type: 'keyword', keyword: 'Dynamic Angle', desc: '역동적 앵글' }, { id: 4008, type: 'keyword', keyword: 'Profile Shot', desc: '측면 샷' },
                                { id: 4009, type: 'keyword', keyword: 'Masterpiece', desc: '걸작' }, { id: 4010, type: 'keyword', keyword: 'Best Quality', desc: '최고 품질' }, { id: 4011, type: 'keyword', keyword: '4K', desc: '4K 해상도' }, { id: 4012, type: 'keyword', keyword: '8K', desc: '8K 해상도' }, { id: 4013, type: 'keyword', keyword: 'High Resolution', desc: '고해상도' }, { id: 4014, type: 'keyword', keyword: 'Detailed', desc: '디테일한' }, { id: 4015, type: 'keyword', keyword: 'Bokeh', desc: '보케 (배경 흐림)' }, { id: 4016, type: 'keyword', keyword: 'Lens Flare', desc: '렌즈 플레어' }, { id: 4017, type: 'keyword', keyword: 'Motion Blur', desc: '모션 블러' }
                            ], 
                            collapsed: true, 
                            isDefault: true,
                            activeTab: '샷/앵글',
                            tabs: [
                                { name: '샷/앵글', keywordIds: [4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008] },
                                { name: '품질/효과', keywordIds: [4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017] }
                            ]
                        }
                    ],
                    userGroups: [],
                    searchTerm: '',
                    preSearchCollapsedState: null,
                    preSearchActiveTabState: null,
                    tabDeleteState: { active: false, groupId: null }
                },

                settings: { 
                    apiKey: '', 
                    aiKeywordSupport: true,
                    referenceImageCount: 1,
                    generationModel: 'gemini', // 'imagen' or 'gemini'
                    aspectRatio: '1:1',
                    interpretationLevel: 'balanced', // 'precise', 'balanced', 'creative'
                    numberOfImages: 1
                },
                promptBoard: { 
                    subject: [], 
                    details: [], 
                    style: [], 
                    composition: [], 
                    manualPrompt: '', 
                    activeKeywordIds: [],
                    draggingItem: null
                },
                promptBoardAreaInfo: [
                    { key: 'subject', title: '1. 주제 (Subject)' },
                    { key: 'details', title: '2. 세부 묘사 (Details)' },
                    { key: 'style', title: '3. 표현 기법 (Style)' },
                    { key: 'composition', title: '4. 구도 (Composition)' }
                ],
                aspectRatioOptions: [
                    { ratio: '1:1', desc: '정사각형' },
                    { ratio: '4:3', desc: '사진 (가로)' },
                    { ratio: '3:4', desc: '사진 (세로)' },
                    { ratio: '16:9', desc: 'HD 영상 (가로)' },
                    { ratio: '9:16', desc: '스마트폰 (세로)' }
                ],
                history: [],
                presets: [],
                imageStation: { 
                    images: [],
                    draggingItem: null
                },
                ui: {
                    manualPromptPosition: 'append',
                    isToolboxOpen: false,
                    isPromptBoardCollapsed: true,
                    activeModal: null, 
                    modalData: {},
                    toast: {
                        show: false,
                        message: ''
                    },
                    isLoadingCompletion: false,
                    isLoadingImage: false,
                    isLoadingTranslation: false,
                    generatedImageUrl: null,
                    selectedImageId: null,
                    historySearchTerm: '',
                    presetSearchTerm: '',
                    editingPresetId: null,
                    isImageInfoPinned: false,
                    currentImageInfo: { name: '', resolution: '', size: '' },
                    moveMenu: { 
                        visible: false, 
                        top: 0, 
                        left: 0, 
                        keyword: null, 
                        fromGroupId: null, 
                        fromTabName: null 
                    },
                    addMenu: {
                        visible: false,
                        top: 0,
                        left: 0,
                        keyword: null
                    }
                },

                // [NEW] Master table to dynamically build the infuse panel
                infuseMasterTable: {
                    expression: {
                        title: '표정',
                        recipes: [
                            { keywordId: 2033, display: '😑' }, // neutral
                            { keywordId: 2020, display: '😊' }, // joy
                            { keywordId: 2021, display: '😢' }, // sadness
                            { keywordId: 2029, display: '😡' }, // anger
                            { keywordId: 2030, display: '😨' }, // fear
                            { keywordId: 2031, display: '😲' }, // surprise
                            { keywordId: 2032, display: '😣' }, // disgust
                            { keywordId: 2043, display: '😞' }, // sullen
                            { keywordId: 2041, display: '😤' }, // pout
                            { keywordId: 2037, display: '😉' }, // wink
                            { keywordId: 2044, display: '😘' }, // kiss face
                            { keywordId: 2042, display: '😋' }  // slight tongue
                        ]
                    },
                    action: {
                        title: '동작',
                        recipes: [
                            { keywordId: 2023, display: '🧘' }, // sit
                            { keywordId: 2025, display: '🏃' }, // run
                            { keywordId: 2026, display: '🤸' }, // jump
                            { keywordId: 2035, display: '🛌' }, // lie
                            { keywordId: 2038, display: '🤗' }, // hug
                            { keywordId: 2034, display: '🤸‍♂️' }, // cartwheel
                            { keywordId: 2039, display: '👊' }, // punch
                            { keywordId: 2040, display: '👟' }  // kick
                        ]
                    },
                    props: {
                        title: '소품',
                        recipes: [
                            { keywordId: 1031, display: '🧢' }, // cap
                            { keywordId: 1032, display: '☂️' }, // umbrella
                            { keywordId: 1033, display: '💐' }, // flower
                            { keywordId: 1028, display: '📖' }, // book
                            { keywordId: 1039, display: '👜' }, // bag
                            { keywordId: 1034, display: '📷' }, // camera
                            { keywordId: 1036, display: '🎸' }, // guitar
                            { keywordId: 1035, display: '🎤' }, // microphone
                            { keywordId: 1037, display: '📱' }, // mobile
                            { keywordId: 1038, display: '📰' }, // newspaper
                            { keywordId: 1027, display: '⚔️' }, // sword
                            { keywordId: 1011, display: '🐱' }, // cat
                            { keywordId: 1012, display: '🐶' }, // dog
                        ]
                    },
                    environment: {
                        title: '환경',
                        recipes: [
                            { keywordId: 3028, display: '☀️' },  // day
                            { keywordId: 3022, display: '🌙' },  // night
                            { keywordId: 3031, display: '🌱' },  // spring
                            { keywordId: 3032, display: '🏖️' },  // summer
                            { keywordId: 3033, display: '🍂' },  // fall
                            { keywordId: 3034, display: '❄️' },  // winter
                            { keywordId: 3030, display: '🌧️' },  // rain
                            { keywordId: 3035, display: '🌪️' }   // wind
                        ]
                    },
                    angle: {
                        title: '앵글',
                        recipes: [
                            { keywordId: 4001, display: '📹🧍‍♀️' }, // full body
                            { keywordId: 4003, display: '📹👩' }, // close-up
                            { keywordId: 4005, display: '⬇️' }, // low angle
                            { keywordId: 4006, display: '⬆️' }  // high angle
                        ]
                    }
                },

                // [NEW] Helper function to get keyword details from the main library
                getKeywordById(id) {
                    for (const group of [...this.keywordLibrary.defaultGroups, ...this.keywordLibrary.userGroups]) {
                        const found = group.keywords.find(k => k.id === id);
                        if (found) return found;
                    }
                    return null; // Return null if not found
                },
                // --- Computed Properties ---
                get isPromptBoardEmpty() {
                    return this.getFinalPrompt().length === 0;
                },
                get promptLengthInfo() {
                    const current = this.getFinalPrompt().length;
                    const max = this.constants.PROMPT_CHAR_LIMIT;
                    return {
                        current,
                        max,
                        exceeds: current > max
                    };
                },
                get referenceImagesSizeInfo() {
                    const maxMB = this.constants.IMAGE_SIZE_LIMIT_MB;
                    const imagesToConsider = this.imageStation.images.slice(0, this.settings.referenceImageCount);
                    if (imagesToConsider.length === 0) {
                        return { current: 0, max: maxMB, exceeds: false };
                    }
                    // Simplified and more direct calculation of Base64 string size
                    const totalBytes = imagesToConsider.reduce((sum, img) => {
                        return sum + (img.dataUrl.length || 0);
                    }, 0);

                    const currentMB = totalBytes / (1024 * 1024);
                    return {
                        current: currentMB,
                        max: maxMB,
                        exceeds: currentMB > maxMB
                    };
                },
                 get filteredHistory() {
                    if (!this.ui.historySearchTerm) return this.history;
                    const term = this.ui.historySearchTerm.toLowerCase();
                    return this.history.filter(item => item.promptText.toLowerCase().includes(term));
                },
                get filteredPresets() {
                    if (!this.ui.presetSearchTerm) return this.presets;
                    const term = this.ui.presetSearchTerm.toLowerCase();
                    return this.presets.filter(item => 
                        item.name.toLowerCase().includes(term) ||
                        item.promptText.toLowerCase().includes(term)
                    );
                },

                // =================================================================
                // API GATEWAY
                // =================================================================
                getApiKey() {
                    if (typeof __api_key !== 'undefined' && __api_key) {
                        return __api_key;
                    }
                    return this.settings.apiKey || "";
                },

                // 텍스트 생성 전용 게이트웨이
                async callTextAPI(systemPrompt, userQuery, temperature = 1.0) {
                    const apiKey = this.getApiKey();
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        safetySettings: this.constants.GEMINI_SAFETY_SETTINGS,
                        generationConfig: {
                            temperature: temperature
                        }
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => null);
                        const message = errorData?.error?.message || `API Error: ${response.status}`;
                        throw new Error(message);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        return text.replace(/```json|```/g, '').trim();
                    } else {
                        const reason = this.getFailureReason(result);
                        const reasonMap = {
                            recitation: "저작권", other: "기타", sexually_explicit: "성적 콘텐츠", hate_speech: "혐오 발언",
                            harassment: "괴롭힘", dangerous_content: "폭력/위험"
                        };
                        if (reason !== 'other') {
                             throw new Error(reasonMap[reason] || "알 수 없는 이유");
                        }
                        throw new Error("No content in API response.");
                    }
                },

                // Gemini 이미지 모델(나노바나나) 전용 게이트웨이
                async callImageAPI(prompt, images = [], mask = null, numberOfImages = 1) {
                    const apiKey = this.getApiKey();

                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                    
                    const parts = [{ text: prompt }];
                    images.forEach(image => parts.push({ inlineData: { mimeType: 'image/png', data: image.dataUrl.split(',')[1] } }));
                    if (mask) {
                        parts.push({ inlineData: { mimeType: 'image/png', data: mask.split(',')[1] } });
                    }

                    const payload = {
                        contents: [{ parts }],
                        generationConfig: { 
                            responseModalities: ['IMAGE'],
                            candidateCount: numberOfImages
                        },
                        safetySettings: this.constants.GEMINI_SAFETY_SETTINGS
                    };

                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                    if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                    return await response.json();
                },

                // Imagen 3 모델 전용 게이트웨이
                async callImagenAPI(prompt, numberOfImages = 1) {
                    const apiKey = this.getApiKey();
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                    
                    const parameters = { 
                        "personGeneration": "ALLOW_ALL",
                        "aspectRatio": this.settings.aspectRatio,
                        "sampleCount": numberOfImages
                    };

                    const payload = { 
                        instances: [{ prompt }], 
                        parameters
                    };
                    
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    
                    if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                    return await response.json();
                },

                async callMultimodalTextAPI(systemPrompt, userQuery, images = []) {
                    const apiKey = this.getApiKey();
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                    const parts = [{ text: userQuery }];
                    images.forEach(image => parts.push({ inlineData: { mimeType: 'image/png', data: image.dataUrl.split(',')[1] } }));

                    const payload = {
                        contents: [{ parts }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        safetySettings: this.constants.GEMINI_SAFETY_SETTINGS,
                        generationConfig: {
                            temperature: 0.5,
                            responseMimeType: "application/json",
                        }
                    };

                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => null);
                        const message = errorData?.error?.message || `API Error: ${response.status}`;
                        throw new Error(message);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        return text.replace(/```json|```/g, '').trim();
                    } else {
                        const reason = this.getFailureReason(result);
                        const reasonMap = { recitation: "저작권", other: "기타", sexually_explicit: "성적 콘텐츠", hate_speech: "혐오 발언", harassment: "괴롭힘", dangerous_content: "폭력/위험" };
                        if (reason !== 'other') throw new Error(reasonMap[reason] || "알 수 없는 이유");
                        throw new Error("API 응답에 내용이 없습니다.");
                    }
                },
                
                // =================================================================
                // AI-ASSISTED FUNCTIONS
                // =================================================================
                async callTranslationAPI(text) {
                    const systemPrompt = "You are a machine translator. Your sole task is to translate the given text into a concise English keyword or phrase suitable for an image generation AI. Do not add any explanations. The response MUST be a single JSON object with a single key 'translatedKeyword'.";
                    const userQuery = `Translate the following text into a concise English keyword or phrase:\n${text}\n\nResponse format:\n{"translatedKeyword": "..."}`;
                    
                    try {
                        const jsonString = await this.callTextAPI(systemPrompt, userQuery, 0.5);
                        const parsed = JSON.parse(jsonString);
                        return parsed.translatedKeyword || text.trim().replace(/\s+/g, ' ');
                    } catch (error) {
                        console.error("Translation API call failed:", error);
                        this.showToast(`AI 지원 오류: ${error.message}`);
                        throw error;
                    }
                },

                async callDescriptionAPI(keyword) {
                    const lang = 'Korean';
                    const systemPrompt = `You are a helpful assistant. Your task is to write a brief, one-sentence description for the given image generation keyword. The description should be in ${lang}. The response MUST be a single JSON object with a single key 'description'.`;
                    const userQuery = `Create a description for the keyword "${keyword}".\n\nResponse format:\n{"description": "..."}`;

                    try {
                        const jsonString = await this.callTextAPI(systemPrompt, userQuery, 0.5);
                        const parsed = JSON.parse(jsonString);
                        return parsed.description || '';
                    } catch (error) {
                        console.error("Description API call failed:", error);
                        this.showToast(`AI 지원 오류: ${error.message}`);
                        throw error;
                    }
                },
                
                async translateManualPrompt() {
                    const textToTranslate = this.promptBoard.manualPrompt.trim();
                    if (!textToTranslate) {
                        this.showToast("번역할 내용을 먼저 입력해주세요.");
                        return;
                    }

                    this.ui.isLoadingTranslation = true;
                    try {
                        const systemPrompt = "You are an intelligent translator. Your task is to translate the given text. Detect the source language and translate it to the other (Korean to English, or English to Korean). The response MUST be a single JSON object with a single key 'translatedText'.";
                        const userQuery = `Translate:\n${textToTranslate}\n\nResponse format:\n{"translatedText": "..."}`;
                        
                        const jsonString = await this.callTextAPI(systemPrompt, userQuery, 0.5);
                        const parsed = JSON.parse(jsonString);
                        if (parsed.translatedText) {
                            this.promptBoard.manualPrompt = parsed.translatedText;
                        } else {
                            throw new Error('Invalid JSON structure in translation response.');
                        }
                    } catch (error) {
                        console.error("Translation Error:", error);
                        this.showToast(`AI 지원 오류: ${error.message}`);
                    } finally {
                        this.ui.isLoadingTranslation = false;
                    }
                },

                async generatePromptSentence() {
                    if (this.promptBoard.subject.length === 0) {
                        this.showToast('먼저 "주제" 키워드를 추가해주세요.');
                        return;
                    }

                    const keywordText = ['subject', 'details', 'style', 'composition']
                        .map(cat => this.promptBoard[cat].map(k => k.keyword).join(', '))
                        .filter(Boolean)
                        .join(', ');

                    this.ui.isLoadingCompletion = true;
                    try {
                        const systemPrompt = "You are a world-class prompt engineer. Combine the given English keywords into a single, creative, detailed descriptive sentence in English. The response must be a single JSON object with the key 'prompt'.";
                        const userQuery = `Combine these keywords:\n${keywordText}\n\nExample format:\n{"prompt": "A cinematic portrait of a beautiful girl with long hair, cinematic lighting."}`;
                        
                        const jsonString = await this.callTextAPI(systemPrompt, userQuery, 1.0);
                        if (jsonString) {
                            const parsed = JSON.parse(jsonString);
                            if (parsed.prompt) {
                                // Rollback: Do not clear the promptBoard. Just update the manual prompt.
                                this.promptBoard.manualPrompt = parsed.prompt;
                            } else {
                                throw new Error('Invalid JSON structure in response.');
                            }
                        }
                    } catch (error) {
                        console.error("AI Prompt Completion Error:", error);
                        this.showToast(`AI 지원 오류: ${error.message}`);
                    } finally {
                        this.ui.isLoadingCompletion = false;
                    }
                },
                
                // =================================================================
                // UTILITY FUNCTIONS
                // =================================================================
                generateFilename(model) {
                    const modelAbbr = model === 'gemini' ? 'gf' : 'im';
                    const timestamp = Date.now();
                    return `sv-${modelAbbr}-${timestamp}.png`;
                },

                getFailureReason(result) {
                    const geminiCandidate = result?.candidates?.[0];
                    if (geminiCandidate) {
                        if (geminiCandidate.finishReason === 'RECITATION') return 'recitation';
                        if (geminiCandidate.finishReason === 'OTHER') return 'other';
                        if (geminiCandidate.finishReason === 'SAFETY') {
                            const blockedRating = geminiCandidate.safetyRatings?.find(r => r.blocked);
                            if (blockedRating) return blockedRating.category.replace('HARM_CATEGORY_', '').toLowerCase();
                        }
                    }
                    const imagenPrediction = result?.predictions?.[0];
                    if (imagenPrediction?.safetyFeedback) {
                        const blockedRating = imagenPrediction.safetyFeedback.safetyRatings?.find(r => r.blocked);
                        if (blockedRating) return blockedRating.category.replace('HARM_CATEGORY_', '').toLowerCase();
                    }
                    return 'other';
                },

                getFinalPrompt() {
                    const promptOrder = ['subject', 'details', 'style', 'composition'];
                    const promptParts = promptOrder.map(areaKey => {
                        const keywords = this.promptBoard[areaKey];
                        return (keywords && keywords.length > 0) ? keywords.map(k => k.keyword).join(', ') : '';
                    }).filter(Boolean);

                    const manualPrompt = this.promptBoard.manualPrompt.trim();
                    if (manualPrompt) {
                        if (this.ui.manualPromptPosition === 'prepend') {
                            promptParts.unshift(manualPrompt);
                        } else {
                            promptParts.push(manualPrompt);
                        }
                    }
                    
                    return promptParts.join(', ');
                },
                
                showToast(message) {
                    this.ui.toast.message = message;
                    this.ui.toast.show = true;
                    setTimeout(() => {
                        this.ui.toast.show = false;
                    }, 4000);
                },

                createBlankCanvas(width, height, color = '#FFFFFF') {
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.fillRect(0, 0, width, height);
                    return canvas.toDataURL('image/png');
                },

                createBlankImageForRatio(ratioStr) {
                    let targetWidth, targetHeight;
                    switch (ratioStr) {
                        case '4:3':   targetWidth = 1280; targetHeight = 896;  break;
                        case '3:4':   targetWidth = 896;  targetHeight = 1280; break;
                        case '16:9':  targetWidth = 1408; targetHeight = 768;  break;
                        case '9:16':  targetWidth = 768;  targetHeight = 1408; break;
                        case '1:1':
                        default:
                            return null; // Don't create for 1:1
                    }
                    return this.createBlankCanvas(targetWidth, targetHeight);
                },

                _toTitleCase(str) {
                    if (!str) return '';
                    return str.split(' ').map(word => {
                        // Do not change fully uppercase words like '4K'
                        if (word.toUpperCase() === word) return word; 
                        return word.charAt(0).toUpperCase() + word.substring(1).toLowerCase();
                    }).join(' ');
                },

                // =================================================================
                // IMAGE STATION FUNCTIONS
                // =================================================================
                handleFileUpload(event) {
                    const files = event.target.files;
                    if (files.length === 0) return;
                    Array.from(files).forEach(file => this.readFileAsDataURL(file));
                    event.target.value = null;
                },

                readFileAsDataURL(file) {
                    if (!file.type.startsWith('image/')) return;
                    const reader = new FileReader();
                    reader.onload = (e) => this.addToImageStation(e.target.result, file.name);
                    reader.onerror = () => {}; 
                    reader.readAsDataURL(file);
                },

                addToImageStation(imageDataUrl, fileName = 'pasted_or_drawn_image.png', selectAfterAdding = true) {
                    const newImage = { id: Date.now() + Math.random(), dataUrl: imageDataUrl, name: fileName };
                    this.imageStation.images.push(newImage);
                    if (selectAfterAdding) {
                        this.selectImage(newImage);
                    }
                    return newImage;
                },
                
                removeFromImageStation(id) {
                    const wasCurrentlyDisplayed = this.ui.selectedImageId === id;
                    const removedIndex = this.imageStation.images.findIndex(img => img.id === id);

                    this.imageStation.images = this.imageStation.images.filter(img => img.id !== id);

                    if (wasCurrentlyDisplayed) {
                        if (this.imageStation.images.length > 0) {
                            const newIndex = Math.min(removedIndex, this.imageStation.images.length - 1);
                            this.selectImage(this.imageStation.images[newIndex]);
                        } else {
                            this.ui.generatedImageUrl = null;
                            this.ui.selectedImageId = null;
                        }
                    }
                },

                selectImage(image) {
                    if (this.ui.selectedImageId === image.id) {
                        this.ui.selectedImageId = null;
                        this.ui.generatedImageUrl = null;
                    } else {
                        this.ui.selectedImageId = image.id;
                        this.ui.generatedImageUrl = image.dataUrl;
                    }
                },

                handleImageDragStart(event, image) {
                    this.imageStation.draggingItem = image;
                    event.dataTransfer.effectAllowed = 'move';
                },

                handleImageDragOver(event, index) {
                    event.preventDefault();
                },

                handleImageDrop(event, targetIndex) {
                    event.preventDefault();
                    if (!this.imageStation.draggingItem) return;

                    const draggedItem = this.imageStation.draggingItem;
                    const fromIndex = this.imageStation.images.findIndex(img => img.id === draggedItem.id);

                    if (fromIndex === -1 || fromIndex === targetIndex) {
                        this.imageStation.draggingItem = null;
                        return;
                    }

                    const [itemToMove] = this.imageStation.images.splice(fromIndex, 1);
                    this.imageStation.images.splice(targetIndex, 0, itemToMove);
                    
                    this.imageStation.draggingItem = null;
                },

                navigateToNextImage() {
                    const images = this.imageStation.images;
                    if (images.length < 2) return;
                    const currentIndex = images.findIndex(img => img.id === this.ui.selectedImageId);
                    if (currentIndex > -1 && currentIndex < images.length - 1) {
                        this.selectImage(images[currentIndex + 1]);
                    }
                },

                navigateToPreviousImage() {
                    const images = this.imageStation.images;
                    if (images.length < 2) return;
                    const currentIndex = images.findIndex(img => img.id === this.ui.selectedImageId);
                    if (currentIndex > 0) {
                        this.selectImage(images[currentIndex - 1]);
                    }
                },

                updateImageInfo(image) {
                    if (!image) {
                        this.ui.currentImageInfo = { name: '', resolution: '', size: '' };
                        return;
                    }
                    const img = new Image();
                    img.onload = () => {
                        const sizeInBytes = image.dataUrl.length * (3 / 4) - 2; // Approximation for base64
                        const sizeInKB = sizeInBytes / 1024;
                        const sizeDisplay = sizeInKB > 1024 
                            ? `${(sizeInKB / 1024).toFixed(2)} MB` 
                            : `${sizeInKB.toFixed(1)} KB`;
                        
                        this.ui.currentImageInfo = {
                            name: image.name,
                            resolution: `${img.width}x${img.height}`,
                            size: sizeDisplay
                        };
                    };
                    img.src = image.dataUrl;
                },
                
                // =================================================================
                // IMAGE GENERATION FUNCTIONS
                // =================================================================
                async generateImage() {
                    let finalPrompt = this.getFinalPrompt();
                    
                    let imagesToSend = this.imageStation.images;

                    if (!finalPrompt && imagesToSend.length === 0) {
                        this.showToast("프롬프트를 입력하거나 이미지를 첨부해주세요.");
                        return;
                    }
                    
                    this.ui.isLoadingImage = true;
                    
                    let modelToUse;
                    modelToUse = this.settings.generationModel;

                    let numberOfImagesToGenerate = this.settings.numberOfImages;

                    if (modelToUse === 'imagen') {
                        imagesToSend = [];
                    } else {
                        imagesToSend = imagesToSend.slice(0, this.settings.referenceImageCount);
                        // Gemini 사용 시, 출력 개수 UI 비활성화 및 값 1로 고정
                        if (this.settings.generationModel === 'gemini') {
                             numberOfImagesToGenerate = 1;
                        }
                    }
                    
                    if (modelToUse === 'gemini' && this.settings.aspectRatio !== '1:1' && imagesToSend.length === 0) {
                        const blankImage = this.createBlankImageForRatio(this.settings.aspectRatio);
                        if (blankImage) {
                            const hackImage = { dataUrl: blankImage, name: 'ratio_hack.png' };
                            imagesToSend.unshift(hackImage);
                        }
                    }
                    
                    const level = this.settings.interpretationLevel;
                    if (level === 'precise') {
                        finalPrompt = `Prioritize a faithful representation of the provided inputs. The text prompt is a strict instruction for modification or detail. If a reference image is included, its core style, subject, and composition must be preserved as the primary foundation. The prompt is: ${finalPrompt}`;
                    } else if (level === 'creative') {
                        finalPrompt = `Use the provided inputs as creative inspiration. You have artistic freedom to dramatically reinterpret the style, composition, and mood, using the text prompt and any reference image as a starting point for a new, imaginative artwork. The prompt is: ${finalPrompt}`;
                    }

                    await this.generateImages(finalPrompt, imagesToSend, modelToUse, numberOfImagesToGenerate);

                    this.ui.isLoadingImage = false;
                },

                // [NEW] Handles all AI actions delegated from the edit canvas
                // [NEW] Handles all AI actions delegated from the edit canvas
                async executeModalAIAction(modalData) {
                    this.ui.isLoadingImage = true;
                    try {
                        let result;
                        const model = 'gemini'; // All modal actions use Gemini

                        if (modalData.mode === 'draw') {
                            const prompt = this.constants[modalData.aISupportType];
                            const imageToSend = { dataUrl: modalData.canvasData };
                            result = await this.callImageAPI(prompt, [imageToSend]);

                        } else if (modalData.mode === 'refine') {
                             const prompt = this.constants[modalData.correctionType];
                            let imagesToSend = [];
                            if (modalData.correctionType === 'id-photo') {
                                const whiteCanvasUrl = this.createBlankCanvas(903, 1161);
                                imagesToSend.push({ dataUrl: whiteCanvasUrl });
                                imagesToSend.push({ dataUrl: modalData.canvasData });
                            } else {
                                imagesToSend.push({ dataUrl: modalData.canvasData });
                            }
                            result = await this.callImageAPI(prompt, imagesToSend);

                        } else if (modalData.mode === 'inpaint' || modalData.mode === 'outpaint') {
                            const imageToSend = { dataUrl: modalData.baseImage };
                            const prompt = modalData.mode === 'inpaint' ? modalData.prompt : "Expand the canvas based on the attached image and mask. The new area should be filled in a way that is consistent with the original image's style and content.";
                            result = await this.callImageAPI(prompt, [imageToSend], modalData.mask);

                        } 
                        // Note: Infuse mode has its own separate logic inside editCanvas's executeAction.

                        // [MODIFIED] Common result handling for single-image outputs.
                        const imageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                        if (imageData) {
                            const newImageUrl = `data:image/png;base64,${imageData}`;
                            // [FIX] Redundant selectImage call removed. addToImageStation now handles selection correctly.
                            this.addToImageStation(newImageUrl, this.generateFilename(model));
                        } else {
                            const reason = this.getFailureReason(result);
                            this.showToast(`AI 안전 정책: ${reason}`);
                        }

                    } catch (error) {
                        console.error("Modal AI Action Error:", error);
                        this.showToast(`작업 실패: ${error.message}`);
                    } finally {
                        this.ui.isLoadingImage = false;
                    }
                },

                async generateImages(prompt, images, model, numberOfImages) {
                    try {
                        let result;
                        
                        if (model === 'gemini') {
                            const imageCount = (images.length > 0 && images[0].name === 'ratio_hack.png') ? 1 : numberOfImages;
                            result = await this.callImageAPI(prompt, images, null, imageCount);
                        } else {
                            result = await this.callImagenAPI(prompt, numberOfImages);
                        }
                        
                        const candidates = model === 'gemini' ? result.candidates : result.predictions;

                        if (candidates && candidates.length > 0) {
                            const generatedImages = [];
                            for (const candidate of candidates) {
                                const imageData = model === 'gemini' 
                                    ? candidate?.content?.parts?.[0]?.inlineData?.data
                                    : candidate?.bytesBase64Encoded;
                                
                                if (imageData) {
                                    const newImageUrl = `data:image/png;base64,${imageData}`;
                                    const newFilename = this.generateFilename(model);
                                    const newImage = { id: Date.now() + Math.random(), dataUrl: newImageUrl, name: newFilename };
                                    generatedImages.push(newImage);
                                }
                            }
                            
                            if (generatedImages.length > 0) {
                                this.imageStation.images.unshift(...generatedImages);
                                this.ui.generatedImageUrl = generatedImages[0].dataUrl;
                                this.ui.selectedImageId = generatedImages[0].id;
                                this.addHistory('success', null, model);
                            } else {
                                const reason = this.getFailureReason(result);
                                this.addHistory('failure', reason, model);
                                this.showToast(`AI 안전 정책에 따라 요청이 거부되었습니다. (${reason})`);
                            }
                        } else {
                            const reason = this.getFailureReason(result);
                            this.addHistory('failure', reason, model);
                            this.showToast(`AI 안전 정책에 따라 요청이 거부되었습니다. (${reason})`);
                        }
                    } catch (error) {
                        console.error("Image Generation Error:", error);
                        this.addHistory('failure', 'technical', model);
                        this.showToast(`이미지 생성 실패: ${error.message}`);
                    }
                },

                // =================================================================
                // Keyword Library & CANVAS SYNC FUNCTIONS
                // =================================================================
                
                handleKeywordLibraryClick(event, item, group) {
                    const isUserKeyword = group && !group.isDefault;
                    const isActive = this.promptBoard.activeKeywordIds.includes(item.id);

                    if (isActive) {
                        this.removeKeywordFromAllBoardAreas(item.id);
                    } else {
                        if (isUserKeyword) {
                            this.openAddMenu(event, item);
                        } else {
                            this.addKeywordToPromptBoard(item, group.id);
                        }
                    }
                },

                addKeywordToPromptBoard(item, areaKey) {
                    if (this.promptBoard[areaKey]) {
                        const newKeywordInstance = { ...item, instanceId: Date.now() + Math.random() };
                        this.promptBoard[areaKey].push(newKeywordInstance);
                        this.updateActiveKeywordIds();
                    }
                },

                removeKeywordFromAllBoardAreas(keywordId) {
                    let removedKeywordName = '';
                    ['subject', 'details', 'style', 'composition'].forEach(areaKey => {
                        this.promptBoard[areaKey] = this.promptBoard[areaKey].filter(k => {
                            if (k.id === keywordId) {
                                removedKeywordName = k.keyword;
                                return false;
                            }
                            return true;
                        });
                    });
                    this.updateActiveKeywordIds();
                },
                
                removeKeywordFromPromptBoard(instanceId) {
                    let keywordIdToRemove = null;
                    let removedKeywordName = '';
                    ['subject', 'details', 'style', 'composition'].forEach(areaKey => {
                        this.promptBoard[areaKey] = this.promptBoard[areaKey].filter(k => {
                            if (k.instanceId === instanceId) {
                                keywordIdToRemove = k.id;
                                removedKeywordName = k.keyword;
                                return false;
                            }
                            return true;
                        });
                    });
                    if (keywordIdToRemove) {
                        this.updateActiveKeywordIds();
                    }
                },

                updateActiveKeywordIds() {
                    const allCanvasKeywordIds = ['subject', 'details', 'style', 'composition']
                        .flatMap(areaKey => this.promptBoard[areaKey].map(k => k.id));
                    this.promptBoard.activeKeywordIds = [...new Set(allCanvasKeywordIds)];
                },
                
                // =================================================================
                // Keyword Library MANAGEMENT (Pop-over Menu)
                // =================================================================
                openKeywordLibraryMoveMenu(event, item, group) {
                    const rect = event.currentTarget.getBoundingClientRect();
                    this.ui.moveMenu = {
                        visible: true,
                        top: rect.bottom + window.scrollY,
                        left: rect.left + window.scrollX,
                        keyword: item,
                        fromGroupId: group.id,
                        fromTabName: group.activeTab
                    };
                },

                closeKeywordLibraryMoveMenu() {
                    this.ui.moveMenu.visible = false;
                },
                
                openAddMenu(event, item) {
                    const rect = event.currentTarget.getBoundingClientRect();
                    this.ui.addMenu = {
                        visible: true,
                        top: rect.bottom + window.scrollY,
                        left: rect.left + window.scrollX,
                        keyword: item,
                    };
                },

                closeAddMenu() {
                    this.ui.addMenu.visible = false;
                },

                moveKeyword(toGroupId, toTabName) {
                    const { keyword, fromGroupId, fromTabName } = this.ui.moveMenu;
                    if (!keyword) return;

                    const allGroups = [...this.keywordLibrary.defaultGroups, ...this.keywordLibrary.userGroups];
                    const fromGroup = allGroups.find(g => g.id === fromGroupId);
                    const toGroup = allGroups.find(g => g.id === toGroupId);

                    if (!fromGroup || !toGroup) return;

                    const fromTab = fromGroup.tabs.find(t => t.name === fromTabName);
                    if (!fromTab) return;

                    const fromKeywordIdIndex = fromTab.keywordIds.indexOf(keyword.id);
                    if (fromKeywordIdIndex === -1) return;

                    // 1. Remove from source
                    fromTab.keywordIds.splice(fromKeywordIdIndex, 1);

                    // 2. Move keyword data if group changes
                    if (fromGroupId !== toGroupId) {
                        const keywordDataIndex = fromGroup.keywords.findIndex(k => k.id === keyword.id);
                        if (keywordDataIndex > -1) {
                            const [keywordData] = fromGroup.keywords.splice(keywordDataIndex, 1);
                            toGroup.keywords.push(keywordData);
                        }
                    }

                    // 3. Add to destination
                    const toTab = toGroup.tabs.find(t => t.name === toTabName);
                    if (!toTab) {
                        fromTab.keywordIds.splice(fromKeywordIdIndex, 0, keyword.id); // Revert
                        return;
                    }
                    toTab.keywordIds.unshift(keyword.id);

                    // 4. Reset state and save
                    this.closeKeywordLibraryMoveMenu();
                    this.saveState(false);
                },

                toggleKeywordLibraryTabDeleteMode(groupId) {
                    const state = this.keywordLibrary.tabDeleteState;
                    if (state.active && state.groupId === groupId) {
                        state.active = false;
                        state.groupId = null;
                    } else {
                        state.active = true;
                        state.groupId = groupId;
                    }
                },

                deleteTabFromKeywordLibraryGroup(groupId, tabName) {
                    const data = {
                        groupId: groupId,
                        tabName: tabName,
                        confirmMessage: `'${tabName}' 탭을 삭제하시겠습니까? 탭 안의 키워드도 모두 삭제됩니다.`
                    };
                    this.openModal('delete-tab-confirm-modal', data);
                },

                confirmDeleteTab() {
                    const { groupId, tabName } = this.ui.modalData;
                    const allGroups = [...this.keywordLibrary.defaultGroups, ...this.keywordLibrary.userGroups];
                    const group = allGroups.find(g => g.id === groupId);
                    if (group) {
                        const tabIndex = group.tabs.findIndex(t => t.name === tabName);
                        if (tabIndex > -1) {
                            const [deletedTab] = group.tabs.splice(tabIndex, 1);
                            group.keywords = group.keywords.filter(k => !deletedTab.keywordIds.includes(k.id));
                            if (group.activeTab === tabName && group.tabs.length > 0) {
                                group.activeTab = group.tabs[0].name;
                            }
                        }
                    }
                    this.keywordLibrary.tabDeleteState = { active: false, groupId: null };
                    this.saveState();
                    this.closeModal();
                },

                async addNewKeywordToKeywordLibrary(keywordInput, descInput) {
                    if (!keywordInput || !keywordInput.trim()) {
                        this.showToast("키워드 이름을 입력해주세요.");
                        return;
                    }

                    this.ui.isLoadingCompletion = true;
                    try {
                        const userGroups = this.keywordLibrary.userGroups;
                        if (userGroups.length === 0) {
                            this.addNewKeywordLibraryGroup("내 키워드");
                        }

                        let finalKeyword = keywordInput.trim();
                        let finalDesc = descInput.trim();

                        if (this.settings.aiKeywordSupport) {
                            const isSimpleEnglish = /^[a-zA-Z0-9\s.,'()\-]+$/.test(finalKeyword);
                            if (!isSimpleEnglish) {
                                finalKeyword = await this.callTranslationAPI(finalKeyword);
                                finalKeyword = this._toTitleCase(finalKeyword);
                            }
                            if (!finalDesc) {
                                finalDesc = await this.callDescriptionAPI(finalKeyword);
                            }
                        } else {
                            // AI support is OFF. Enforce English-only.
                            const isEnglishOnly = /^[a-zA-Z0-9\s.,'()\-]+$/.test(finalKeyword);
                            if (!isEnglishOnly) {
                                this.showToast("키워드는 영문만 등록할 수 있습니다.");
                                this.ui.isLoadingCompletion = false;
                                return;
                            }
                        }
                        
                        if (!finalDesc) {
                            finalDesc = '_';
                        }

                        const newKeyword = {
                            id: 'user-' + Date.now() + Math.random(),
                            type: 'keyword',
                            keyword: finalKeyword.replace(/\s+/g, ' '),
                            desc: finalDesc,
                            isCustom: true
                        };
                        
                        const targetGroup = this.keywordLibrary.userGroups[0];
                        targetGroup.keywords.unshift(newKeyword);
                        
                        const targetTab = targetGroup.tabs[0] || null;
                        if (targetTab) {
                             targetTab.keywordIds.unshift(newKeyword.id);
                        }
                        this.saveState();
                    } catch (error) {
                        console.error("AI Support Error:", error);
                        this.showToast("AI 지원 오류: " + error.message);
                    } finally {
                        this.ui.isLoadingCompletion = false;
                    }
                },

                addNewKeywordLibraryGroup(name) {
                    if (!name || !name.trim()) {
                        this.showToast("그룹 이름을 입력해주세요.");
                        return;
                    }
                    const newGroup = {
                        id: 'user-' + Date.now() + Math.random(),
                        name: name.trim(),
                        keywords: [],
                        collapsed: true,
                        isDefault: false,
                        activeTab: '기본',
                        tabs: [{ name: '기본', keywordIds: [] }]
                    };
                    this.keywordLibrary.userGroups.push(newGroup);
                    this.saveState();
                },

                deleteUserKeywordLibraryGroup(groupId) {
                    const groupIndex = this.keywordLibrary.userGroups.findIndex(g => g.id === groupId);
                    if (groupIndex > -1) {
                        const [deletedGroup] = this.keywordLibrary.userGroups.splice(groupIndex, 1);
                        this.saveState();
                        this.showToast(`'${deletedGroup.name}' 그룹이 삭제되었습니다.`);
                    }
                },
                
                removeKeywordFromKeywordLibrary(groupId, itemId) {
                    const allGroups = [...this.keywordLibrary.defaultGroups, ...this.keywordLibrary.userGroups];
                    const group = allGroups.find(g => g.id === groupId);
                    
                    if (group) {
                        const keywordIndex = group.keywords.findIndex(k => k.id === itemId);
                        if (keywordIndex > -1) {
                            const [removedKeyword] = group.keywords.splice(keywordIndex, 1);
                            group.tabs.forEach(tab => {
                                const idIndex = tab.keywordIds.indexOf(itemId);
                                if (idIndex > -1) tab.keywordIds.splice(idIndex, 1);
                            });
                            this.removeKeywordFromAllBoardAreas(removedKeyword.id);
                            this.saveState();
                            this.showToast(`'${removedKeyword.keyword}' 키워드가 삭제되었습니다.`);
                        }
                    }
                },

                // =================================================================
                // PROMPT BOARD DRAG & DROP FUNCTIONS
                // =================================================================
                
                handlePromptBoardDragStart(event, item, fromGroupKey) {
                    this.promptBoard.draggingItem = { item: { ...item }, fromGroupKey: fromGroupKey };
                    event.dataTransfer.effectAllowed = 'move';
                },

                handlePromptBoardDragOver(event) {
                    event.preventDefault();
                },
                
                handlePromptBoardDrop(event, toGroupKey) {
                    if (!this.promptBoard.draggingItem) return;
                
                    const { item, fromGroupKey } = this.promptBoard.draggingItem;
                    const fromArray = this.promptBoard[fromGroupKey];
                    const fromIndex = fromArray.findIndex(k => k.instanceId === item.instanceId);
                
                    if (fromIndex === -1) {
                        this.clearPromptBoardDragState();
                        return;
                    }
                
                    const dropTarget = event.target.closest('.prompt-keyword');
                    const toArray = this.promptBoard[toGroupKey];
                    let toIndex = toArray.length;

                    if (dropTarget) {
                        const targetId = dropTarget.dataset.instanceId;
                        if (targetId !== item.instanceId) {
                           const targetIndexInDOM = Array.from(dropTarget.parentElement.children).indexOf(dropTarget);
                           const rect = dropTarget.getBoundingClientRect();
                           const isAfter = event.clientY > rect.top + rect.height / 2;
                           toIndex = isAfter ? targetIndexInDOM + 1 : targetIndexInDOM;
                        } else {
                            this.clearPromptBoardDragState();
                            return;
                        }
                    }
                
                    const [movedItem] = fromArray.splice(fromIndex, 1);
                
                    if (fromGroupKey === toGroupKey && fromIndex < toIndex) {
                        toIndex--;
                    }
                
                    toArray.splice(toIndex, 0, movedItem);
                
                    this.updateActiveKeywordIds();
                    this.clearPromptBoardDragState();
                },

                clearPromptBoardDragState() {
                    this.promptBoard.draggingItem = null;
                },
                
                // Image Station D&D
                handleImageStationDragStart(event, image) {
                    this.imageStation.draggingItem = image;
                    event.dataTransfer.effectAllowed = 'move';
                },

                handleImageStationOver(event, index) {
                    event.preventDefault();
                },

                handleImageStationDrop(event, targetIndex) {
                    event.preventDefault();
                    if (!this.imageStation.draggingItem) return;

                    const draggedItem = this.imageStation.draggingItem;
                    const fromIndex = this.imageStation.images.findIndex(img => img.id === draggedItem.id);

                    if (fromIndex === -1 || fromIndex === targetIndex) {
                        this.imageStation.draggingItem = null;
                        return;
                    }

                    const [itemToMove] = this.imageStation.images.splice(fromIndex, 1);
                    this.imageStation.images.splice(targetIndex, 0, itemToMove);
                    
                    this.imageStation.draggingItem = null;
                },

                clearImageStationDragState() {
                    this.imageStation.draggingItem = null;
                },

                // =================================================================
                // OTHER UI & STATE MANAGEMENT FUNCTIONS
                // =================================================================
                
                clearPromptBoardAndImageStation() {
                    this.promptBoard = { subject: [], details: [], style: [], composition: [], manualPrompt: '', activeKeywordIds: [] };
                    this.imageStation.images = [];
                    this.ui.generatedImageUrl = null;
                    this.ui.selectedImageId = null;
                    this.showToast("보드와 이미지 스테이션을 모두 비웠습니다.");
                },

                factoryReset() {
                    localStorage.removeItem(this.constants.LOCAL_STORAGE_KEY);
                    this.showToast("모든 데이터가 초기화되었습니다. 페이지를 새로고침합니다.");
                    setTimeout(() => location.reload(), 1500);
                },

                openModal(id, data = {}) {
                    this.ui.modalData = data;
                    this.ui.activeModal = id;
                },
                
                closeModal() {
                    this.ui.activeModal = null;
                    this.ui.modalData = {};
                },
                
                copyToClipboard(text) {
                    if (!text) return;
                     const textarea = document.createElement('textarea');
                     textarea.value = text;
                     document.body.appendChild(textarea);
                     textarea.select();
                     try {
                        document.execCommand('copy');
                        this.showToast("클립보드에 복사되었습니다!");
                     } catch (err) {
                        this.showToast("복사에 실패했습니다.");
                     }
                     document.body.removeChild(textarea);
                },
                
                saveState(showToast = true) {
                    try {
                        const dataToSave = {
                            keywordLibrary: {
                                defaultGroups: this.keywordLibrary.defaultGroups,
                                userGroups: this.keywordLibrary.userGroups,
                            },
                            settings: this.settings,
                            history: this.history,
                            presets: this.presets
                        };
                        localStorage.setItem(this.constants.LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
                        if(showToast && this.ui.activeModal === 'settings-modal') this.showToast("설정이 저장되었습니다.");
                    } catch (error) {
                        this.showToast("설정을 저장하는데 실패했습니다. 브라우저 저장 공간이 부족할 수 있습니다.");
                    }
                },
                
                loadState() {
                    try {
                        const savedData = localStorage.getItem(this.constants.LOCAL_STORAGE_KEY);
                        if (!savedData) return;
                        const parsed = JSON.parse(savedData);
                        if (parsed) {
                           if (parsed.keywordLibrary) {
                                this.keywordLibrary.defaultGroups = parsed.keywordLibrary.defaultGroups || this.keywordLibrary.defaultGroups;
                                this.keywordLibrary.userGroups = parsed.keywordLibrary.userGroups || [];
                            }
                            this.settings = { ...this.settings, ...parsed.settings };
                            this.history = parsed.history || [];
                            this.presets = parsed.presets || [];
                            this.ui.generatedImageUrl = null;
                            this.ui.selectedImageId = null;
                            this.imageStation.images = [];
                            this.showToast("저장된 설정을 불러왔습니다.");
                        }
                    } catch (error) {
                        console.error("Load state error:", error);
                    }
                },
                
                // =================================================================
                // PRESET & HISTORY REFACTORED FUNCTIONS
                // =================================================================
                saveCurrentPromptBoardAsPreset() {
                    const promptText = this.getFinalPrompt();
                    if (!promptText) {
                        this.showToast("저장할 내용이 없습니다.");
                        return;
                    }
                    const now = new Date();
                    const name = `Preset ${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    
                    const preset = {
                        id: Date.now(),
                        name: name,
                        promptText: promptText,
                        promptLength: promptText.length,
                        promptBoardState: JSON.parse(JSON.stringify(this.promptBoard))
                    };
                    
                    if (this.settings.generationModel === 'imagen' && this.settings.seed) {
                        preset.seed = this.settings.seed;
                    }

                    this.presets.unshift(preset);
                    this.saveState();
                    this.showToast(`'${name}' 프리셋이 저장되었습니다.`);
                },
                
                savePresetFromHistory(historyId) {
                    const item = this.history.find(h => h.id === historyId);
                    if (!item) return;

                    const now = new Date();
                    const name = `Preset ${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

                    const preset = {
                        id: Date.now(),
                        name: name,
                        promptText: item.promptText,
                        promptLength: item.promptLength,
                        promptBoardState: JSON.parse(JSON.stringify(item.promptBoardState))
                    };
                    
                    this.presets.unshift(preset);
                    this.saveState();
                    this.showToast(`히스토리를 프리셋으로 저장했습니다: '${name}'`);
                },
                savePromptAsPreset(promptText) {
                    if (!promptText) {
                        this.showToast("저장할 프롬프트가 없습니다.");
                        return;
                    }
                    const now = new Date();
                    const name = `분석 프리셋 ${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                    
                    const preset = {
                        id: Date.now(),
                        name: name,
                        promptText: promptText,
                        promptLength: promptText.length,
                        promptBoardState: {
                            subject: [], details: [], style: [], composition: [],
                            manualPrompt: promptText, activeKeywordIds: []
                        }
                    };
                    
                    this.presets.unshift(preset);
                    this.saveState();
                    this.showToast(`'${name}' 프리셋이 저장되었습니다.`);
                },

                loadPreset(id) {
                    const preset = this.presets.find(p => p.id === id);
                    if (preset) {
                        this.promptBoard = { ...{activeKeywordIds: []}, ...JSON.parse(JSON.stringify(preset.promptBoardState)) };
                        this.imageStation.images = [];
                        this.ui.generatedImageUrl = null;
                        this.ui.selectedImageId = null;
                        this.settings.seed = preset.seed || '';
                        this.showToast(`'${preset.name}' 프리셋을 불러왔습니다.`);
                        this.closeModal();
                    }
                },
                
                deletePreset(id) {
                    this.presets = this.presets.filter(p => p.id !== id);
                    this.saveState();
                    this.showToast("프리셋을 삭제했습니다.");
                },

                updatePresetName(id, newName) {
                    const preset = this.presets.find(p => p.id === id);
                    if(preset && newName.trim()){
                        preset.name = newName.trim();
                        this.saveState(false);
                    }
                    this.ui.editingPresetId = null;
                },

                deleteHistory(id) {
                    this.history = this.history.filter(i => i.id !== id);
                    this.saveState();
                    this.showToast("히스토리 항목을 삭제했습니다.");
                },

                // =================================================================
                // HISTORY FUNCTIONS
                // =================================================================
                restoreHistory(id) {
                    const item = this.history.find(h => h.id === id);
                    if (item) {
                         this.promptBoard = { ...this.promptBoard, ...item.promptBoardState };
                         if (item.image) {
                            // Find if image still exists in imageStation, otherwise add it.
                            const existingImage = this.imageStation.images.find(img => img.dataUrl === item.image);
                            if(existingImage){
                                this.selectImage(existingImage);
                            } else {
                                this.addToImageStation(item.image, `history_${item.id}.png`);
                            }
                         } else {
                            this.imageStation.images = [];
                            this.ui.generatedImageUrl = null;
                            this.ui.selectedImageId = null;
                         }
                        this.ui.isPromptBoardCollapsed = false;
                        this.showToast("히스토리를 복원했습니다.");
                        this.closeModal();
                    }
                },
                
                addHistory(status, reason, model, prompt = null) {
                    this.history.unshift({
                        id: Date.now(),
                        status,
                        reason,
                        modelUsed: model,
                        promptText: prompt || this.getFinalPrompt(),
                        promptLength: (prompt || this.getFinalPrompt()).length,
                        image: null,
                        promptBoardState: JSON.parse(JSON.stringify(this.promptBoard))
                    });
                }
            });        
   
            Alpine.data('editCanvas', () => ({
                // =================================================================
                // 1. 상태 변수 (State Properties)
                // =================================================================
                mode: null,
                canvas: null,
                isLoading: false,
                baseImage: null,
                activeListeners: {}, // To track and remove mode-specific event listeners
                
                // Mode-specific states
                refineState: {},
                brushSize: 20,
                brushColor: '#000000',
                activeAISupport: null,
                inpaintPrompt: '',
                maskMode: 'transform',
                fabricImage: null,
                originalImage: null,
                activeAspectRatioPreset: null,
                padding: {},
                originalWidth: 0,
                originalHeight: 0,
                expansionBudgetPercent: 100,
                scaledResolution: '0x0',
                cornerBudgetConsumption: 0,
                outputs: [],
                outputCount: 1,
                infuseActiveTab: 'expression',
                analyzeState: {},
                emotionDisplayOrder: [
                    { key: 'neutral', label: 'NEUTRAL', color: 'bg-slate-500' },
                    { key: 'joy', label: 'JOY', color: 'bg-amber-400' },
                    { key: 'sadness', label: 'SADNESS', color: 'bg-blue-500' },
                    { key: 'anger', label: 'ANGER', color: 'bg-red-500' },
                    { key: 'fear', label: 'FEAR', color: 'bg-violet-500' },
                    { key: 'surprise', label: 'SURPRISE', color: 'bg-orange-500' },
                    { key: 'contempt', label: 'CONTEMPT', color: 'bg-amber-800' },
                    { key: 'disgust', label: 'DISGUST', color: 'bg-green-500' }
                ],
                
                aiPreparationStrategies: {
                    draw: (context) => ({
                        mode: context.mode,
                        aISupportType: context.activeAISupport,
                        canvasData: context._exportCanvasAtOriginalResolution()
                    }),
                    refine: (context) => ({
                        mode: context.mode,
                        correctionType: context.refineState.activeAICorrection,
                        canvasData: context._exportCanvasAtOriginalResolution()
                    }),
                    inpaint: async (context) => {
                        const maskCanvas = new fabric.StaticCanvas(null, { width: context.canvas.width, height: context.canvas.height });
                        const nonImageObjects = context.canvas.getObjects().filter(obj => obj.type !== 'image');
                        const clonedObjects = await Promise.all(nonImageObjects.map(obj => new Promise(resolve => obj.clone(resolve))));
                        if (context.maskMode === 'transform') {
                            maskCanvas.backgroundColor = 'black';
                            clonedObjects.forEach(clone => maskCanvas.add(clone.set({ stroke: 'white', fill: 'white' })));
                        } else {
                            maskCanvas.backgroundColor = 'white';
                            clonedObjects.forEach(clone => maskCanvas.add(clone.set({ stroke: 'black', fill: 'black' })));
                        }
                        maskCanvas.renderAll();
                        return {
                            mode: context.mode,
                            prompt: context.inpaintPrompt,
                            baseImage: context.baseImage,
                            mask: maskCanvas.toDataURL({ format: 'png' })
                        };
                    },
                    outpaint: (context) => {
                        const originalImageDataUrl = context.baseImage;
                        if (!originalImageDataUrl) throw new Error("원본 이미지를 찾을 수 없습니다.");
                        const finalWidth = Math.round(context.originalWidth * (1 + (context.padding.left + context.padding.right) / 100));
                        const finalHeight = Math.round(context.originalHeight * (1 + (context.padding.top + context.padding.bottom) / 100));
                        const maskCanvas = document.createElement('canvas');
                        maskCanvas.width = finalWidth;
                        maskCanvas.height = finalHeight;
                        const maskCtx = maskCanvas.getContext('2d');
                        maskCtx.fillStyle = 'black';
                        maskCtx.fillRect(0, 0, finalWidth, finalHeight);
                        maskCtx.fillStyle = 'white';
                        maskCtx.fillRect(
                            Math.round(context.originalWidth * (context.padding.left / 100)),
                            Math.round(context.originalHeight * (context.padding.top / 100)),
                            context.originalWidth, context.originalHeight);
                        return {
                            mode: context.mode,
                            baseImage: originalImageDataUrl,
                            mask: maskCanvas.toDataURL('image/png')
                        };
                    }
                },

                actionHandlers: {
                    // 표준 AI 액션을 처리하는 헬퍼 함수
                    _executeStandardAIAction: async (context) => {
                        const strategy = context.aiPreparationStrategies[context.mode];
                        if (strategy) {
                            const modalAIActionData = await strategy(context);
                            await Alpine.store('app').executeModalAIAction(modalAIActionData);
                            context.reset();
                        } else {
                            throw new Error(`AI 전략을 찾을 수 없습니다: ${context.mode}`);
                        }
                    },
                    
                    // 표준 로컬(비-AI) 액션을 처리하는 헬퍼 함수
                    _executeStandardLocalAction: (context) => {
                        const dataUrl = context._exportCanvasAtOriginalResolution();
                        if (dataUrl) {
                            Alpine.store('app').addToImageStation(dataUrl, Alpine.store('app').generateFilename('gemini'));
                        }
                        context.reset();
                    },

                    // 모드별 핸들러
                    draw: async function(context) {
                        if (context.activeAISupport) {
                            await this._executeStandardAIAction(context);
                        } else {
                            this._executeStandardLocalAction(context);
                        }
                    },
                    refine: async function(context) {
                        if (context.refineState.activeAICorrection) {
                            await this._executeStandardAIAction(context);
                        } else {
                            this._executeStandardLocalAction(context);
                        }
                    },
                    inpaint: async function(context) {
                        await this._executeStandardAIAction(context);
                    },
                    outpaint: async function(context) {
                        await this._executeStandardAIAction(context);
                    },
                    infuse: async (context) => {
                        const promises = context.outputs.map(async (output) => {
                            const keywordText = output.attributes.map(keywordId => {
                                const keyword = Alpine.store('app').getKeywordById(keywordId);
                                return keyword ? keyword.keyword : '';
                            }).join(', ');
                            
                            if (!keywordText) {
                                return { outputId: output.id, result: null }; // 키워드가 없으면 건너뛰되, ID는 유지
                            }
                            
                            const finalPrompt = `Modify the provided image based on these instructions: ${keywordText}`;
                            const imageToSend = { dataUrl: context.baseImage };
                            const apiResult = await Alpine.store('app').callImageAPI(finalPrompt, [imageToSend]);
                            return { outputId: output.id, result: apiResult }; // 결과와 원본 ID를 함께 반환
                        });
                        
                        const results = (await Promise.all(promises)).filter(item => item.result);
                        const generatedImages = [];
                        
                        results.forEach(item => {
                            const imageData = item.result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            if (imageData) {
                                const newImageUrl = `data:image/png;base64,${imageData}`;
                                const newFilename = Alpine.store('app').generateFilename('gemini');
                                
                                generatedImages.push({ 
                                    outputId: item.outputId, 
                                    dataUrl: newImageUrl, 
                                    name: newFilename 
                                });
                            }
                        });

                        if (generatedImages.length > 0) {
                            context._displayInfuseResults(generatedImages);
                            generatedImages.forEach(img => {
                                Alpine.store('app').addToImageStation(img.dataUrl, img.name, false);
                            });
                            Alpine.store('app').showToast(`${generatedImages.length}개의 이미지를 생성하여 첨부했습니다.`);
                        } else {
                            Alpine.store('app').showToast(`생성된 이미지가 없습니다.`);
                        }
                    },
                    analyze: async (context) => {
                        await context.executeAnalyzeAction();
                    }
                },

                modeConfigs: {
                    draw:       { loadImage: true,  asBackground: true,  drawingMode: true,  selection: false, cursor: 'crosshair' },
                    refine:     { loadImage: true,  asBackground: false, drawingMode: false, selection: false, cursor: 'default' },
                    inpaint:    { loadImage: true,  asBackground: true,  drawingMode: true,  selection: false, cursor: 'crosshair' },
                    outpaint:   { loadImage: true,  asBackground: false, drawingMode: false, selection: false, cursor: 'default' },
                    infuse:     { loadImage: true,  asBackground: false, drawingMode: false, selection: false, cursor: 'default' },
                    analyze:    { loadImage: true,  asBackground: false, drawingMode: false, selection: false, cursor: 'default' }
                },
                
                initialModeStates: {
                    refineState: { brightness: 0, contrast: 0, saturation: 0, hue: 0, activeFilter: null, angle: 0, flipX: false, flipY: false, activeAICorrection: null },
                    brushSize: 20,
                    brushColor: '#000000',
                    activeAISupport: null,
                    inpaintPrompt: '',
                    maskMode: 'transform',
                    activeAspectRatioPreset: null,
                    padding: { top: 0, right: 0, bottom: 0, left: 0 },
                    outputCount: 1,
                    outputs: [{ id: 1, active: true, attributes: [] }],
                    infuseActiveTab: 'expression',
                    analyzeState: { activeTab: 'extract', isLoading: false, promptResult: '', keywordResult: [], expressionResult: null, commentResult: '', costumeResult: null, costumeSheetType: 'costume', zoom: 1 }
                },

                // =================================================================
                // 2. 계산된 속성 (Computed Properties)
                // =================================================================
                get title() {
                    return { draw: '🎨 그림 그리기', refine: '📸 이미지 보정', inpaint: '🖌️ 부분 수정', outpaint: '📐 캔버스 확장', infuse: '🧪 피사체 제어', analyze: '🔬 이미지 분석' }[this.mode] || '';
                },
                get currentImageIndex() {
                    const images = Alpine.store('app').imageStation.images;
                    const selectedId = Alpine.store('app').ui.selectedImageId;
                    return images.findIndex(img => img.id === selectedId);
                },
                get canNavigatePrevious() { return this.currentImageIndex > 0; },
                get canNavigateNext() {
                    const images = Alpine.store('app').imageStation.images;
                    return this.currentImageIndex > -1 && this.currentImageIndex < images.length - 1;
                },

                // =================================================================
                // 3. 중앙 제어 (Dispatchers & Initializers)
                // =================================================================
                init() {
                    this.$watch('$store.app.ui.activeModal', (newValue) => {
                        if (newValue === 'edit-canvas') {
                            this.$nextTick(() => this.initialize());
                        } else {
                            if (this.canvas) this.canvas.dispose();
                            this.canvas = null;
                        }
                    });
                    this.$watch('$store.app.ui.selectedImageId', (newId, oldId) => {
                        if (this.$store.app.ui.activeModal === 'edit-canvas' && newId !== oldId) {
                            this.switchMode(this.mode); // Reload content in the same mode
                        }
                    });
                    this.$watch('analyzeState.activeTab', () => {
                        // [MODIFIED] Only reset the loading state, preserving the results of each tab.
                        this.analyzeState.isLoading = false;
                    });
                },

                // [REFACTORED] initialize now only runs ONCE when the modal opens.
                initialize() {
                    this.$nextTick(() => {
                        const canvasEl = this.$refs.canvas;
                        if (!canvasEl) return;
                        const parent = canvasEl.parentElement;
                        const size = Math.min(parent.clientWidth, parent.clientHeight);
                        
                        this.canvas = new fabric.Canvas(this.$refs.canvas);
                        this.canvas.setDimensions({ width: size, height: size });

                        const initialMode = Alpine.store('app').ui.modalData.mode;
                        this.switchMode(initialMode);
                    });
                },

                // [NEW] switchMode is now the core logic for changing modes.
                switchMode(newMode) {
                    if (!this.canvas) return;
                    
                    // 1. Clean up the previous mode
                    this.cleanupCurrentMode();
                    
                    // 2. Set up the new mode
                    this.mode = newMode;
                    const config = this.modeConfigs[this.mode];
                    if (!config) return;

                    // 3. Reset all UI-related state variables
                    this.resetAllModeStates();

                    // 4. Apply new canvas settings from config
                    this.canvas.isDrawingMode = config.drawingMode;
                    this.canvas.selection = config.selection;
                    this.canvas.defaultCursor = config.cursor;
                    this.canvas.hoverCursor = config.cursor;

                    // 5. Load image if required
                    if (config.loadImage) {
                        const selectedImageUrl = Alpine.store('app').ui.generatedImageUrl;
                        if (selectedImageUrl) {
                            this._loadImage({ asBackground: config.asBackground, onComplete: () => this.onModeReady() });
                        } else {
                            this.onModeReady();
                        }
                    } else {
                        this.onModeReady();
                    }
                },
                
                // [NEW] Helper to clean up canvas and events
                cleanupCurrentMode() {
                    if (!this.canvas) return;

                    // [MODIFIED] Reset zoom and pan state to default before cleaning up
                    this.canvas.setZoom(1);
                    this.canvas.viewportTransform = [1, 0, 0, 1, 0, 0];

                    // Remove all objects
                    this.canvas.clear();
                    // Remove all event listeners attached in the previous mode
                    for (const eventName in this.activeListeners) {
                        this.canvas.off(eventName, this.activeListeners[eventName]);
                    }
                    this.activeListeners = {};
                    this.baseImage = null;
                    this.fabricImage = null;
                },

                onModeReady() {
                    this.updateBrush();
                    
                    if (this.mode === 'analyze' && this.baseImage) {
                        this.resetZoom();
                    }
                },
                
                resetAllModeStates() {
                    const initialStates = JSON.parse(JSON.stringify(this.initialModeStates));
                    Object.assign(this, initialStates);
                },

                reset() {
                    this.switchMode(this.mode);
                },

                async executeAction() {
                    const modesRequiringImage = ['refine', 'inpaint', 'outpaint', 'infuse', 'analyze'];
                    if (modesRequiringImage.includes(this.mode) && !this.baseImage) {
                        Alpine.store('app').showToast("이 작업을 수행하려면 먼저 이미지를 불러와야 합니다.");
                        return;
                    }
                    if (this.isLoading) return;
                    this.isLoading = true;

                    try {
                        const handler = this.actionHandlers[this.mode];
                        if (handler) {
                            // .call을 사용하여 핸들러 내부의 'this'가 actionHandlers 객체를 가리키도록 설정
                            await handler.call(this.actionHandlers, this); 
                        } else {
                            throw new Error(`액션 핸들러를 찾을 수 없습니다: ${this.mode}`);
                        }
                    } catch (error) {
                        console.error("Edit Canvas Action Error:", error);
                        Alpine.store('app').showToast(`작업 실패: ${error.message}`);
                    } finally {
                        this.isLoading = false;
                    }
                },

                _displayInfuseResults(generatedImages) {
                    if (!this.canvas || generatedImages.length === 0) return;

                    this.canvas.clear();
                    this.canvas.backgroundColor = '#1e2b3b';

                    const canvasWidth = this.canvas.width;
                    const canvasHeight = this.canvas.height;
                    const numImages = generatedImages.length;

                    let cols = numImages >= 2 ? 2 : 1;
                    let rows = numImages > 2 ? 2 : 1;
                    if (numImages === 2) rows = 1;

                    const cellWidth = canvasWidth / cols;
                    const cellHeight = canvasHeight / rows;

                    const imagePromises = generatedImages.map((imageInfo, index) => {
                        return new Promise(resolve => {
                            fabric.Image.fromURL(imageInfo.dataUrl, (img) => {
                                const scale = Math.min((cellWidth * 0.9) / img.width, (cellHeight * 0.9) / img.height);
                                img.scale(scale);
                                
                                const col = index % cols;
                                const row = Math.floor(index / cols);
                                
                                const left = (col * cellWidth) + (cellWidth - img.getScaledWidth()) / 2;
                                const top = (row * cellHeight) + (cellHeight - img.getScaledHeight()) / 2;

                                img.set({ left, top, selectable: false, evented: false });

                                const textBg = new fabric.Rect({
                                    width: 30, height: 30, fill: 'rgba(0,0,0,0.6)',
                                    rx: 5, ry: 5, left: left + 5, top: top + 5,
                                    selectable: false, evented: false
                                });
                                
                                const numberText = new fabric.Text(String(imageInfo.outputId), {
                                    fontSize: 20, fill: '#fff', fontFamily: 'Inter, sans-serif',
                                    left: left + 5 + 15, top: top + 5 + 15,
                                    originX: 'center', originY: 'center',
                                    selectable: false, evented: false
                                });

                                resolve([img, textBg, numberText]);
                            }, { crossOrigin: 'anonymous' });
                        });
                    });

                    Promise.all(imagePromises).then(objects => {
                        const validObjects = objects.filter(Boolean);
                        validObjects.forEach(objGroup => objGroup.forEach(obj => this.canvas.add(obj)));
                        this.canvas.renderAll();
                    });
                },
                
                handleResize() {
                    if (this.mode === 'draw' && !this.baseImage && this.canvas) {
                        const wrapper = this.$refs.canvasWrapper;
                        if (wrapper) {
                            this.canvas.setDimensions({ width: wrapper.clientWidth, height: wrapper.clientHeight });
                        }
                    }
                },
                _exportCanvasAtOriginalResolution() {
                    if (!this.canvas) return null;

                    if (['draw', 'refine', 'inpaint', 'outpaint', 'infuse'].includes(this.mode) && this.fabricImage && this.fabricImage.scaleX > 0) {
                        const multiplier = 1 / this.fabricImage.scaleX;
                        return this.canvas.toDataURL({ format: 'png', multiplier: multiplier });
                    }
                    
                    return this.canvas.toDataURL({ format: 'png' });
                },
                _loadImage(options = {}) {
                    const { imageUrlToLoad = null, asBackground = false, onComplete = () => {} } = options;
                    
                    const imageUrl = imageUrlToLoad || Alpine.store('app').ui.generatedImageUrl;
                    if (!imageUrl) {
                        if (this.mode === 'draw') {
                             if (onComplete) onComplete();
                        }
                        return;
                    }

                    this.baseImage = imageUrl;
                    if (!this.canvas) return;
                    this.canvas.clear();
                    this.canvas.backgroundColor = 'transparent';

                    fabric.Image.fromURL(imageUrl, (img) => {
                        this.fabricImage = img;
                        const canvasWrapper = this.$refs.canvasWrapper;
                        const containerSize = Math.min(canvasWrapper.clientWidth, canvasWrapper.clientHeight);
                        
                        const scale = Math.min(containerSize / img.width, containerSize / img.height);
                        
                        const canvasWidth = img.width * scale;
                        const canvasHeight = img.height * scale;
                        this.canvas.setDimensions({ width: canvasWidth, height: canvasHeight });
                        
                        img.scale(scale);
                        img.set({ selectable: false, evented: false });
                        
                        this.canvas.add(img);
                        img.center();
                        
                        if (asBackground) {
                            this.canvas.sendToBack(img);
                        }

                        this.originalImage = img.getElement();
                        this.originalWidth = img.width;
                        this.originalHeight = img.height;
                        
                        this.canvas.renderAll();
                        if (onComplete) onComplete();

                    }, { crossOrigin: 'anonymous' });
                },

                _updateStateAndApply(updates, type = 'transform') {
                    if (!this.fabricImage) return;
                    Object.assign(this.refineState, updates);
                    if (type === 'transform') this.applyTransforms();
                    else if (type === 'filter') this.applyRefineFilters();
                },
                
                updateBrush() {
                    if (!this.canvas || !this.canvas.freeDrawingBrush) return;
                    const brush = this.canvas.freeDrawingBrush;
                    if (this.mode === 'draw') {
                        brush.color = this.brushColor;
                    } else if (this.mode === 'inpaint') {
                        brush.color = 'rgba(255, 0, 255, 0.5)';
                    }
                    brush.width = parseInt(this.brushSize, 10) || 1;
                },

                // --- REFINE MODE FUNCTIONS ---
                rotateImage(degrees) {
                    const newAngle = (this.refineState.angle + degrees) % 360;
                    this._updateStateAndApply({ angle: newAngle }, 'transform');
                },
                flipImage(axis) {
                    if (axis === 'X') {
                        this._updateStateAndApply({ flipX: !this.refineState.flipX }, 'transform');
                    } else if (axis === 'Y') {
                        this._updateStateAndApply({ flipY: !this.refineState.flipY }, 'transform');
                    }
                },
                applyTransforms() {
                    if (!this.canvas || !this.fabricImage) return;
                    this.fabricImage.set({
                        angle: this.refineState.angle,
                        flipX: this.refineState.flipX,
                        flipY: this.refineState.flipY
                    });
                    this.fabricImage.center();
                    this.canvas.renderAll();
                },
                applyRefineFilters() {
                    if (!this.canvas || !this.fabricImage) return;
                    this.fabricImage.filters = [];
                    const state = this.refineState;
                    switch(state.activeFilter) {
                        case 'grayscale': this.fabricImage.filters.push(new fabric.Image.filters.Grayscale()); break;
                        case 'sepia': this.fabricImage.filters.push(new fabric.Image.filters.Sepia()); break;
                        case 'invert': this.fabricImage.filters.push(new fabric.Image.filters.Invert()); break;
                        case 'blur': this.fabricImage.filters.push(new fabric.Image.filters.Blur({ blur: 0.15 })); break;
                    }
                    if (state.brightness !== 0) this.fabricImage.filters.push(new fabric.Image.filters.Brightness({ brightness: state.brightness }));
                    if (state.contrast !== 0) this.fabricImage.filters.push(new fabric.Image.filters.Contrast({ contrast: state.contrast }));
                    if (state.saturation !== 0) this.fabricImage.filters.push(new fabric.Image.filters.Saturation({ saturation: state.saturation }));
                    if (state.hue !== 0) this.fabricImage.filters.push(new fabric.Image.filters.HueRotation({ rotation: state.hue }));
                    this.fabricImage.applyFilters();
                    this.canvas.renderAll();
                },
                handleFilterChange() {
                    this._updateStateAndApply({}, 'filter');
                },
                
                setInpaintPreset(type) {
                    if (type === 'remove') {
                        this.inpaintPrompt = 'remove any text or other distracting overlays from the marked area, seamlessly blending it with the surrounding background.';
                    } else if (type === 'fix') {
                        this.inpaintPrompt = 'identify the incorrect body structure(such as too many fingers and toes, added arms and legs, or unnatural joints) in the marked area and redraw it into a universal and natural form.';
                    }
                },
                
                toggleAspectRatioPreset(ratioStr) {
                    if (this.activeAspectRatioPreset === ratioStr) {
                        this.activeAspectRatioPreset = null;
                        this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
                    } else {
                        this.activeAspectRatioPreset = ratioStr;
                        if (!this.originalWidth || !this.originalHeight) return;
                        const [targetW, targetH] = ratioStr.split(':').map(Number);
                        const targetAspectRatio = targetW / targetH;
                        const currentAspectRatio = this.originalWidth / this.originalHeight;
                        this.padding = { top: 0, right: 0, bottom: 0, left: 0 };
                        if (Math.abs(targetAspectRatio - currentAspectRatio) < 0.01) {
                            this.updateExpansionState();
                            return;
                        }
                        if (targetAspectRatio > currentAspectRatio) {
                            const newTotalWidth = this.originalHeight * targetAspectRatio;
                            const totalHorizontalPadding = newTotalWidth - this.originalWidth;
                            const horizontalPaddingPercent = (totalHorizontalPadding / this.originalWidth) * 100;
                            this.padding.left = horizontalPaddingPercent / 2;
                            this.padding.right = horizontalPaddingPercent / 2;
                        } else {
                            const newTotalHeight = this.originalWidth / targetAspectRatio;
                            const totalVerticalPadding = newTotalHeight - this.originalHeight;
                            const verticalPaddingPercent = (totalVerticalPadding / this.originalHeight) * 100;
                            this.padding.top = verticalPaddingPercent / 2;
                            this.padding.bottom = verticalPaddingPercent / 2;
                        }
                    }
                    this.updateExpansionState();
                },
                drawPreview() {
                    if (!this.canvas || !this.fabricImage) return;
                    const container = this.$refs.canvasWrapper;
                    const containerSize = Math.min(container.clientWidth, container.clientHeight);
                    const totalWidth = this.originalWidth * (1 + (this.padding.left + this.padding.right) / 100);
                    const totalHeight = this.originalHeight * (1 + (this.padding.top + this.padding.bottom) / 100);
                    const paddedAspectRatio = totalWidth / totalHeight;
                    let canvasWidth, canvasHeight;
                    if (paddedAspectRatio > 1) {
                        canvasWidth = containerSize;
                        canvasHeight = containerSize / paddedAspectRatio;
                    } else {
                        canvasHeight = containerSize;
                        canvasWidth = containerSize * paddedAspectRatio;
                    }
                    this.canvas.setDimensions({ width: canvasWidth, height: canvasHeight });
                    this.canvas.clear();
                    this.canvas.backgroundColor = 'rgba(128, 128, 128, 0.4)';
                    const imageScale = canvasWidth / totalWidth;
                    this.fabricImage.set({
                        scaleX: imageScale, scaleY: imageScale,
                        left: (this.padding.left / 100) * this.originalWidth * imageScale,
                        top: (this.padding.top / 100) * this.originalHeight * imageScale
                    });
                    this.canvas.add(this.fabricImage).renderAll();
                },
                updateExpansionState(activeSide = null) {
                    if (activeSide) this.activeAspectRatioPreset = null;
                    if (!this.originalWidth) return;
                    const originalArea = this.originalWidth * this.originalHeight;
                    const maxTotalArea = originalArea * 2.0;
                    const maxSliderValue = 100;
                    const maxPaddings = {};
                    ['top', 'right', 'bottom', 'left'].forEach(side => {
                        const otherHorizontal = side === 'left' ? this.padding.right : this.padding.left;
                        const otherVertical = side === 'top' ? this.padding.bottom : this.padding.top;
                        let maxBudget = maxSliderValue;
                        if (['left', 'right'].includes(side)) {
                            const currentTotalHeight = this.originalHeight * (1 + (this.padding.top + this.padding.bottom) / 100);
                            if (currentTotalHeight > 0) {
                                const maxTotalWidth = maxTotalArea / currentTotalHeight;
                                const totalHorizontalPaddingPercent = ((maxTotalWidth / this.originalWidth) - 1) * 100;
                                maxBudget = totalHorizontalPaddingPercent - otherHorizontal;
                            } else { maxBudget = 0; }
                        } else {
                            const currentTotalWidth = this.originalWidth * (1 + (this.padding.left + this.padding.right) / 100);
                            if (currentTotalWidth > 0) {
                                const maxTotalHeight = maxTotalArea / currentTotalWidth;
                                const totalVerticalPaddingPercent = ((maxTotalHeight / this.originalHeight) - 1) * 100;
                                maxBudget = totalVerticalPaddingPercent - otherVertical;
                            } else { maxBudget = 0; }
                        }
                        maxPaddings[side] = Math.max(0, Math.min(maxSliderValue, maxBudget));
                    });
                    if (activeSide && this.padding[activeSide] > maxPaddings[activeSide]) this.padding[activeSide] = maxPaddings[activeSide];
                    const linearWidthExpansion = this.originalWidth * (this.padding.left + this.padding.right) / 100;
                    const linearHeightExpansion = this.originalHeight * (this.padding.top + this.padding.bottom) / 100;
                    const linearExpandedArea = linearWidthExpansion * this.originalHeight + linearHeightExpansion * this.originalWidth;
                    const currentWidth = this.originalWidth * (1 + (this.padding.left + this.padding.right) / 100);
                    const currentHeight = this.originalHeight * (1 + (this.padding.top + this.padding.bottom) / 100);
                    const currentTotalArea = currentWidth * currentHeight;
                    const actualExpandedArea = currentTotalArea - originalArea;
                    const cornerArea = actualExpandedArea - linearExpandedArea;
                    this.cornerBudgetConsumption = (cornerArea / (maxTotalArea - originalArea)) * 100;
                    const budgetUsedPercent = (actualExpandedArea / (maxTotalArea - originalArea)) * 100;
                    this.expansionBudgetPercent = Math.max(0, 100 - budgetUsedPercent);
                    if (currentWidth > 0 && currentHeight > 0) {
                        const aspectRatio = currentWidth / currentHeight;
                        const totalPixels = 1024 * 1024;
                        const scaledHeight = Math.round(Math.sqrt(totalPixels / aspectRatio));
                        const scaledWidth = Math.round(aspectRatio * scaledHeight);
                        this.scaledResolution = `${scaledWidth}x${scaledHeight}`;
                    }
                    this.drawPreview();
                },

                // --- INFUSE MODE FUNCTIONS ---
                addRemoveAttribute(keywordId) {
                    const activeOutput = this.outputs.find(o => o.active);
                    if (!activeOutput) return;

                    const masterTable = Alpine.store('app').infuseMasterTable;
                    let categoryKey = null;
                    for (const key in masterTable) {
                        if (masterTable[key].recipes.some(r => r.keywordId === keywordId)) {
                            categoryKey = key;
                            break;
                        }
                    }
                    if (!categoryKey) return;

                    const categoryRecipes = masterTable[categoryKey].recipes.map(r => r.keywordId);
                    const existingAttrInSameCategory = activeOutput.attributes.find(id => categoryRecipes.includes(id));

                    if (existingAttrInSameCategory === keywordId) {
                        activeOutput.attributes = activeOutput.attributes.filter(id => id !== keywordId);
                    } else {
                        if (existingAttrInSameCategory) {
                             activeOutput.attributes = activeOutput.attributes.filter(id => id !== existingAttrInSameCategory);
                        }
                        activeOutput.attributes.push(keywordId);
                    }
                },
                updateOutputs() {
                    this.outputs = Array.from({ length: this.outputCount }, (_, i) => {
                        const existing = this.outputs[i];
                        if (existing) {
                            return { ...existing, active: i === 0 };
                        } else {
                            return { id: i + 1, active: i === 0, attributes: [] };
                        }
                    });
                },
                getInfuseDisplay(keywordId) {
                    const masterTable = Alpine.store('app').infuseMasterTable;
                    for (const category of Object.values(masterTable)) {
                        const recipe = category.recipes.find(r => r.keywordId === keywordId);
                        if (recipe) return recipe.display;
                    }
                    return '?';
                },

                // --- ANALYZE MODE FUNCTIONS ---
                setZoom(level) {
                    if (!this.canvas || !this.fabricImage) return;
                    let newZoom = parseFloat(level);
                    if (newZoom < 1) newZoom = 1;
                    if (newZoom > 5) newZoom = 5;
                    this.analyzeState.zoom = newZoom;
                    
                    this.canvas.zoomToPoint(new fabric.Point(this.canvas.width / 2, this.canvas.height / 2), newZoom);
                    
                    this.panCanvas(null); // Clamp viewport after zooming
                    this.canvas.renderAll();
                },
                resetZoom() {
                    this.analyzeState.zoom = 1; 
                    if (!this.canvas || !this.fabricImage) return;
                    
                    this.canvas.setZoom(1);
                    
                    const vpt = this.canvas.viewportTransform;
                    vpt[4] = (this.canvas.width - this.fabricImage.getScaledWidth()) / 2;
                    vpt[5] = (this.canvas.height - this.fabricImage.getScaledHeight()) / 2;
                    this.canvas.requestRenderAll();
                },
                panCanvas(direction) {
                    if (!this.canvas || !this.fabricImage) return;

                    if (this.analyzeState.zoom <= 1 && direction) return;

                    const vpt = this.canvas.viewportTransform;
                    const panAmount = 50;
                    
                    const currentWidth = this.fabricImage.getScaledWidth() * this.canvas.getZoom();
                    const currentHeight = this.fabricImage.getScaledHeight() * this.canvas.getZoom();

                    const rightBound = this.canvas.width - currentWidth;
                    const bottomBound = this.canvas.height - currentHeight;

                    if (direction) {
                        if (direction === 'up') vpt[5] += panAmount;
                        if (direction === 'down') vpt[5] -= panAmount;
                        if (direction === 'left') vpt[4] += panAmount;
                        if (direction === 'right') vpt[4] -= panAmount;
                    }

                    if (vpt[4] > 0) vpt[4] = 0;
                    if (vpt[5] > 0) vpt[5] = 0;
                    if (vpt[4] < rightBound) vpt[4] = rightBound;
                    if (vpt[5] < bottomBound) vpt[5] = bottomBound;

                    this.canvas.requestRenderAll();
                },
            async executeAnalyzeAction() {
                this.analyzeState.isLoading = true; 
                try {
                    const appStore = Alpine.store('app');
                    const imageToSend = { dataUrl: this.baseImage };
                    const actionType = this.analyzeState.activeTab;
                    
                    if (actionType === 'extract') {
                        const systemPrompt = "You are a world-class prompt engineer. Analyze the provided image and generate a detailed, descriptive English prompt that could create a similar image. Also, extract 5-7 relevant keywords as hashtags. The response must be a single JSON object with two keys: 'generatedPrompt' (string) and 'keywords' (array of strings).";
                        const userQuery = "Analyze this image and provide a generative prompt and keywords in JSON format.";
                        const jsonString = await appStore.callMultimodalTextAPI(systemPrompt, userQuery, [imageToSend]);
                        const result = JSON.parse(jsonString);
                        this.analyzeState.promptResult = result.generatedPrompt || '프롬프트를 추출하지 못했습니다.';
                        
                        const keywords = result.keywords || [];
                        this.analyzeState.keywordResult = keywords.map(k => appStore._toTitleCase(k));

                    } else if (actionType === 'expression') {
                        const systemPrompt = "You are an expert in facial expression analysis. Analyze the main subject's face in the image based on these eight emotions: neutral, joy, sadness, anger, fear, surprise, contempt, and disgust. Provide a score from 0.0 to 1.0 for each. Also, provide a one-paragraph situational commentary in Korean. The response must be a single JSON object with two keys: 'expressionAnalysis' (an object with emotion scores) and 'situationalCommentary' (a string).";
                        const userQuery = "Analyze the facial expression and situation in this image and provide the results in JSON format.";
                        const jsonString = await appStore.callMultimodalTextAPI(systemPrompt, userQuery, [imageToSend]);
                        const result = JSON.parse(jsonString);

                        this.analyzeState.expressionResult = result.expressionAnalysis || null;
                        this.analyzeState.commentResult = result.situationalCommentary || '코멘트를 생성하지 못했습니다.';

                        if (this.analyzeState.expressionResult) {
                            try {
                                const resultImageUrl = await this._createAnalysisResultImage(
                                    this.baseImage,
                                    this.analyzeState.expressionResult,
                                    this.analyzeState.commentResult,
                                    this.emotionDisplayOrder
                                );
                                const filename = `analysis-${Date.now()}.png`;
                                appStore.addToImageStation(resultImageUrl, filename, false);
                                appStore.showToast("분석 결과 이미지를 스테이션에 추가했습니다.");
                            } catch (imgError) {
                                console.error("Failed to create analysis image:", imgError);
                                appStore.showToast("분석 결과 이미지 생성에 실패했습니다.");
                            }
                        }

                    } else if (actionType === 'costume') {
                        let prompt;
                        if (this.analyzeState.costumeSheetType === 'character') {
                            prompt = "Analyze the character in the image. Create a 'character sheet' that includes a full-body view from the front, side, and back. Maintain a consistent art style and character design across all views, and present it on a clean white background.";
                        } else {
                            prompt = "Analyze the clothing and accessories worn by the person in the image. Isolate each item and arrange them neatly on a clean, white background to create a 'costume sheet'.";
                        }
                        const result = await appStore.callImageAPI(prompt, [imageToSend]);
                        const imageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                        if (imageData) {
                            const newImageUrl = `data:image/png;base64,${imageData}`;
                            this.analyzeState.costumeResult = newImageUrl;
                            const newFilename = `sheet-${Date.now()}.png`;
                            appStore.addToImageStation(newImageUrl, newFilename, false);
                            appStore.showToast("시트를 생성하여 스테이션에 추가했습니다.");
                        } else {
                            throw new Error("AI가 시트를 생성하지 못했습니다.");
                        }
                    }
                } catch (error) {
                    Alpine.store('app').showToast(`분석 실패: ${error.message}`);
                } finally {
                    this.analyzeState.isLoading = false;
                }
            },

            sortAttributes(attributes) {
                const masterTable = Alpine.store('app').infuseMasterTable;
                const categoryOrder = Object.keys(masterTable);

                const getCategory = (id) => {
                    for (const key of categoryOrder) {
                        if (masterTable[key].recipes.some(r => r.keywordId === id)) {
                            return key;
                        }
                    }
                    return null;
                };

                return [...attributes].sort((a, b) => {
                    const categoryA = getCategory(a);
                    const categoryB = getCategory(b);
                    return categoryOrder.indexOf(categoryA) - categoryOrder.indexOf(categoryB);
                });
            },
            
            _wrapText(context, text, maxWidth, fontSize, fontFace) {
                context.font = `${fontSize}px ${fontFace}`;
                if(!text) return [''];
                const words = text.split(' ');
                let lines = [];
                let currentLine = words[0] || '';

                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = context.measureText(currentLine + " " + word).width;
                    if (width < maxWidth) {
                        currentLine += " " + word;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
                return lines;
            },

            _drawRoundRect(ctx, x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                if (width <= 0 || height <= 0) return;
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + width, y, x + width, y + height, radius);
                ctx.arcTo(x + width, y + height, x, y + height, radius);
                ctx.arcTo(x, y + height, x, y, radius);
                ctx.arcTo(x, y, x + width, y, radius);
                ctx.closePath();
                ctx.fill();
            },

            _createAnalysisResultImage(baseImageUrl, expressionResult, commentResult, emotionOrder) {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    const width = 1080;
                    const padding = 10;
                    const contentWidth = width - padding * 2;
                    
                    const colorMap = {
                        'bg-slate-500': '#64748b', 'bg-amber-400': '#facc15', 'bg-blue-500': '#3b82f6',
                        'bg-red-500': '#ef4444', 'bg-violet-500': '#8b5cf6', 'bg-orange-500': '#f97316',
                        'bg-amber-800': '#92400e', 'bg-green-500': '#22c55e'
                    };

                    const lineHeight = 40;
                    const graphHeight = 50;
                    const sectionSpacing = 20;
                    const commentLines = this._wrapText(ctx, commentResult, contentWidth - 80, 26, '"Noto Sans KR", sans-serif');
                    
                    const analysisSectionHeight = 50 + (graphHeight * emotionOrder.length) + 30;
                    const commentSectionHeight = 50 + (commentLines.length * lineHeight) + 30;
                    
                    const fixedVerticalSpace = (padding * 2) + 40 + sectionSpacing * 2 + analysisSectionHeight + commentSectionHeight;
                    const thumbnailHeight = 1350 - fixedVerticalSpace;
                    const totalHeight = 1350;

                    canvas.width = width;
                    canvas.height = totalHeight;
                    
                    ctx.fillStyle = '#4285F4'; // Gemini Blue
                    ctx.fillRect(0, 0, width, totalHeight);
                    
                    ctx.fillStyle = 'white';
                    this._drawRoundRect(ctx, padding, padding, contentWidth, totalHeight - padding * 2, 15);

                    let currentY = padding;

                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        ctx.save();
                        const thumbX = padding + 20;
                        const thumbY = currentY + 20;
                        const thumbAreaWidth = contentWidth - 40;
                        const thumbAreaHeight = thumbnailHeight - 20;
                        this._drawRoundRect(ctx, thumbX, thumbY, thumbAreaWidth, thumbAreaHeight, 10);
                        ctx.strokeStyle = '#e2e8f0';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.clip();

                        const thumbRatio = Math.min(thumbAreaWidth / img.width, thumbAreaHeight / img.height);
                        const thumbW = img.width * thumbRatio;
                        const thumbH = img.height * thumbRatio;
                        ctx.drawImage(img, thumbX + (thumbAreaWidth - thumbW) / 2, thumbY + (thumbAreaHeight - thumbH) / 2, thumbW, thumbH);
                        ctx.restore();

                        currentY += thumbnailHeight;
                        currentY += sectionSpacing;

                        const analysisBoxX = padding + 20;
                        const analysisBoxY = currentY;
                        const analysisBoxWidth = contentWidth - 40;
                        
                        ctx.fillStyle = '#f8fafc'; // slate-50 background
                        this._drawRoundRect(ctx, analysisBoxX, analysisBoxY, analysisBoxWidth, analysisSectionHeight, 10);
                        ctx.fill();
                        ctx.strokeStyle = '#e2e8f0';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        let innerY = analysisBoxY + 40; 
                        ctx.font = 'bold 32px Inter, sans-serif';
                        ctx.fillStyle = '#1e293b';
                        ctx.fillText('표정 분석 결과', analysisBoxX + 20, innerY);
                        innerY += 40; 

                        emotionOrder.forEach(emotion => {
                            const score = (expressionResult && expressionResult[emotion.key]) !== undefined ? expressionResult[emotion.key] : 0;
                            
                            ctx.font = '26px Inter, sans-serif';
                            ctx.fillStyle = '#475569';
                            ctx.textAlign = 'left';
                            ctx.fillText(emotion.label, analysisBoxX + 20, innerY + 24);

                            const barX = analysisBoxX + 180;
                            const barWidth = analysisBoxWidth - 300; 
                            
                            ctx.fillStyle = '#e2e8f0';
                            this._drawRoundRect(ctx, barX, innerY, barWidth, 36, 18);
                            
                            ctx.fillStyle = colorMap[emotion.color] || '#64748b';
                            this._drawRoundRect(ctx, barX, innerY, barWidth * score, 36, 18);

                            ctx.fillStyle = '#334155';
                            ctx.textAlign = 'right';
                            ctx.font = 'bold 26px Inter, sans-serif';
                            ctx.fillText(`${(score * 100).toFixed(0)}%`, analysisBoxX + analysisBoxWidth - 20, innerY + 24);

                            innerY += graphHeight;
                        });

                        currentY += analysisSectionHeight + sectionSpacing;
                        
                        const commentBoxX = padding + 20;
                        const commentBoxY = currentY;
                        const commentBoxWidth = contentWidth - 40;
                        
                        ctx.fillStyle = '#f8fafc'; // slate-50 background
                        this._drawRoundRect(ctx, commentBoxX, commentBoxY, commentBoxWidth, commentSectionHeight, 10);
                        ctx.fill();
                        ctx.strokeStyle = '#e2e8f0';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        innerY = commentBoxY + 40;
                        ctx.font = 'bold 32px Inter, sans-serif';
                        ctx.fillStyle = '#1e293b';
                        ctx.textAlign = 'left';
                        ctx.fillText('해석', commentBoxX + 20, innerY);
                        innerY += 40;

                        ctx.fillStyle = '#334155';
                        ctx.font = '26px "Noto Sans KR", sans-serif';
                        commentLines.forEach(line => {
                            ctx.fillText(line, commentBoxX + 20, innerY);
                            innerY += lineHeight;
                        });

                        resolve(canvas.toDataURL('image/png'));
                    };
                    img.onerror = reject;
                    img.src = baseImageUrl;
                });
            },
            
            async saveKeywordsToLibrary() {
                const appStore = Alpine.store('app');
                const keywordsToSave = this.analyzeState.keywordResult;

                if (!keywordsToSave || keywordsToSave.length === 0) {
                    appStore.showToast("저장할 키워드가 없습니다.");
                    return;
                }

                const groupName = "이미지 분석";
                const tabName = "분석01";

                let targetGroup = appStore.keywordLibrary.userGroups.find(g => g.name === groupName);
                if (!targetGroup) {
                    const newGroup = {
                        id: 'user-' + Date.now() + Math.random(),
                        name: groupName,
                        keywords: [],
                        collapsed: false,
                        isDefault: false,
                        activeTab: tabName,
                        tabs: []
                    };
                    appStore.keywordLibrary.userGroups.unshift(newGroup);
                    targetGroup = newGroup;
                }

                let targetTab = targetGroup.tabs.find(t => t.name === tabName);
                if (!targetTab) {
                    const newTab = { name: tabName, keywordIds: [] };
                    targetGroup.tabs.push(newTab);
                    targetTab = newTab;
                }

                const newKeywords = [];
                const newKeywordIds = [];

                keywordsToSave.forEach(keywordStr => {
                    const newKeyword = {
                        id: 'user-' + Date.now() + Math.random(),
                        type: 'keyword',
                        keyword: keywordStr,
                        desc: '_',
                        isCustom: true
                    };
                    newKeywords.push(newKeyword);
                    newKeywordIds.push(newKeyword.id);
                });

                targetGroup.keywords.unshift(...newKeywords);
                targetTab.keywordIds.unshift(...newKeywordIds);

                appStore.saveState(false);
                appStore.showToast(`'${groupName}' 그룹에 키워드 ${newKeywords.length}개를 저장했습니다.`);
            }
        }));

            Alpine.store('app').loadState();
        });
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        body { font-family: 'Inter', 'Noto Sans KR', sans-serif; }
        .material-symbols-outlined { vertical-align: middle; font-variation-settings: 'FILL' 0, 'wght' 200, 'GRAD' 0, 'opsz' 24; }
        .toast { min-width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 8px; padding: 16px; position: fixed; z-index: 10000; left: 50%; bottom: 50px; transform: translateX(-50%); transition: all 0.5s; }
        .spinner { animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .library-item .item-controls { opacity: 0; }
        .library-item:hover .item-controls { opacity: 1; }

        .library-item { transition: all 0.2s ease-in-out; }
        .library-item.selected-in-promptBoard {
            background-color: #dbeafe !important; /* blue-200 */
        }
        .library-item:not(.selected-in-promptBoard):hover { background-color: #f0f9ff; }
        
        .keyword-tab { transition: all 0.2s ease-in-out; }
        .keyword-tab.active { border-color: #3b82f6; background-color: #3b82f6; color: white; }
        
        .promptBoard-area { transition: all 0.2s ease-in-out; border: 2px dashed transparent; }
        
        .prompt-keyword:hover .remove-keyword-btn { opacity: 1; }
        .remove-keyword-btn { opacity: 0; transition: opacity 0.2s; }
        .toggle-icon { transition: transform 0.2s ease-in-out; }
        .group-container.collapsed .toggle-icon { transform: rotate(-90deg); }
        .group-content { transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.3s; max-height: 1000px; overflow: hidden; opacity: 1;}
        .group-container.collapsed .group-content { max-height: 0; padding-top: 0; padding-bottom: 0; opacity: 0;}
        
        #image-result-container .loader { width: 50px; height: 50px; border-radius: 50%; display: inline-block; border-top: 5px solid #3498db; border-right: 5px solid transparent; box-sizing: border-box; animation: spin 1s linear infinite; }
        .thumbnail-item .remove-img-btn { opacity: 0; transition: opacity 0.2s; }
        .thumbnail-item:hover .remove-img-btn { opacity: 1; }
        .modal-backdrop { transition: opacity 0.3s ease-in-out; }
        .interactive-panel { transform: translateY(10px); transition: transform 0.3s ease-out, opacity 0.3s ease-out; }
        
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: #3b82f6; } /* blue-500 */
        input:checked + .toggle-slider:before { transform: translateX(22px); }
        #edit-canvas { z-index: 60; }
        #manual-prompt-textarea { min-height: 80px; resize: vertical; overflow-y: auto; }
        .interactive-btn { background-color: transparent; border-radius: 9999px; padding: 0.25rem; transition: all 0.2s ease-in-out; margin: 1px; }
        .interactive-btn:hover { background-color: rgba(255, 255, 255, 0.2); transform: scale(1.1); }
        .interactive-btn.selected { background-color: rgba(46, 213, 115, 0.3); outline: 2px solid #2ed573; }
        .group-header .group-controls { opacity: 0; transition: opacity 0.2s ease-in-out; }
        .group-header:hover .group-controls { opacity: 1; }

        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800"
    x-data="{ isMobile: window.innerWidth < 768 }"
    @resize.window="isMobile = window.innerWidth < 768"
    x-init="
        $watch('$store.app.keywordLibrary.searchTerm', (newValue, oldValue) => {
            const store = $store.app;
            const allGroups = [...store.keywordLibrary.defaultGroups, ...store.keywordLibrary.userGroups];
            
            if (newValue && !oldValue) { // Search starts
                store.keywordLibrary.preSearchCollapsedState = allGroups.reduce((acc, group) => {
                    acc[group.id] = group.collapsed;
                    return acc;
                }, {});
                 store.keywordLibrary.preSearchActiveTabState = allGroups.reduce((acc, group) => {
                    acc[group.id] = group.activeTab;
                    return acc;
                }, {});
            }

            if (newValue) { // While searching: Centralized logic to avoid race conditions
                const termLower = newValue.toLowerCase();
                allGroups.forEach(group => {
                    let isGroupVisible = false;
                    let matchingTabName = null;

                    const groupName = group.isDefault ? { subject: '주제', details: '세부 묘사', style: '표현 기법', composition: '구도' }[group.id] : group.name;
                    if (groupName && groupName.toLowerCase().includes(termLower)) {
                        isGroupVisible = true;
                    }
                    
                    for (const tab of group.tabs) {
                        let tabContainsResult = false;
                        if (tab.name.toLowerCase().includes(termLower)) {
                            tabContainsResult = true;
                        } else {
                            tabContainsResult = tab.keywordIds.some(id => {
                                const keyword = group.keywords.find(k => k.id === id);
                                return keyword && (
                                    keyword.keyword.toLowerCase().includes(termLower) || 
                                    (keyword.desc && keyword.desc.toLowerCase().includes(termLower))
                                );
                            });
                        }
                        if (tabContainsResult) {
                            isGroupVisible = true;
                            if (!matchingTabName) { // Set only the first matching tab
                                matchingTabName = tab.name;
                            }
                        }
                    }

                    if (isGroupVisible) {
                        group.collapsed = false;
                        if (matchingTabName) {
                            group.activeTab = matchingTabName;
                        }
                    }
                });
            } else if (!newValue && oldValue) { // Search ends
                allGroups.forEach(group => {
                    if (store.keywordLibrary.preSearchCollapsedState && store.keywordLibrary.preSearchCollapsedState.hasOwnProperty(group.id)) {
                        group.collapsed = store.keywordLibrary.preSearchCollapsedState[group.id];
                    }
                    if (store.keywordLibrary.preSearchActiveTabState && store.keywordLibrary.preSearchActiveTabState.hasOwnProperty(group.id)) {
                        group.activeTab = store.keywordLibrary.preSearchActiveTabState[group.id];
                    }
                });
                store.keywordLibrary.preSearchCollapsedState = null;
                store.keywordLibrary.preSearchActiveTabState = null;
            }
        });
        $watch('$store.app.isPromptBoardEmpty', (isEmpty) => {
            $store.app.ui.isPromptBoardCollapsed = isEmpty;
        });
        $watch('$store.app.ui.selectedImageId', (newId) => {
            const store = $store.app;
            if (newId) {
                const selectedImage = store.imageStation.images.find(img => img.id === newId);
                if (selectedImage) {
                    store.updateImageInfo(selectedImage);
                }
            } else {
                store.ui.currentImageInfo = { name: '', resolution: '', size: '' };
            }
        });
        $watch('$store.app.settings.generationModel', (newValue) => {
            const settings = $store.app.settings;
            if (newValue === 'gemini') {
                settings.numberOfImages = 1;
            }
        });
    ">

    <div class="container mx-auto p-4 sm:p-6 max-w-7xl">
        <header class="flex justify-between items-center mb-6 sm:mb-8">
            <div class="w-10"></div>
            <div class="text-center">
                <!-- Responsive Font Size for Title -->
                <h1 class="text-3xl sm:text-5xl font-bold text-slate-900">✨ 세빛 스튜디오</h1>
            </div>
            <button id="settings-btn" class="text-slate-500 hover:text-blue-600 transition-colors w-10 h-10 flex items-center justify-center" title="설정" @click="$store.app.openModal('settings-modal')">
                <span class="material-symbols-outlined text-3xl">settings</span>
            </button>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <div 
                x-data="{ isAdding: false }"
                class="lg:col-span-1 bg-white p-4 sm:p-6 rounded-2xl shadow-lg flex flex-col"
                >
                <div class="flex justify-between items-center mb-4 border-b pb-2 border-slate-200">
                    <h2 class="text-xl sm:text-2xl font-bold">📚 키워드 라이브러리</h2>
                    <button @click="isAdding = !isAdding"
                        class="text-slate-500 hover:text-blue-600 transition-colors"
                        title="새 키워드/그룹 추가">
                        <span class="material-symbols-outlined transition-transform text-2xl" :class="{'rotate-45': isAdding}">add_circle</span>
                    </button>
                </div>

                <div x-show="isAdding" x-transition class="mb-4 space-y-2">
                    <!-- Add Keyword Section -->
                    <div class="p-4 bg-slate-50 rounded-lg space-y-4">
                         <div x-data="{ newKeyword: '', newDesc: '' }">
                             <h4 class="font-bold text-slate-800">새 키워드 추가</h4>
                             <p class="text-sm text-slate-500">첫번째 사용자 그룹에 추가됩니다.</p>
                             <div class="mt-2 space-y-2">
                                 <input type="text" placeholder="키워드 이름 (AI 지원 시 자유롭게 입력)" class="w-full p-2 border rounded-md border-slate-300 bg-white" x-model="newKeyword" @keydown.enter="$store.app.addNewKeywordToKeywordLibrary(newKeyword, newDesc); newKeyword=''; newDesc='';">
                                 <input type="text" placeholder="설명 (선택, 비워둘 수 있음)" class="w-full p-2 border rounded-md border-slate-300 bg-white" x-model="newDesc" @keydown.enter="$store.app.addNewKeywordToKeywordLibrary(newKeyword, newDesc); newKeyword=''; newDesc='';">
                                 <button class="w-full bg-blue-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-blue-600 flex items-center justify-center" @click="$store.app.addNewKeywordToKeywordLibrary(newKeyword, newDesc); newKeyword=''; newDesc='';" :disabled="$store.app.ui.isLoadingCompletion">
                                     <span class="material-symbols-outlined spinner text-base" x-show="$store.app.ui.isLoadingCompletion" x-cloak>progress_activity</span>
                                     <span x-show="!$store.app.ui.isLoadingCompletion">등록</span>
                                 </button>
                             </div>
                         </div>
                    </div>
                     <!-- Add Group Section -->
                    <div x-data="{ newGroupName: '' }" class="p-4 bg-slate-50 rounded-lg space-y-2">
                         <h4 class="font-bold text-slate-800">새 그룹 추가</h4>
                        <input type="text" x-ref="newGroupNameInput" placeholder="새 그룹 이름 입력..."
                               x-model="newGroupName"
                               @keydown.enter.prevent="$store.app.addNewKeywordLibraryGroup(newGroupName); newGroupName='';"
                               class="w-full p-2 border rounded-md border-slate-300 bg-white"
                               >
                        <button @click="$store.app.addNewKeywordLibraryGroup(newGroupName); newGroupName='';" class="w-full bg-blue-500 text-white font-semibold py-2 px-3 rounded-lg hover:bg-blue-600">추가</button>
                    </div>
                </div>

                <div class="relative mb-4">
                    <span class="material-symbols-outlined absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">search</span>
                    <input type="text" id="keyword-search-input" placeholder="키워드 검색..." class="w-full p-2 pl-10 border rounded-md border-slate-300 bg-white" x-model="$store.app.keywordLibrary.searchTerm">
                </div>

                <div id="keyword-list-container" class="space-y-3 flex-grow overflow-y-auto pr-2">
                    <template x-for="group in [...$store.app.keywordLibrary.defaultGroups, ...$store.app.keywordLibrary.userGroups]" :key="group.id">
                        <div x-data="keywordGroup(group)"
                             @click.outside="$store.app.keywordLibrary.tabDeleteState.groupId === group.id ? $store.app.keywordLibrary.tabDeleteState.active = false : null"
                             x-show="hasSearchResults"
                             class="group-container bg-slate-50 px-2 py-3 rounded"
                             :class="{'collapsed': !$store.app.keywordLibrary.searchTerm && group.collapsed}"
                             :data-group-id="group.id" 
                            >
                            <div class="group-header flex justify-between items-center cursor-pointer group" @click="!$store.app.keywordLibrary.searchTerm && (group.collapsed = !group.collapsed)">
                                <div class="flex items-center">
                                    <span class="material-symbols-outlined toggle-icon text-slate-500 mr-2">expand_more</span>
                                    <span class="font-bold text-slate-800 text-base sm:text-lg" x-text="group.isDefault ? { subject: '주제', details: '세부 묘사', style: '표현 기법', composition: '구도' }[group.id] : group.name"></span>
                                    <span class="keyword-count ml-2 text-xs text-slate-500" x-text="`(${filteredCount})`"></span>
                                </div>
                                <div class="group-controls flex items-center gap-1">
                                    <button x-show="!group.isDefault" @click.stop="$store.app.deleteUserKeywordLibraryGroup(group.id)" class="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100" title="그룹 삭제">
                                        <span class="material-symbols-outlined text-base">delete</span>
                                    </button>
                                </div>
                            </div>
                            <div x-show="!(!$store.app.keywordLibrary.searchTerm && group.collapsed)" class="group-content pt-3">
                                <div class="flex items-center flex-wrap gap-1 mb-3 border-t pt-3 border-slate-200">
                                    <template x-for="tab in group.tabs" :key="tab.name">
                                        <div class="relative shrink-0">
                                            <button @click.stop="group.activeTab = tab.name" 
                                                    class="keyword-tab text-xs font-semibold py-1 px-3 rounded-full border"
                                                    :class="{ 'active': group.activeTab === tab.name, 'bg-white': group.activeTab !== tab.name }">
                                                <span x-text="tab.name"></span>
                                            </button>
                                            <button x-show="$store.app.keywordLibrary.tabDeleteState.active && $store.app.keywordLibrary.tabDeleteState.groupId === group.id && group.tabs.length > 1"
                                                    @click.stop="$store.app.deleteTabFromKeywordLibraryGroup(group.id, tab.name)"
                                                    class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-4 h-4 flex items-center justify-center text-xs leading-none hover:bg-red-700 transition-colors" x-cloak>&times;</button>
                                        </div>
                                    </template>
                                    <template x-if="!group.isDefault">
                                        <div class="relative shrink-0">
                                            <button x-show="!isAddingTab"
                                                    @click.stop="isAddingTab = true; $nextTick(() => $refs.newTabInput?.focus()); group.collapsed=false"
                                                    class="bg-blue-100 text-blue-600 rounded-full w-6 h-6 flex items-center justify-center hover:bg-blue-200"
                                                    title="탭 추가">
                                                <span class="material-symbols-outlined text-base">add</span>
                                            </button>
                                            <div x-show="isAddingTab" @click.stop @keydown.escape.prevent="isAddingTab = false; newTabName = ''" class="flex items-center gap-1 p-1 bg-slate-200 rounded-lg" x-cloak>
                                                <input type="text" x-ref="newTabInput" x-model="newTabName" placeholder="새 탭 이름"
                                                       class="text-xs p-1 rounded-md border-slate-300 w-24"
                                                       @keydown.enter.prevent="confirmAddTab()">
                                                <button @click="confirmAddTab()" class="text-green-600 hover:bg-green-100 rounded-full p-0.5">
                                                    <span class="material-symbols-outlined text-sm">check</span>
                                                </button>
                                                <button @click="isAddingTab = false; newTabName = ''" class="text-red-500 hover:bg-red-100 rounded-full p-0.5">
                                                    <span class="material-symbols-outlined text-sm">close</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="relative shrink-0">
                                             <button @click.stop="$store.app.toggleKeywordLibraryTabDeleteMode(group.id); group.collapsed=false" x-show="group.tabs.length > 1"
                                                    class="rounded-full w-6 h-6 flex items-center justify-center"
                                                    :class="$store.app.keywordLibrary.tabDeleteState.active && $store.app.keywordLibrary.tabDeleteState.groupId === group.id ? 'bg-red-200 text-red-700 hover:bg-red-300' : 'bg-red-100 text-red-600 hover:bg-red-200'"
                                                    title="탭 삭제">
                                                <span class="material-symbols-outlined text-base">remove</span>
                                            </button>
                                        </div>
                                    </template>
                                </div>
                                <ul class="space-y-1 max-h-96 overflow-y-auto">
                                    <template x-for="(item, index) in filteredKeywords" :key="item.id">
                                        <li>
                                             <div class="library-item bg-white p-3 rounded-lg border shadow-sm flex justify-between items-center cursor-pointer"
                                                  @click="$store.app.handleKeywordLibraryClick($event, item, group)"
                                                  :class="{ 'selected-in-promptBoard': $store.app.promptBoard.activeKeywordIds.includes(item.id) }">
                                                <div>
                                                    <p class="font-bold" x-text="item.keyword"></p>
                                                    <p class="text-sm text-slate-500" x-text="item.desc"></p>
                                                </div>
                                                <template x-if="item.isCustom">
                                                    <div class="item-controls flex items-center gap-1 transition-opacity">
                                                        <button @click.stop="$store.app.openKeywordLibraryMoveMenu($event, item, group)" 
                                                                class="p-1 rounded-full text-slate-500 hover:bg-slate-200"
                                                                title="위치 변경">
                                                            <span class="material-symbols-outlined text-base">open_with</span>
                                                        </button>
                                                        <button @click.stop="$store.app.removeKeywordFromKeywordLibrary(group.id, item.id)"
                                                                class="p-1 rounded-full text-red-500 hover:bg-red-100"
                                                                title="삭제">
                                                            <span class="material-symbols-outlined text-base">delete</span>
                                                        </button>
                                                    </div>
                                                </template>
                                             </div>
                                        </li>
                                    </template>
                                </ul>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Right Column: Prompt Board, Image Station & Generator Deck -->
            <div class="lg:col-span-2 space-y-4">
                <div id="promptBoard-container"
                     class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg group-container transition-all"
                     :class="{'collapsed': $store.app.ui.isPromptBoardCollapsed}">
                    <div class="flex flex-wrap justify-between items-center border-b pb-2 gap-2 border-slate-200">
                        <div class="flex items-center gap-4">
                            <h2 class="text-xl sm:text-2xl font-bold">📝 프롬프트 보드</h2>
                            <button class="text-slate-500 hover:text-blue-600 transition-colors" title="수동 프롬프트 편집" @click="$store.app.openModal('manual-prompt-modal')">
                                <span class="material-symbols-outlined">keyboard</span>
                            </button>
                            <button class="text-slate-500 hover:text-blue-600 transition-colors" title="프리셋 관리" @click.stop="$store.app.openModal('load-preset-modal')">
                                <span class="material-symbols-outlined">folder</span>
                            </button>
                        </div>
                        <div class="flex gap-2 flex-wrap">
                            <button class="bg-[#4285F4] hover:bg-[#3367D6] text-white font-bold py-2 px-4 rounded-lg transition-colors inline-flex items-center gap-2 disabled:opacity-50 text-sm sm:text-base" @click="$store.app.generatePromptSentence()" :disabled="$store.app.ui.isLoadingCompletion">
                                <span class="material-symbols-outlined text-base spinner" x-show="$store.app.ui.isLoadingCompletion" x-cloak>progress_activity</span>
                                <span class="material-symbols-outlined text-base" x-show="!$store.app.ui.isLoadingCompletion">lightbulb</span>
                                <span>AI 프롬프트 완성</span>
                            </button>
                             <button class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition-opacity inline-flex items-center gap-2 text-sm sm:text-base" @click="$store.app.clearPromptBoardAndImageStation()">
                                <span class="material-symbols-outlined text-base">delete</span> 
                                <span>비우기</span>
                            </button>
                        </div>
                    </div>
                    <div class="group-content pt-4">
                        <div id="promptBoard" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <template x-for="area in $store.app.promptBoardAreaInfo" :key="area.key">
                                <div x-data="promptBoardArea(area.key, area.title)"
                                     :id="`area-${key}`"
                                     class="promptBoard-area bg-slate-50 px-4 py-3 rounded-lg relative"
                                     @dragover.prevent="$store.app.handlePromptBoardDragOver($event, key)"
                                     @drop.prevent="$store.app.handlePromptBoardDrop($event, key)">
                                    <h3 class="font-bold text-base sm:text-lg mb-2" x-text="title"></h3>
                                    <div class="flex flex-wrap gap-2 min-h-[36px] relative">
                                        <template x-for="(item, index) in keywords" :key="item.instanceId">
                                            <div class="prompt-keyword bg-blue-100 text-blue-800 text-sm font-semibold px-3 py-1 rounded-full flex items-center gap-2 cursor-grab border-2 border-transparent" 
                                                :data-instance-id="item.instanceId" :data-id="item.id" draggable="true" 
                                                @dragstart="$store.app.handlePromptBoardDragStart($event, item, key)"
                                                :class="{'opacity-25': $store.app.promptBoard.draggingItem && $store.app.promptBoard.draggingItem.item.instanceId === item.instanceId}">
                                                <span x-text="item.keyword"></span>
                                                <button class="remove-keyword-btn text-blue-600 hover:text-blue-900" @click="$store.app.removeKeywordFromPromptBoard(item.instanceId)">
                                                    <span class="material-symbols-outlined text-base pointer-events-none">cancel</span>
                                                </button>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                            </template>
                        </div>
                        <div class="mt-4 pt-4 border-t border-slate-200">
                            <div class="flex justify-between items-center gap-4 mb-2">
                                <h3 class="text-lg font-bold">최종 프롬프트</h3>
                                <div class="text-sm text-slate-500 ml-auto" :class="{ 'text-red-500 font-bold': $store.app.promptLengthInfo.exceeds }">
                                    <span x-text="`${$store.app.promptLengthInfo.current} / ${$store.app.promptLengthInfo.max} 자`"></span>
                                </div>
                            </div>
                             <div class="relative group">
                                <textarea id="result-output" rows="4" class="w-full p-4 border border-slate-300 rounded-lg bg-slate-100 text-slate-700 transition-all" readonly :value="$store.app.getFinalPrompt()"></textarea>
                                 <button @click="$store.app.copyToClipboard($store.app.getFinalPrompt())" title="프롬프트 복사"
                                        class="absolute top-2 right-2 p-1.5 bg-slate-200 text-slate-600 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity hover:bg-slate-300">
                                    <span class="material-symbols-outlined text-base">content_copy</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg">
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-2 border-b pb-2 border-slate-200">
                        <div class="flex items-center gap-4">
                            <h2 class="text-xl sm:text-2xl font-bold">🖼️ 이미지 스테이션</h2>
                            <label for="image-upload-input" class="cursor-pointer text-slate-500 hover:text-blue-600" title="이미지 첨부">
                                <span class="material-symbols-outlined">attachment</span>
                            </label>
                            <div class="relative">
                                <button @click="!isMobile && ($store.app.ui.isToolboxOpen = !$store.app.ui.isToolboxOpen)"
                                        :title="isMobile ? '편집 도구는 PC에서만 사용 가능합니다' : '편집 도구 상자'"
                                        :disabled="isMobile"
                                        class="cursor-pointer text-slate-500 hover:text-blue-600"
                                        :class="{ 'opacity-50 cursor-not-allowed': isMobile }">
                                    <span class="material-symbols-outlined">construction</span>
                                </button>
                                <div x-show="$store.app.ui.isToolboxOpen"
                                     @click.outside="$store.app.ui.isToolboxOpen = false"
                                     x-transition
                                     class="absolute top-0 left-full ml-2 w-52 bg-white rounded-lg shadow-xl border z-10 p-2 space-y-1" x-cloak>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'draw'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>🎨 그림 그리기</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'refine'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>📸 이미지 보정</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'inpaint'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>🖌️ 부분 수정</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'outpaint'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>📐 캔버스 확장</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'infuse'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>🧪 피사체 제어</span>
                                    </button>
                                    <button @click="$store.app.openModal('edit-canvas', {mode: 'analyze'}); $store.app.ui.isToolboxOpen = false"
                                            class="w-full text-left px-3 py-2 text-sm text-slate-700 rounded hover:bg-slate-100">
                                        <span>🔬 이미지 분석</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="text-sm text-slate-500" :class="{ 'text-red-500 font-bold': $store.app.referenceImagesSizeInfo.exceeds }">
                            <span x-text="`${$store.app.referenceImagesSizeInfo.current.toFixed(1)} / ${$store.app.referenceImagesSizeInfo.max.toFixed(1)} MB`"></span>
                        </div>
                        <input type="file" id="image-upload-input" multiple accept="image/*" class="hidden" @change="$store.app.handleFileUpload($event)">
                    </div>
                    <div id="image-thumbnail-container" class="flex flex-wrap items-center gap-1.5 bg-slate-50 rounded-lg transition-all duration-300 ease-in-out overflow-hidden"
                        :class="{
                             'min-h-[80px] p-1': $store.app.imageStation.images.length > 0,
                             'max-h-0': $store.app.imageStation.images.length === 0
                         }">
                        <template x-for="(img, index) in $store.app.imageStation.images" :key="img.id">
                            <div class="thumbnail-item relative cursor-pointer"
                                @click="$store.app.selectImage(img)"
                                draggable="true"
                                @dragstart="$store.app.handleImageDragStart($event, img)"
                                @dragover.prevent="$store.app.handleImageDragOver($event, index)"
                                @drop.prevent="$store.app.handleImageDrop($event, index)">
                                <img :src="img.dataUrl" class="w-16 h-16 object-cover rounded-md pointer-events-none" :class="{ 'ring-2 ring-offset-2 ring-blue-500': $store.app.ui.selectedImageId === img.id, 'opacity-50': $store.app.imageStation.draggingItem && $store.app.imageStation.draggingItem.id === img.id }">
                                <div x-show="index < $store.app.settings.referenceImageCount" class="absolute top-0 left-0 bg-black bg-opacity-60 text-white rounded-br-md rounded-tl-md text-xs font-bold w-4 h-4 flex items-center justify-center" x-text="index + 1" x-cloak></div>
                                <button class="remove-img-btn absolute top-0 right-0 bg-black bg-opacity-50 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs -mt-1 -mr-1" @click.stop="$store.app.removeFromImageStation(img.id)">
                                    <span class="material-symbols-outlined text-sm pointer-events-none">close</span>
                                </button>
                            </div>
                        </template>
                    </div>
                </div>

                <!-- Generator Deck -->
                <div id="generatorDeck-container" class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg">
                    <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center sm:gap-3 mb-4">
                         <div class="flex-grow flex flex-col sm:flex-row sm:items-center sm:justify-start sm:gap-4 gap-y-3">
                            <h2 class="text-xl sm:text-2xl font-bold">🚀 제너레이터 덱</h2>
                            <div class="flex items-center gap-4">
                                <div x-data="{ open: false }" class="relative">
                                    <button @click="open = !open"
                                            class="text-slate-500 hover:text-blue-600 transition-colors" title="파라미터 설정">
                                        <span class="material-symbols-outlined">tune</span>
                                    </button>
                                    <div x-show="open" @click.outside="open = false" x-transition class="absolute z-10 top-full mt-2 right-0 sm:left-0 sm:right-auto bg-white rounded-lg shadow-xl border w-80 p-4 space-y-4">
                                        <div class="space-y-2">
                                            <label class="text-sm font-bold text-slate-700">생성 모델</label>
                                             <div class="inline-flex rounded-md shadow-sm w-full" role="group">
                                                <button type="button" @click="$store.app.settings.generationModel = 'gemini'" class="w-1/2 px-4 py-2 text-sm font-medium rounded-l-lg border focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.generationModel === 'gemini', 'bg-white text-gray-900 border-gray-200': $store.app.settings.generationModel !== 'gemini' }">🍌 Gemini Flash</button>
                                                <button type="button" @click="$store.app.settings.generationModel = 'imagen'" class="w-1/2 px-4 py-2 text-sm font-medium rounded-r-lg border focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.generationModel === 'imagen', 'bg-white text-gray-900 border-gray-200': $store.app.settings.generationModel !== 'imagen' }">🔮 Imagen 3</button>
                                             </div>
                                        </div>
                                        <div class="space-y-2">
                                            <label class="text-sm font-bold text-slate-700">AI 해석 수준</label>
                                             <div class="inline-flex rounded-md shadow-sm w-full" role="group">
                                                <button type="button" @click="$store.app.settings.interpretationLevel = 'precise'" class="w-1/3 px-4 py-2 text-sm font-medium rounded-l-lg border focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.interpretationLevel === 'precise', 'bg-white text-gray-900 border-gray-200': $store.app.settings.interpretationLevel !== 'precise' }">정확하게</button>
                                                <button type="button" @click="$store.app.settings.interpretationLevel = 'balanced'" class="w-1/3 px-4 py-2 text-sm font-medium border-t border-b focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.interpretationLevel === 'balanced', 'bg-white text-gray-900 border-gray-200': $store.app.settings.interpretationLevel !== 'balanced' }">균형 있게</button>
                                                <button type="button" @click="$store.app.settings.interpretationLevel = 'creative'" class="w-1/3 px-4 py-2 text-sm font-medium rounded-r-lg border focus:z-10 focus:ring-2" :class="{'bg-blue-600 text-white border-blue-600': $store.app.settings.interpretationLevel === 'creative', 'bg-white text-gray-900 border-gray-200': $store.app.settings.interpretationLevel !== 'creative' }">자유롭게</button>
                                             </div>
                                        </div>
                                        <div class="space-y-2">
                                            <label for="reference-image-count" class="text-sm font-bold text-slate-700">참조 이미지: <span x-text="$store.app.settings.referenceImageCount"></span></label>
                                            <input id="reference-image-count" type="range" min="0" max="4" x-model.number="$store.app.settings.referenceImageCount" class="w-full">
                                        </div>
                                        <div class="space-y-2">
                                            <label for="number-of-images" class="text-sm font-bold text-slate-700" :class="{'text-slate-400': $store.app.settings.generationModel === 'gemini'}">출력 이미지: <span x-text="$store.app.settings.numberOfImages"></span></label>
                                            <input id="number-of-images" type="range" min="1" max="4" step="1" x-model.number="$store.app.settings.numberOfImages" class="w-full" :disabled="$store.app.settings.generationModel === 'gemini'">
                                        </div>
                                        <div class="space-y-4 pt-2 border-t border-slate-200">
                                             <div class="space-y-2">
                                                <div class="flex items-center">
                                                    <label class="text-sm font-bold text-slate-700">비율</label>
                                                </div>
                                                <select x-model="$store.app.settings.aspectRatio" class="w-full p-2 border rounded-md border-slate-300 bg-white" :disabled="$store.app.settings.generationModel === 'gemini' && $store.app.imageStation.images.slice(0, $store.app.settings.referenceImageCount).length > 0">
                                                    <template x-for="option in $store.app.aspectRatioOptions" :key="option.ratio">
                                                        <option :value="option.ratio" x-text="`${option.ratio} ${option.desc}`"></option>
                                                    </template>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button class="text-slate-500 hover:text-blue-600 transition-colors" title="프롬프트 생성 히스토리" @click="$store.app.openModal('history-modal')">
                                    <span class="material-symbols-outlined">history</span>
                                </button>
                            </div>
                        </div>
                        <div class="w-full sm:w-auto">
                            <button id="generate-image-btn" class="w-full sm:w-auto bg-[#4285F4] hover:bg-[#3367D6] text-white font-bold py-2 px-4 rounded-lg transition-colors inline-flex items-center justify-center gap-2 disabled:opacity-50" @click="$store.app.generateImage()" :disabled="$store.app.ui.isLoadingImage">
                                <span class="material-symbols-outlined text-base spinner" x-show="$store.app.ui.isLoadingImage" x-cloak>progress_activity</span>
                                <span class="material-symbols-outlined text-base" x-show="!$store.app.ui.isLoadingImage">auto_awesome</span>
                                <span>이미지 생성</span>
                            </button>
                        </div>
                    </div>
                    
                    <div id="deck-output-container" 
                        class="w-full aspect-square bg-slate-100 rounded-lg flex items-center justify-center relative transition-all">
                        <div id="image-loader" class="loader" x-show="$store.app.ui.isLoadingImage" x-cloak></div>
                        <img id="deck-generated-image" :src="$store.app.ui.generatedImageUrl" alt="AI Generated Image" class="w-full h-full object-contain rounded-lg" x-show="$store.app.ui.generatedImageUrl && !$store.app.ui.isLoadingImage" draggable="false" x-cloak>
                        <p id="deck-placeholder-text" class="text-slate-500" x-show="!$store.app.ui.generatedImageUrl && !$store.app.ui.isLoadingImage">AI 생성 이미지가 여기에 표시됩니다.</p>
                        
                        <div class="absolute top-3 left-3 flex items-start gap-2" x-show="$store.app.ui.generatedImageUrl && !$store.app.ui.isLoadingImage" x-cloak>
                            <div class="group relative">
                                <button @click="$store.app.ui.isImageInfoPinned = !$store.app.ui.isImageInfoPinned"
                                        class="bg-white text-slate-700 font-bold py-1 px-3 rounded-lg hover:bg-slate-200 transition-all shadow-md"
                                        :class="{ 'bg-blue-500 text-white hover:bg-blue-600': $store.app.ui.isImageInfoPinned }">
                                    <span class="material-symbols-outlined text-base">info</span>
                                </button>
                                <div class="absolute left-0 top-full mt-2 w-48 bg-black/70 backdrop-blur-sm text-white text-xs rounded-lg p-2 shadow-lg transition-opacity pointer-events-none"
                                     :class="{
                                         'opacity-100': $store.app.ui.isImageInfoPinned,
                                         'opacity-0 group-hover:opacity-100': !$store.app.ui.isImageInfoPinned
                                     }">
                                    <p class="font-bold truncate" x-text="$store.app.ui.currentImageInfo.name || '...'" title="파일명"></p>
                                    <p x-text="`해상도: ${$store.app.ui.currentImageInfo.resolution || '...'}`"></p>
                                    <p x-text="`크기: ${$store.app.ui.currentImageInfo.size || '...'}`"></p>
                                </div>
                            </div>
                        </div>

                        <div class="absolute top-3 right-3 flex gap-2" x-show="$store.app.ui.generatedImageUrl && !$store.app.ui.isLoadingImage" x-cloak>
                            <a :href="$store.app.ui.generatedImageUrl" :download="$store.app.ui.currentImageInfo.name || `sevit_studio_${Date.now()}.png`" class="bg-white text-slate-700 font-bold py-1 px-3 rounded-lg hover:bg-slate-200 transition-all shadow-md" title="다운로드" id="download-image-btn">
                                <span class="material-symbols-outlined text-base">download</span>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Unified Edit Canvas -->
    <div id="edit-canvas" x-data="editCanvas()" x-show="$store.app.ui.activeModal === 'edit-canvas'" 
         x-transition class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-stretch justify-center p-4" 
         @click.self="$store.app.closeModal()" 
         @resize.window.debounce.250ms="handleResize()" 
         x-cloak>
        <div class="flex items-stretch gap-2 w-full h-full mx-auto">
            <div x-ref="canvasWrapper" class="relative flex items-center justify-center flex-grow h-full bg-slate-900/50 rounded-lg w-full">
                <canvas x-ref="canvas" class="rounded-lg shadow-xl"></canvas>
                <div x-show="isLoading && mode === 'infuse'" class="absolute inset-0 bg-black/50 flex items-center justify-center rounded-lg" x-cloak>
                    <div class="w-16 h-16 border-8 border-dashed rounded-full animate-spin border-sky-400"></div>
                </div>
                <!-- [MODIFIED] Image Navigation for ALL Modes -->
                <template x-if="$store.app.imageStation.images.length > 1">
                    <div class="absolute inset-0 flex items-center justify-between pointer-events-none p-2">
                        <button @click="$store.app.navigateToPreviousImage()"
                                :disabled="!canNavigatePrevious"
                                class="w-10 h-10 bg-black/30 text-white rounded-full hover:bg-black/60 disabled:opacity-20 disabled:cursor-not-allowed pointer-events-auto transition-all backdrop-blur-sm">
                            &#9664;
                        </button>
                        <button @click="$store.app.navigateToNextImage()"
                                :disabled="!canNavigateNext"
                                class="w-10 h-10 bg-black/30 text-white rounded-full hover:bg-black/60 disabled:opacity-20 disabled:cursor-not-allowed pointer-events-auto transition-all backdrop-blur-sm">
                            &#9654;
                        </button>
                    </div>
                </template>
            </div>
            <div class="flex-shrink-0 self-start mt-16 flex flex-col gap-2 bg-slate-800 p-4 rounded-lg shadow-2xl w-full md:w-80">
                <div class="flex justify-center items-center relative">
                    <h3 class="text-white font-bold text-center text-xl" x-text="title"></h3>
                </div>

                <div class="relative">
                    <div class="grid grid-cols-6 gap-1 p-1 bg-slate-700 rounded-lg">
                        <template x-for="item in [
                            { mode: 'draw', icon: '🎨', title: '그림 그리기' },
                            { mode: 'refine', icon: '📸', title: '이미지 보정' },
                            { mode: 'inpaint', icon: '🖌️', title: '부분 수정' },
                            { mode: 'outpaint', icon: '📐', title: '캔버스 확장' },
                            { mode: 'infuse', icon: '🧪', title: '피사체 제어' },
                            { mode: 'analyze', icon: '🔬', title: '이미지 분석' }
                        ]" :key="item.mode">
                            <button 
                                @click="switchMode(item.mode)"
                                :disabled="isLoading || mode === item.mode"
                                :title="item.title"
                                class="py-2 rounded-md text-xl transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                :class="{
                                    'bg-sky-500': mode === item.mode,
                                    'hover:bg-slate-600': mode !== item.mode
                                }">
                                <span x-text="item.icon"></span>
                            </button>
                        </template>
                    </div>
                </div>

                <!-- [REVISED] Main Content Wrapper for proper layout -->
                <div class="flex-grow flex flex-col min-h-0">
                    <div class="flex-grow overflow-y-auto space-y-2 pr-2 -mr-2 scrollbar-hide">
                        <!-- Dynamic Controls Area -->
                        <div class="space-y-2">
                            <!-- Draw Controls -->
                            <template x-if="mode === 'draw'">
                                <div class="space-y-4">
                                    <div>
                                        <label class="font-semibold text-sm text-white">색상</label>
                                        <input type="color" x-model="brushColor" @input="updateBrush()" class="w-full h-10 p-1 border rounded-md cursor-pointer">
                                    </div>
                                    <div>
                                        <label class="font-semibold text-sm text-white"><span>크기</span>: <span x-text="brushSize"></span></label>
                                        <input type="range" min="1" max="50" x-model="brushSize" @input="updateBrush()" class="w-full">
                                    </div>
                                    <div class="pt-4 border-t border-slate-700 space-y-2">
                                        <label class="text-sm font-semibold text-white mb-2 block">AI 지원</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <button @click="activeAISupport = (activeAISupport === 'line-cleanup' ? null : 'line-cleanup')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="activeAISupport === 'line-cleanup' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                선 정리
                                            </button>
                                            <button @click="activeAISupport = (activeAISupport === 'sketch-complete' ? null : 'sketch-complete')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="activeAISupport === 'sketch-complete' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                스케치 완성
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </template>

                            <!-- Refine Controls -->
                            <template x-if="mode === 'refine'">
                                <div class="space-y-4">
                                    <div class="space-y-2">
                                        <label class="text-sm font-semibold text-white mb-2 block">기본 변환</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <button @click="rotateImage(-90)" class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors bg-slate-600 text-slate-200 hover:bg-slate-500 flex items-center justify-center gap-1">
                                                <span class="material-symbols-outlined text-sm">rotate_left</span> 좌회전
                                            </button>
                                            <button @click="rotateImage(90)" class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors bg-slate-600 text-slate-200 hover:bg-slate-500 flex items-center justify-center gap-1">
                                                <span class="material-symbols-outlined text-sm">rotate_right</span> 우회전
                                            </button>
                                            <button @click="flipImage('X')" class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors bg-slate-600 text-slate-200 hover:bg-slate-500 flex items-center justify-center gap-1">
                                                <span class="material-symbols-outlined text-sm">flip</span> 좌우 반전
                                            </button>
                                            <button @click="flipImage('Y')" class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors bg-slate-600 text-slate-200 hover:bg-slate-500 flex items-center justify-center gap-1">
                                                <span class="material-symbols-outlined text-sm" style="transform: rotate(90deg);">flip</span> 상하 반전
                                            </button>
                                        </div>
                                    </div>
                                     <div class="pt-4 border-t border-slate-700">
                                        <div class="grid grid-cols-2 gap-x-4 gap-y-3">
                                            <div>
                                                <label class="text-sm font-semibold text-white">밝기: <span x-text="(refineState.brightness * 100).toFixed(0)"></span></label>
                                                <input type="range" x-model.number="refineState.brightness" min="-1" max="1" step="0.01" class="w-full" @input.debounce.10ms="handleFilterChange()">
                                            </div>
                                            <div>
                                                <label class="text-sm font-semibold text-white">대비: <span x-text="(refineState.contrast * 100).toFixed(0)"></span></label>
                                                <input type="range" x-model.number="refineState.contrast" min="-1" max="1" step="0.01" class="w-full" @input.debounce.10ms="handleFilterChange()">
                                            </div>
                                            <div>
                                                <label class="text-sm font-semibold text-white">채도: <span x-text="(refineState.saturation * 100).toFixed(0)"></span></label>
                                                <input type="range" x-model.number="refineState.saturation" min="-1" max="1" step="0.01" class="w-full" @input.debounce.10ms="handleFilterChange()">
                                            </div>
                                            <div>
                                                <label class="text-sm font-semibold text-white">색조: <span x-text="(refineState.hue * 100).toFixed(0)"></span></label>
                                                <input type="range" x-model.number="refineState.hue" min="-1" max="1" step="0.01" class="w-full" @input.debounce.10ms="handleFilterChange()">
                                            </div>
                                        </div>
                                    </div>
                                    <div class="pt-4 border-t border-slate-700 space-y-2">
                                        <label class="text-sm font-semibold text-white mb-2 block">필터</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <button @click="refineState.activeFilter = (refineState.activeFilter === 'grayscale' ? null : 'grayscale'); handleFilterChange()" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeFilter === 'grayscale' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">흑백</button>
                                            <button @click="refineState.activeFilter = (refineState.activeFilter === 'sepia' ? null : 'sepia'); handleFilterChange()" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeFilter === 'sepia' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">세피아</button>
                                            <button @click="refineState.activeFilter = (refineState.activeFilter === 'invert' ? null : 'invert'); handleFilterChange()" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeFilter === 'invert' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">색상 반전</button>
                                            <button @click="refineState.activeFilter = (refineState.activeFilter === 'blur' ? null : 'blur'); handleFilterChange()" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeFilter === 'blur' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">블러</button>
                                        </div>
                                    </div>                            
                                    <div class="pt-4 border-t border-slate-700 space-y-2">
                                        <label class="text-sm font-semibold text-white mb-2 block">AI 보정</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <button @click="refineState.activeAICorrection = (refineState.activeAICorrection === 'background-removal' ? null : 'background-removal')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeAICorrection === 'background-removal' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                배경 제거
                                            </button>
                                            <button @click="refineState.activeAICorrection = (refineState.activeAICorrection === 'colorize' ? null : 'colorize')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeAICorrection === 'colorize' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                AI 채색
                                            </button>
                                            <button @click="refineState.activeAICorrection = (refineState.activeAICorrection === 'quality-enhance' ? null : 'quality-enhance')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeAICorrection === 'quality-enhance' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                품질 개선
                                            </button>
                                            <button @click="refineState.activeAICorrection = (refineState.activeAICorrection === 'id-photo' ? null : 'id-photo')" class="w-full py-2 rounded-md text-sm font-semibold transition-colors" :class="refineState.activeAICorrection === 'id-photo' ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                증명사진 변환
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Inpaint Controls -->
                            <template x-if="mode === 'inpaint'">
                                <div class="space-y-4">
                                    <div class="space-y-2">
                                        <label class="text-white text-sm font-semibold">마스크 모드</label>
                                        <div class="inline-flex rounded-md shadow-sm w-full" role="group">
                                            <button type="button" @click="maskMode = 'transform'" class="w-1/2 px-4 py-2 text-sm font-medium text-white bg-transparent rounded-l-lg border border-gray-500 hover:bg-sky-600 hover:border-sky-600 focus:z-10 focus:ring-2 focus:ring-sky-500 transition-colors" :class="{'bg-sky-500 border-sky-500': maskMode === 'transform'}">영역 변환</button>
                                            <button type="button" @click="maskMode = 'preserve'" class="w-1/2 px-4 py-2 text-sm font-medium text-white bg-transparent rounded-r-lg border border-gray-500 hover:bg-sky-600 hover:border-sky-600 focus:z-10 focus:ring-2 focus:ring-sky-500 transition-colors" :class="{'bg-sky-500 border-sky-500': maskMode === 'preserve'}">영역 유지</button>
                                        </div>
                                    </div>
                                    <div class="space-y-2">
                                        <label class="text-white text-sm font-semibold"><span>브러시 크기</span>: <span x-text="brushSize"></span></label>
                                        <input type="range" min="5" max="100" x-model="brushSize" @input="updateBrush()" class="w-full">
                                    </div>
                                    <div class="space-y-2">
                                        <div class="flex justify-between items-center mb-1">
                                            <label class="text-white text-sm font-semibold">수정 내용:</label>
                                            <div class="flex flex-wrap gap-2">
                                                <button @click="setInpaintPreset('remove')"
                                                        class="text-xs font-semibold py-1 px-2 rounded-full border transition-colors bg-slate-600 border-slate-500 text-slate-200 hover:bg-slate-500">
                                                    텍스트 제거
                                                </button>
                                                <button @click="setInpaintPreset('fix')"
                                                        class="text-xs font-semibold py-1 px-2 rounded-full border transition-colors bg-slate-600 border-slate-500 text-slate-200 hover:bg-slate-500">
                                                    신체 오류 수정
                                                </button>
                                            </div>
                                        </div>
                                        <input type="text" placeholder="예: a cute silver tabby cat" x-model="inpaintPrompt" @keydown.enter.prevent.stop="executeAction()" class="w-full bg-slate-700 text-white p-2 rounded-md border border-slate-600 focus:outline-none focus:ring-2 focus:ring-sky-500">
                                    </div>
                                </div>
                            </template>
                            <!-- Outpaint Controls -->
                            <template x-if="mode === 'outpaint'">
                                 <div class="space-y-4">
                                    <div class="bg-slate-700 text-white p-3 rounded-md text-center space-y-2">
                                        <label class="block text-sm font-semibold text-slate-300">예상 해상도 (1MP 환산)</label>
                                        <span class="font-mono text-lg" x-text="scaledResolution">1024x1024</span>
                                    </div>
                                    <div class="bg-slate-700 text-white p-3 rounded-md text-center space-y-2">
                                        <label class="block text-sm font-semibold text-slate-300">남은 확장 용량: <span x-text="expansionBudgetPercent.toFixed(0) + '%'"></span></label>
                                        <div class="w-full bg-slate-600 rounded-full h-2">
                                            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300" :style="`width: ${expansionBudgetPercent}%`"></div>
                                        </div>
                                        <div class="h-4">
                                            <p x-show="cornerBudgetConsumption > 0.1" x-transition class="text-xs text-amber-400" x-text="`모서리 확장으로 ${cornerBudgetConsumption.toFixed(0)}% 추가 소모`" x-cloak></p>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="text-sm font-semibold text-white mb-2 block">비율 프리셋</label>
                                        <div class="grid grid-cols-2 gap-2">
                                            <template x-for="option in $store.app.aspectRatioOptions.filter(o => o.ratio !== '1:1')" :key="option.ratio">
                                                <button @click="toggleAspectRatioPreset(option.ratio)"
                                                        class="w-full text-xs font-semibold py-2 px-2 rounded-md transition-colors flex items-center justify-center gap-1"
                                                        :class="activeAspectRatioPreset === option.ratio ? 'bg-sky-500 text-white' : 'bg-slate-600 text-slate-200 hover:bg-slate-500'">
                                                    <span x-text="option.desc"></span>
                                                </button>
                                            </template>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-x-4 gap-y-3 pt-2 border-t border-slate-700">
                                        <div>
                                            <label class="text-sm font-semibold text-white">위: <span x-text="padding.top.toFixed(0) + '%'"></span></label>
                                            <input type="range" x-model.number="padding.top" min="0" max="100" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer" @input="updateExpansionState('top')">
                                        </div>
                                        <div>
                                            <label class="text-sm font-semibold text-white">오른쪽: <span x-text="padding.right.toFixed(0) + '%'"></span></label>
                                            <input type="range" x-model.number="padding.right" min="0" max="100" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer" @input="updateExpansionState('right')">
                                        </div>
                                        <div>
                                            <label class="text-sm font-semibold text-white">아래: <span x-text="padding.bottom.toFixed(0) + '%'"></span></label>
                                            <input type="range" x-model.number="padding.bottom" min="0" max="100" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer" @input="updateExpansionState('bottom')">
                                        </div>
                                        <div>
                                            <label class="text-sm font-semibold text-white">왼쪽: <span x-text="padding.left.toFixed(0) + '%'"></span></label>
                                            <input type="range" x-model.number="padding.left" min="0" max="100" class="w-full h-2 bg-slate-600 rounded-lg appearance-none cursor-pointer" @input="updateExpansionState('left')">
                                        </div>
                                    </div>
                                </div>
                            </template>
                            <!-- Infuse Controls -->
                            <template x-if="mode === 'infuse'">
                                <div class="space-y-4">
                                    <div class="pt-2">
                                        <label class="text-sm font-semibold text-white mb-2 block text-center">원본 이미지</label>
                                        <div class="flex justify-center">
                                            <img :src="baseImage" class="w-28 h-28 object-contain rounded-md border-2 border-slate-600 bg-slate-900" alt="Original Image"
                                                x-show="baseImage">
                                            <div class="w-28 h-28 rounded-md border-2 border-slate-600 bg-slate-900 flex items-center justify-center text-slate-500 text-xs"
                                                x-show="!baseImage">
                                                <span>이미지 없음</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="flex gap-2 justify-center pt-4 border-t border-slate-700">
                                        <template x-for="output in outputs" :key="output.id">
                                            <div class="p-2 border-2 rounded-lg cursor-pointer transition-colors flex flex-col min-w-[50px] min-h-[6rem]"
                                                :class="output.active ? 'border-sky-500 bg-sky-100' : 'border-slate-300 bg-white'"
                                                @click="outputs.forEach(o => o.active = false); output.active = true">
                                                <div class="flex items-center justify-between text-slate-600">
                                                    <span class="font-bold text-xl" x-text="output.id"></span>
                                                    <span class="material-symbols-outlined text-sm" x-show="output.attributes.length > 0" x-cloak>check_circle</span>
                                                </div>
                                                <div class="flex-grow flex flex-wrap items-center justify-center gap-2 mt-2">
                                                    <template x-for="attrId in sortAttributes(output.attributes)" :key="attrId">
                                                        <span class="text-slate-500 text-lg" :title="$store.app.getKeywordById(attrId)?.desc" x-text="getInfuseDisplay(attrId)"></span>
                                                    </template>
                                                </div>
                                            </div>
                                        </template>
                                    </div>
                                    <div class="space-y-2">
                                        <label class="text-sm font-semibold text-white">출력 이미지: <span x-text="outputCount"></span></label>
                                        <input type="range" min="1" max="4" step="1" x-model.number="outputCount" @input="updateOutputs" class="w-full">
                                    </div>

                                    <div class="pt-2 border-t border-slate-700">
                                        <div class="flex border-b border-slate-600 -mx-4 px-2">
                                            <template x-for="(category, catKey) in $store.app.infuseMasterTable" :key="catKey">
                                                <button @click="infuseActiveTab = catKey" 
                                                        class="flex-1 text-sm font-semibold py-2 px-1 text-center border-b-2 transition-colors"
                                                        :class="{
                                                            'text-sky-400 border-sky-400': infuseActiveTab === catKey,
                                                            'text-slate-400 border-transparent hover:text-white': infuseActiveTab !== catKey
                                                        }">
                                                    <span x-text="category.title"></span>
                                                </button>
                                            </template>
                                        </div>
                                        <div class="relative overflow-y-auto pt-3">
                                            <template x-for="(category, catKey) in $store.app.infuseMasterTable" :key="catKey">
                                                <div x-show="infuseActiveTab === catKey" class="flex flex-wrap gap-2">
                                                    <template x-for="recipe in category.recipes" :key="recipe.keywordId">
                                                        <button 
                                                            x-data="{ keyword: $store.app.getKeywordById(recipe.keywordId) }"
                                                            @click="addRemoveAttribute(recipe.keywordId)"
                                                            class="text-xs font-semibold py-1 px-3 rounded-full border transition-colors"
                                                            :class="{
                                                                'bg-sky-500 border-sky-500 text-white': outputs.find(o => o.active)?.attributes.includes(recipe.keywordId),
                                                                'bg-slate-600 border-slate-500 text-slate-200 hover:bg-slate-500': !outputs.find(o => o.active)?.attributes.includes(recipe.keywordId)
                                                            }">
                                                            <span x-text="keyword ? keyword.desc : '...'"></span>
                                                        </button>
                                                    </template>
                                                </div>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                            </template>
                            <!-- Analyze Controls -->
                            <template x-if="mode === 'analyze'">
                                <div class="space-y-4 text-white">
                                    <div class="p-3 bg-slate-700 rounded-lg text-xs text-slate-300 space-y-1">
                                        <p class="font-bold text-white truncate" x-text="$store.app.ui.currentImageInfo.name || '...'" title="파일명"></p>
                                        <p x-text="`해상도: ${$store.app.ui.currentImageInfo.resolution || '...'}`"></p>
                                        <p x-text="`크기: ${$store.app.ui.currentImageInfo.size || '...'}`"></p>
                                    </div>
                                    <div class="p-3 bg-slate-700 rounded-lg space-y-3">
                                        <div>
                                            <label class="text-sm font-semibold text-white">확대: <span x-text="`${(analyzeState.zoom * 100).toFixed(0)}%`"></span></label>
                                            <input type="range" min="1" max="5" step="0.1" x-model.number="analyzeState.zoom" @input="setZoom($event.target.value)" class="w-full mt-1">
                                        </div>
                                        <div class="flex items-center justify-center gap-2">
                                           <button @click="panCanvas('left')" class="w-8 h-8 bg-slate-600 rounded-md flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed" :disabled="analyzeState.zoom <= 1"><span class="material-symbols-outlined">arrow_back</span></button>
                                           <button @click="panCanvas('up')" class="w-8 h-8 bg-slate-600 rounded-md flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed" :disabled="analyzeState.zoom <= 1"><span class="material-symbols-outlined">arrow_upward</span></button>
                                           <button @click="panCanvas('down')" class="w-8 h-8 bg-slate-600 rounded-md flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed" :disabled="analyzeState.zoom <= 1"><span class="material-symbols-outlined">arrow_downward</span></button>
                                           <button @click="panCanvas('right')" class="w-8 h-8 bg-slate-600 rounded-md flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed" :disabled="analyzeState.zoom <= 1"><span class="material-symbols-outlined">arrow_forward</span></button>
                                        </div>
                                    </div>
                                    <div class="flex border-b border-slate-600 -mx-4 px-2">
                                        <button @click="analyzeState.activeTab = 'extract'" 
                                                class="flex-1 text-sm font-semibold py-2 px-1 text-center border-b-2 transition-colors"
                                                :class="{
                                                    'text-sky-400 border-sky-400': analyzeState.activeTab === 'extract',
                                                    'text-slate-400 border-transparent hover:text-white': analyzeState.activeTab !== 'extract'
                                                }">
                                            <span>프롬프트 추출</span>
                                        </button>
                                        <button @click="analyzeState.activeTab = 'expression'" 
                                                class="flex-1 text-sm font-semibold py-2 px-1 text-center border-b-2 transition-colors"
                                                :class="{
                                                    'text-sky-400 border-sky-400': analyzeState.activeTab === 'expression',
                                                    'text-slate-400 border-transparent hover:text-white': analyzeState.activeTab !== 'expression'
                                                }">
                                            <span>표정 분석</span>
                                        </button>
                                        <button @click="analyzeState.activeTab = 'costume'" 
                                                class="flex-1 text-sm font-semibold py-2 px-1 text-center border-b-2 transition-colors"
                                                :class="{
                                                    'text-sky-400 border-sky-400': analyzeState.activeTab === 'costume',
                                                    'text-slate-400 border-transparent hover:text-white': analyzeState.activeTab !== 'costume'
                                                }">
                                            <span>시트 추출</span>
                                        </button>
                                    </div>

                                    <div class="relative min-h-[300px]">
                                        <!-- Extract Tab -->
                                        <div x-show="analyzeState.activeTab === 'extract'">
                                            <div x-show="analyzeState.isLoading" class="flex justify-center items-center py-10" x-cloak>
                                                <div class="w-8 h-8 border-4 border-dashed rounded-full animate-spin border-sky-400"></div>
                                            </div>
                                            <div x-show="!analyzeState.isLoading" class="space-y-4">
                                                <div>
                                                    <label class="font-semibold text-sm">추출된 프롬프트</label>
                                                    <div class="relative group mt-1">
                                                        <textarea readonly :value="analyzeState.promptResult" class="w-full h-28 p-2 bg-slate-700 rounded-md text-sm resize-none" placeholder="이곳에 AI가 분석한 프롬프트가 표시됩니다..."></textarea>
                                                        <div x-show="analyzeState.promptResult" class="absolute top-2 right-2 flex flex-col gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity" x-cloak>
                                                            <button @click="$store.app.copyToClipboard(analyzeState.promptResult)" title="프롬프트 복사" class="p-1 bg-slate-600 rounded-md hover:bg-slate-500"><span class="material-symbols-outlined text-xs">content_copy</span></button>
                                                            <button @click="$store.app.savePromptAsPreset(analyzeState.promptResult)" title="프리셋으로 저장" class="p-1 bg-slate-600 rounded-md hover:bg-slate-500"><span class="material-symbols-outlined text-xs">save</span></button>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label class="font-semibold text-sm">추천 키워드</label>
                                                    <div class="relative group mt-1">
                                                        <div class="p-2 bg-slate-700 rounded-md flex flex-wrap gap-2 min-h-[36px]">
                                                            <template x-for="keyword in analyzeState.keywordResult" :key="keyword">
                                                                <span class="bg-slate-600 text-slate-200 text-xs font-semibold px-2 py-1 rounded-full" x-text="keyword"></span>
                                                            </template>
                                                        </div>
                                                        <div x-show="analyzeState.keywordResult.length > 0" class="absolute top-2 right-2 flex flex-col gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity" x-cloak>
                                                            <button @click="$store.app.copyToClipboard(analyzeState.keywordResult.map(k => '#' + k).join(' '))" title="태그 복사 (#)" class="p-1 bg-slate-600 rounded-md hover:bg-slate-500">
                                                                <span class="material-symbols-outlined text-xs">tag</span>
                                                            </button>
                                                            <button @click="saveKeywordsToLibrary()" title="라이브러리에 저장" class="p-1 bg-slate-600 rounded-md hover:bg-slate-500">
                                                                <span class="material-symbols-outlined text-xs">library_add</span>
                                                            </button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Expression Tab -->
                                        <div x-show="analyzeState.activeTab === 'expression'">
                                             <div x-show="analyzeState.isLoading" class="flex justify-center items-center py-10" x-cloak>
                                                <div class="w-8 h-8 border-4 border-dashed rounded-full animate-spin border-sky-400"></div>
                                            </div>
                                            <div x-show="!analyzeState.isLoading" class="space-y-4">
                                                <div>
                                                    <label class="font-semibold text-sm">표정 분석 결과</label>
                                                    <div class="mt-1 space-y-2 p-3 bg-slate-700 rounded-md">
                                                        <template x-for="emotion in emotionDisplayOrder" :key="emotion.key">
                                                            <div class="flex items-center gap-2">
                                                                <span class="w-16 text-right text-xs uppercase text-slate-300" x-text="emotion.label"></span>
                                                                <div class="flex-1 bg-slate-600 rounded-full h-3">
                                                                    <div class="h-3 rounded-full" :class="emotion.color" :style="`width: ${((analyzeState.expressionResult && analyzeState.expressionResult[emotion.key]) || 0) * 100}%`"></div>
                                                                </div>
                                                                <span class="w-8 text-left text-xs text-slate-300" x-text="`${(((analyzeState.expressionResult && analyzeState.expressionResult[emotion.key]) || 0) * 100).toFixed(0)}%`"></span>
                                                            </div>
                                                        </template>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label class="font-semibold text-sm">해석</label>
                                                    <p class="mt-1 text-sm text-slate-300 p-3 bg-slate-700 rounded-md min-h-[60px]" x-text="analyzeState.commentResult || '이곳에 AI가 분석한 이미지 해석이 표시됩니다...'"></p>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Costume Tab -->
                                        <div x-show="analyzeState.activeTab === 'costume'" class="space-y-3">
                                             <div class="inline-flex rounded-md shadow-sm w-full" role="group">
                                                <button type="button" @click="analyzeState.costumeSheetType = 'costume'" class="w-1/2 px-4 py-2 text-sm font-medium rounded-l-lg border focus:z-10 focus:ring-2" :class="{'bg-sky-500 text-white border-sky-500': analyzeState.costumeSheetType === 'costume', 'bg-slate-600 text-gray-200 border-gray-500': analyzeState.costumeSheetType !== 'costume' }">의상 시트</button>
                                                <button type="button" @click="analyzeState.costumeSheetType = 'character'" class="w-1/2 px-4 py-2 text-sm font-medium rounded-r-lg border focus:z-10 focus:ring-2" :class="{'bg-sky-500 text-white border-sky-500': analyzeState.costumeSheetType === 'character', 'bg-slate-600 text-gray-200 border-gray-500': analyzeState.costumeSheetType !== 'character' }">캐릭터 시트</button>
                                             </div>
                                             <div class="mt-2">
                                                <div class="w-full aspect-square bg-slate-900/50 rounded-md flex items-center justify-center relative">
                                                    <div x-show="analyzeState.isLoading" class="w-8 h-8 border-4 border-dashed rounded-full animate-spin border-sky-400" x-cloak></div>
                                                    <p x-show="!analyzeState.isLoading && !analyzeState.costumeResult" class="text-slate-500 text-sm">생성된 시트가 여기에 표시됩니다.</p>
                                                    <img :src="analyzeState.costumeResult" x-show="!analyzeState.isLoading && analyzeState.costumeResult" class="w-full h-full object-contain rounded-md" x-cloak>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <div class="mt-auto pt-4 border-t border-slate-700">
                    <div class="flex flex-col gap-2">
                        <div class="flex gap-2">
                            <button class="flex-1 bg-slate-600 text-white font-bold py-2 px-3 rounded-lg hover:bg-slate-500 transition-colors flex items-center justify-center" title="초기화" @click="reset()">
                                 <span>초기화</span>
                            </button>
                            <button class="flex-1 text-white font-bold py-2 px-3 rounded-lg transition-colors flex items-center justify-center gap-1 disabled:opacity-50"
                                    :class="{
                                        'bg-green-500 hover:bg-green-600': (mode === 'draw' && !activeAISupport) || (mode === 'refine' && !refineState.activeAICorrection),
                                        'bg-[#4285F4] hover:bg-[#3367D6]': !((mode === 'draw' && !activeAISupport) || (mode === 'refine' && !refineState.activeAICorrection))
                                    }"
                                    title="실행" 
                                    @click="executeAction()"
                                    :disabled="isLoading">
                                <span class="material-symbols-outlined spinner text-base" x-show="isLoading" x-cloak>progress_activity</span>
                                
                                <template x-if="!isLoading">
                                    <span class="material-symbols-outlined text-base" 
                                          x-text="(mode === 'draw' && !activeAISupport) || (mode === 'refine' && !refineState.activeAICorrection) ? 'play_arrow' : 'auto_awesome'">
                                    </span>
                                </template>
                                
                                <span x-show="!isLoading">실행</span>
                            </button>
                        </div>
                        <div class="">
                            <button class="w-full bg-slate-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors" @click="$store.app.closeModal()">
                                닫기
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="settings-modal" x-show="$store.app.ui.activeModal === 'settings-modal'" x-transition class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal-backdrop" @click.self="$store.app.closeModal()" x-cloak>
        <div class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg w-full max-w-xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6 border-b pb-3 border-slate-200">
                <h3 class="text-2xl font-bold">⚙️ 설정</h3>
                <button class="text-slate-500 hover:text-slate-800" @click="$store.app.closeModal()"><span class="material-symbols-outlined">close</span></button>
            </div>
            <div class="space-y-6">
                <div>
                     <div class="flex items-center mb-2">
                        <label class="font-bold text-slate-700">Gemini API 키</label>
                    </div>
                    <input type="password" id="api-key-input" class="w-full p-2 border rounded-md border-slate-300 bg-white" placeholder="API 키를 여기에 붙여넣으세요" x-model="$store.app.settings.apiKey">
                    <!-- 요구사항 1: 안내 메시지 수정 -->
                    <p class="text-xs text-slate-500 mt-1">API 키는 브라우저에만 저장되며 외부로 전송되지 않습니다.</p>
                </div>
                 <div class="flex items-center justify-between">
                    <div>
                        <label class="font-bold text-slate-700">AI 키워드 생성 지원</label>
                        <p class="text-sm text-slate-600">키워드 추가 시, 자동으로 영문 번역 및 설명을 생성합니다.</p>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="ai-support-toggle" x-model="$store.app.settings.aiKeywordSupport">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="flex items-center justify-between pt-6">
                    <div>
                        <label class="font-bold text-slate-700">초기화</label>
                        <p class="text-sm text-slate-600">모든 사용자 데이터를 삭제하고 프로그램을 처음 상태로 되돌립니다.</p>
                    </div>
                    <button class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition-opacity" @click="$store.app.openModal('confirm-modal')">초기화</button>
                </div>
            </div>
            <div class="mt-8 pt-4 border-t flex justify-end gap-3 border-slate-200">
                 <button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600" @click="$store.app.saveState(); $store.app.closeModal()">저장하고 닫기</button>
            </div>
        </div>
    </div>

    <!-- ================================================================= -->
    <!-- UNIFIED SIMPLE MODAL CONTAINER                                    -->
    <!-- ================================================================= -->
    <div id="unified-simple-modal" 
         x-show="['confirm-modal', 'delete-tab-confirm-modal', 'manual-prompt-modal'].includes($store.app.ui.activeModal)"
         x-transition class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal-backdrop" 
         @click.self="$store.app.closeModal()" x-cloak>
        
        <div class="bg-white p-6 rounded-2xl shadow-lg w-full max-h-[90vh] overflow-y-auto"
             :class="{
                 'max-w-sm': ['confirm-modal', 'delete-tab-confirm-modal'].includes($store.app.ui.activeModal),
                 'max-w-2xl': $store.app.ui.activeModal === 'manual-prompt-modal'
             }">
    
            <!-- Template for: confirm-modal (Factory Reset) -->
            <template x-if="$store.app.ui.activeModal === 'confirm-modal'">
                <div>
                    <h3 class="text-xl font-bold mb-4 text-red-600">⚠️ 초기화를 진행하시겠습니까?</h3>
                    <p class="text-slate-600 mb-6">모든 사용자 데이터(키워드, 그룹, 프리셋, 히스토리, 설정 등)가 영구적으로 삭제됩니다. <span class="font-bold">이 작업은 되돌릴 수 없습니다.</span></p>
                    <div class="flex justify-end gap-3">
                        <button class="bg-gray-200 text-slate-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300" @click="$store.app.closeModal()">취소</button>
                        <button class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600" @click="$store.app.factoryReset()">확인</button>
                    </div>
                </div>
            </template>
            
            <!-- Template for: delete-tab-confirm-modal -->
            <template x-if="$store.app.ui.activeModal === 'delete-tab-confirm-modal'">
                <div>
                    <h3 class="text-xl font-bold mb-4 text-red-600">탭 삭제 확인</h3>
                    <p class="text-slate-600 mb-6" x-text="$store.app.ui.modalData.confirmMessage"></p>
                    <div class="flex justify-end gap-3">
                        <button class="bg-gray-200 text-slate-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300" @click="$store.app.closeModal()">취소</button>
                        <button class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600" @click="$store.app.confirmDeleteTab()">삭제</button>
                    </div>
                </div>
            </template>
            
            <!-- Template for: manual-prompt-modal -->
            <template x-if="$store.app.ui.activeModal === 'manual-prompt-modal'">
                 <div>
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-2xl font-bold">수동 프롬프트 편집</h3>
                        <div class="flex items-center gap-2">
                             <button class="text-indigo-600 hover:text-indigo-800 disabled:opacity-50" title="AI 양방향 번역" @click="$store.app.translateManualPrompt()" :disabled="$store.app.ui.isLoadingTranslation">
                                <span class="material-symbols-outlined spinner text-base" x-show="$store.app.ui.isLoadingTranslation" x-cloak>progress_activity</span>
                                <span class="material-symbols-outlined" x-show="!$store.app.ui.isLoadingTranslation">translate</span>
                            </button>
                             <div class="inline-flex rounded-lg shadow-sm" role="group">
                                <button type="button" class="px-3 py-1 text-sm font-medium transition-colors" @click="$store.app.ui.manualPromptPosition = 'prepend'" :class="{'bg-blue-600 text-white': $store.app.ui.manualPromptPosition === 'prepend', 'bg-white text-gray-900': $store.app.ui.manualPromptPosition !== 'prepend' }">맨 앞</button>
                                <button type="button" class="px-3 py-1 text-sm font-medium transition-colors" @click="$store.app.ui.manualPromptPosition = 'append'" :class="{'bg-blue-600 text-white': $store.app.ui.manualPromptPosition === 'append', 'bg-white text-gray-900': $store.app.ui.manualPromptPosition !== 'append' }">맨 뒤</button>
                             </div>
                        </div>
                    </div>
                    <!-- 요구사항 6: Ctrl+Enter 단축키 추가 -->
                    <textarea id="manual-prompt-textarea" class="w-full p-2 border rounded-md border-slate-300 bg-white" rows="6" placeholder="추가하고 싶은 프롬프트를 직접 입력하세요..." x-model="$store.app.promptBoard.manualPrompt" @keydown.ctrl.enter.prevent="$store.app.closeModal()"></textarea>
                    <div class="mt-6 flex justify-end gap-3">
                        <button class="bg-gray-200 text-slate-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300" @click="$store.app.closeModal()">취소</button>
                        <button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600" @click="$store.app.closeModal()">완료</button>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <!-- REFACTORED PRESET/HISTORY MODALS -->
    <template x-ref="listItemComponent">
        <div class="bg-slate-50 p-4 rounded-lg border border-slate-200 flex flex-col gap-2">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <!-- Title for Preset -->
                    <template x-if="type === 'preset'">
                        <div class="flex items-center gap-2">
                            <template x-if="$store.app.ui.editingPresetId !== item.id">
                                <span class="text-lg font-bold" x-text="item.name"></span>
                            </template>
                            <input type="text" x-show="$store.app.ui.editingPresetId === item.id" :value="item.name"
                                   class="text-lg font-bold bg-white border border-blue-500 rounded px-1"
                                   @keydown.enter="$store.app.updatePresetName(item.id, $event.target.value)"
                                   @blur="$store.app.updatePresetName(item.id, $event.target.value)"
                                   :x-ref="`preset-input-${item.id}`"
                                   x-cloak>
                        </div>
                    </template>
                    <!-- Title for History -->
                    <template x-if="type === 'history'">
                        <span class="text-sm font-bold text-slate-500" x-text="new Date(item.id).toLocaleString()"></span>
                    </template>
                    
                    <span class="text-sm text-slate-500">- <span x-text="item.promptLength + '자'"></span></span>

                    <!-- Metadata Icons -->
                     <div class="flex items-center gap-2">
                        <template x-if="type === 'history'">
                            <div class="flex items-center gap-2">
                                <span x-show="item.modelUsed === 'gemini'" title="Gemini 2.5 Flash Image">🍌</span>
                                <span x-show="item.modelUsed === 'imagen'" title="Imagen 3">🔮</span>
                                <span x-show="item.status === 'success'" class="material-symbols-outlined text-green-500" title="성공">check_circle</span>
                                <div x-show="item.status === 'failure'" class="flex items-center gap-1 text-red-500" title="실패">
                                    <span class="material-symbols-outlined">warning</span>
                                    <span class="text-xs font-bold" x-text="{ technical: '기술적 오류', recitation: '저작권', other: '기타', sexually_explicit: '성적 콘텐츠', hate_speech: '혐오 발언', harassment: '괴롭힘', dangerous_content: '폭력/위험' }[item.reason] || ''"></span>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                     <!-- 요구사항 2: 프리셋 이름 편집 방식 변경 -->
                     <button x-show="type === 'preset'" class="text-slate-500 hover:text-slate-600" title="이름 수정" @click="$store.app.ui.editingPresetId = item.id; $nextTick(() => $refs[`preset-input-${item.id}`]?.focus())"><span class="material-symbols-outlined">edit</span></button>
                     <button x-show="type === 'history'" class="text-green-500 hover:text-green-600" title="프리셋으로 저장" @click="$store.app.savePresetFromHistory(item.id)"><span class="material-symbols-outlined">save</span></button>
                     <button class="text-blue-500 hover:text-blue-600" title="불러오기" @click="type === 'preset' ? $store.app.loadPreset(item.id) : $store.app.restoreHistory(item.id)"><span class="material-symbols-outlined">undo</span></button>
                     <button class="text-red-500 hover:text-red-600" title="삭제" @click="type === 'preset' ? $store.app.deletePreset(item.id) : $store.app.deleteHistory(item.id)"><span class="material-symbols-outlined">delete</span></button>
                </div>
            </div>
            <div class="text-sm bg-slate-100 p-3 rounded-md text-slate-700">
                <span x-text="item.promptText"></span>
            </div>
        </div>
    </template>

    <div id="load-preset-modal" x-show="$store.app.ui.activeModal === 'load-preset-modal'" x-transition class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal-backdrop" @click.self="$store.app.closeModal()" x-cloak>
        <div class="bg-white p-6 rounded-2xl shadow-lg w-full max-w-3xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-2xl font-bold">📂 프리셋 관리</h3>
                <div class="flex items-center gap-2">
                    <button class="text-blue-500 hover:text-blue-600 transition-colors" title="현재 프롬프트 저장" @click="$store.app.saveCurrentPromptBoardAsPreset()">
                        <span class="material-symbols-outlined">save</span>
                    </button>
                    <button class="text-slate-500 hover:text-slate-800" @click="$store.app.closeModal()"><span class="material-symbols-outlined">close</span></button>
                </div>
            </div>
            <div class="relative mb-4 flex-shrink-0">
                <span class="material-symbols-outlined absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">search</span>
                <input type="text" placeholder="프리셋 검색..." class="w-full p-2 pl-10 border rounded-md border-slate-300 bg-white" x-model="$store.app.ui.presetSearchTerm">
            </div>
            <div class="overflow-y-auto flex-grow">
                <template x-if="$store.app.filteredPresets.length === 0">
                    <div class="text-center text-slate-500 p-8">저장된 프리셋이 없습니다.</div>
                </template>
                <div class="space-y-4">
                    <template x-for="item in $store.app.filteredPresets" :key="item.id">
                        <div x-data="{ item: item, type: 'preset' }" x-html="$refs.listItemComponent.innerHTML"></div>
                    </template>
                </div>
            </div>
        </div>
    </div>
    
    <div id="history-modal" x-show="$store.app.ui.activeModal === 'history-modal'" x-transition class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal-backdrop" @click.self="$store.app.closeModal()" x-cloak>
        <div class="bg-white p-6 rounded-2xl shadow-lg w-full max-w-3xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-2xl font-bold">📜 프롬프트 히스토리</h3>
                <button class="text-slate-500 hover:text-slate-800" @click="$store.app.closeModal()"><span class="material-symbols-outlined">close</span></button>
            </div>
             <div class="relative mb-4 flex-shrink-0">
                <span class="material-symbols-outlined absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">search</span>
                <input type="text" placeholder="히스토리 검색..." class="w-full p-2 pl-10 border rounded-md border-slate-300 bg-white" x-model="$store.app.ui.historySearchTerm">
            </div>
            <div class="overflow-y-auto flex-grow">
                <template x-if="$store.app.filteredHistory.length === 0">
                    <div class="text-center text-slate-500 p-8">생성 기록이 없습니다.</div>
                </template>
                <div class="space-y-4">
                    <template x-for="item in $store.app.filteredHistory" :key="item.id">
                        <div x-data="{ item: item, type: 'history' }" x-html="$refs.listItemComponent.innerHTML"></div>
                    </template>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast-message" class="toast" x-show="$store.app.ui.toast.show" x-text="$store.app.ui.toast.message" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0 translate-y-full" x-transition:enter-end="opacity-100 translate-y-0" x-transition:leave="transition ease-in duration-300" x-transition:leave-start="opacity-100 translate-y-0" x-transition:leave-end="opacity-0 translate-y-full"></div>

    <!-- Keyword Move Menu -->
    <div x-show="$store.app.ui.moveMenu.visible"
        @click.outside="$store.app.closeKeywordLibraryMoveMenu()"
        x-transition
        :style="`position: absolute; top: ${$store.app.ui.moveMenu.top}px; left: ${$store.app.ui.moveMenu.left}px; z-index: 50;`"
        class="bg-white rounded-lg shadow-2xl border border-slate-200 w-64 max-h-80 overflow-y-auto p-2"
        x-cloak>
        <p class="text-lg font-bold px-2 py-1 text-slate-800">이동할 위치 선택</p>
        <template x-for="group in $store.app.keywordLibrary.userGroups" :key="group.id">
            <div class="my-1">
                <p class="text-base font-bold text-slate-800 px-2 py-1" x-text="group.name"></p>
                <template x-for="tab in group.tabs" :key="group.id + '-' + tab.name">
                    <button 
                        @click="$store.app.moveKeyword(group.id, tab.name)"
                        :disabled="$store.app.ui.moveMenu.fromGroupId === group.id && $store.app.ui.moveMenu.fromTabName === tab.name"
                        class="w-full text-left text-sm px-3 py-1.5 rounded hover:bg-blue-50 disabled:bg-slate-200 disabled:cursor-not-allowed">
                        <span x-text="tab.name"></span>
                    </button>
                </template>
            </div>
        </template>
    </div>

    <!-- Keyword Add Menu -->
    <div x-show="$store.app.ui.addMenu.visible"
        @click.outside="$store.app.closeAddMenu()"
        x-transition
        :style="`position: absolute; top: ${$store.app.ui.addMenu.top}px; left: ${$store.app.ui.addMenu.left}px; z-index: 50;`"
        class="bg-white rounded-lg shadow-2xl border border-slate-200 w-64 max-h-80 overflow-y-auto p-2"
        x-cloak>
        <p class="text-lg font-bold px-2 py-1 text-slate-800">추가할 영역 선택</p>
        <template x-for="area in $store.app.promptBoardAreaInfo" :key="area.key">
            <button 
                @click="$store.app.addKeywordToPromptBoard($store.app.ui.addMenu.keyword, area.key); $store.app.closeAddMenu()"
                class="w-full text-left text-base px-2 py-1.5 rounded hover:bg-blue-50">
                <span x-text="area.title"></span>
            </button>
        </template>
    </div>

</body>
</html>
